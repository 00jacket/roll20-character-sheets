/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 40);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var PFLog = exports.PFLog = {
  // PFLog just a little helper to write to console using fancy type
  l: '%cס§₪₪₪₪§|(Ξ≥≤≥≤≥≤ΞΞΞΞΞΞΞΞΞΞ>    ',
  r: '    <ΞΞΞΞΞΞΞΞΞΞ≥≤≥≤≥≤Ξ)|§₪₪₪₪§ס',
  bg: 'background: linear-gradient(to right,green,white,white,green); color:black;text-shadow: 0 0 8px white;',
  modulecount: 0
};

var PFConsole = exports.PFConsole = {
  log: function log(text) {
    console.log(PFLog.l + text + PFLog.r, PFLog.bg);
  }
};

/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* ---- BEGIN: TheAaronSheet.js ---- */
// Github:   https://github.com/shdwjk/TheAaronSheet/blob/master/TheAaronSheet.js
// By:       The Aaron, Arcane Scriptomancer
// Contact:  https://app.roll20.net/users/104025/the-aaron

var TAS = TAS || (function(){
    'use strict';

    var version = '0.2.4',
        lastUpdate = 1457098091,

        loggingSettings = {
            debug: {
                key:     'debug',
                title:   'DEBUG',
                color: {
                    bgLabel: '#7732A2',
                    label:   '#F2EF40',
                    bgText:  '#FFFEB7',
                    text:    '#7732A2'
                }
            },
            error: {
                key:     'error',
                title:   'Error',
                color: {
                    bgLabel: '#C11713',
                    label:   'white',
                    bgText:  '#C11713',
                    text:    'white'
                }
            },
            warn: {
                key:     'warn',
                title:   'Warning',
                color: {
                    bgLabel: '#F29140',
                    label:   'white',
                    bgText:  '#FFD8B7',
                    text:    'black'
                }
            },
            info: {
                key:     'info',
                title:   'Info',
                color: {
                    bgLabel: '#413FA9',
                    label:   'white',
                    bgText:  '#B3B2EB',
                    text:    'black'
                }
            },
            notice: {
                key:     'notice',
                title:   'Notice',
                color: {
                    bgLabel: '#33C133',
                    label:   'white',
                    bgText:  '#ADF1AD',
                    text:    'black'
                }
            },
            log: {
                key:     'log',
                title:   'Log',
                color: {
                    bgLabel: '#f2f240',
                    label:   'black',
                    bgText:  '#ffff90',
                    text:    'black'
                }
            },
            callstack: {
                key:     'TAS',
                title:   'function',
                color: {
                    bgLabel: '#413FA9',
                    label:   'white',
                    bgText:  '#B3B2EB',
                    text:    'black'
                }
            },
            callstack_async: {
                key:     'TAS',
                title:   'ASYNC CALL',
                color: {
                    bgLabel: '#413FA9',
                    label:   'white',
                    bgText:  '#413FA9',
                    text:    'white'
                }
            },
            TAS: {
                key:     'TAS',
                title:   'TAS',
                color: {
                    bgLabel: 'grey',
                    label:   'black;background:linear-gradient(#304352,#d7d2cc,#d7d2cc,#d7d2cc,#304352)',
                    bgText:  'grey',
                    text:    'black;background:linear-gradient(#304352,#d7d2cc,#d7d2cc,#d7d2cc,#304352)'
                }
            }
        },


        config = {
            debugMode: false,
            logging: {
                log: true,
                notice: true,
                info: true,
                warn: true,
                error: true,
                debug: false
            }
        },

        callstackRegistry = [],
		queuedUpdates = {}, //< Used for delaying saves till the last momment.

    complexType = function(o){
        switch(typeof o){
            case 'string':
                return 'string';
            case 'boolean':
                return 'boolean';
            case 'number':
                return (_.isNaN(o) ? 'NaN' : (o.toString().match(/\./) ? 'decimal' : 'integer'));
            case 'function':
                return 'function: '+(o.name ? o.name+'()' : '(anonymous)');
            case 'object':
                return (_.isArray(o) ? 'array' : (_.isArguments(o) ? 'arguments' : ( _.isNull(o) ? 'null' : 'object')));
            default:
                return typeof o;
        }
    },

	dataLogger = function(primaryLogger,secondaryLogger,data){
        _.each(data,function(m){
            var type = complexType(m);
            switch(type){
                case 'string':
                    primaryLogger(m);
                    break;
                case 'undefined':
                case 'null':
                case 'NaN':
                    primaryLogger('['+type+']');
                    break;
                case 'number':
                case 'not a number':
                case 'integer':
                case 'decimal':
                case 'boolean':
                    primaryLogger('['+type+']: '+m);
                    break;
                default:
                    primaryLogger('['+type+']:=========================================');
                    secondaryLogger(m);
                    primaryLogger('=========================================================');
                    break;
            }
        });
	},


    colorLog = function(options){
        var coloredLoggerFunction,
            key = options.key,
            label = options.title || 'TAS',
            lBGColor = (options.color && options.color.bgLabel) || 'blue',
            lTxtColor = (options.color && options.color.label) || 'white',
            mBGColor = (options.color && options.color.bgText) || 'blue',
            mTxtColor = (options.color && options.color.text) || 'white';

        coloredLoggerFunction = function(message){
            console.log(
                '%c '+label+': %c '+message + ' ',
                'background-color: '+lBGColor+';color: '+lTxtColor+'; font-weight:bold;',
                'background-color: '+mBGColor+';color: '+mTxtColor+';'
            ); 
        };
        return function(){
            if('TAS'===key || config.logging[key]){
               dataLogger(coloredLoggerFunction,function(m){console.log(m);},_.toArray(arguments)); 
            }
        };
    },

    logDebug  = colorLog(loggingSettings.debug),
    logError  = colorLog(loggingSettings.error),
    logWarn   = colorLog(loggingSettings.warn),
    logInfo   = colorLog(loggingSettings.info),
    logNotice = colorLog(loggingSettings.notice),
    logLog    = colorLog(loggingSettings.log),
    log       = colorLog(loggingSettings.TAS),
    logCS     = colorLog(loggingSettings.callstack),
    logCSA    = colorLog(loggingSettings.callstack_async),

    registerCallstack = function(callstack,label){
        var idx=_.findIndex(callstackRegistry,function(o){
            return (_.difference(o.stack,callstack).length === _.difference(callstack,o.stack).length) &&
                _.difference(o.stack,callstack).length === 0 &&
                o.label === label;
        });
        if(-1 === idx){
            idx=callstackRegistry.length;
            callstackRegistry.push({
                stack: callstack,
                label: label
            });
        }
        return idx;
    },

    setConfigOption = function(options){
        var newconf =_.defaults(options,config);
        newconf.logging=_.defaults(
            (options && options.logging)||{},
            config.logging
        );
        config=newconf;
    },
    
    debugMode = function(){
        config.logging.debug=true;
        config.debugMode = true;
    },

    getCallstack = function(){
        var e = new Error('dummy'),
            stack = _.map(_.rest(e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
            .split('\n')),function(l){
                return l.replace(/\s+.*$/,'');
            });
        return stack;
    },
    logCallstackSub = function(cs){
        var matches, csa;
        _.find(cs,function(line){
            matches = line.match(/TAS_CALLSTACK_(\d+)/);
            if(matches){
               csa=callstackRegistry[matches[1]];
               logCSA( '===================='+(csa.label ? '> '+csa.label+' <' : '')+'====================');
               logCallstackSub(csa.stack);
               return true;
            } 
            logCS(line);
            return false;
        });
    },
    logCallstack = function(){
        var cs;
        if(config.debugMode){
            cs = getCallstack();
            cs.shift();
            log('==============================> CALLSTACK <==============================');
            logCallstackSub(cs);
            log('=========================================================================');
        }
    },


    wrapCallback = function (label, callback, context){
        var callstack;
        if('function' === typeof label){
            context=callback;
            callback=label;
            label=undefined;
        }
        if(!config.debugMode){
            return (function(cb,ctx){
                return function(){
                    cb.apply(ctx||{},arguments);
                };
            }(callback,context));
        }
        
        callstack = getCallstack();
        callstack.shift();
        
        return (function(cb,ctx,cs,lbl){
            var ctxref=registerCallstack(cs,lbl);

            /*jshint -W054 */
            return new Function('cb','ctx','TASlog',
                "return function TAS_CALLSTACK_"+ctxref+"(){"+
                    "TASlog('Entering: '+(cb.name||'(anonymous function)'));"+
                    "cb.apply(ctx||{},arguments);"+
                    "TASlog('Exiting: '+(cb.name||'(anonymous function)'));"+
                "};")(cb,ctx,log);
            /*jshint +W054 */
        }(callback,context,callstack,label));
    },


    prepareUpdate = function( attribute, value ){
        queuedUpdates[attribute]=value;
    },

    applyQueuedUpdates = function() {
      setAttrs(queuedUpdates);
      queuedUpdates = {};
    },

	namesFromArgs = function(args,base){
        return _.chain(args)
            .reduce(function(memo,attr){
                if('string' === typeof attr) {
                    memo.push(attr);
                } else if(_.isArray(args) || _.isArguments(args)){
                    memo = namesFromArgs(attr,memo);
                }
                return memo;
            },(_.isArray(base) && base) || [])
            .uniq()
            .value();
	},

	addId = function(obj,value){
		Object.defineProperty(obj,'id',{
			value: value,
			writeable: false,
			enumerable: false
		});
	},

	addProp = function(obj,prop,value,fullname){
		(function(){
            var pname=(_.contains(['S','F','I','D'],prop) ? '_'+prop : prop),
			    full_pname = fullname || prop,
                pvalue=value;

            _.each(['S','I','F'],function(p){
                if( !_.has(obj,p)){
                    Object.defineProperty(obj, p, {
                        value: {},
                        enumerable: false,
                        readonly: true
                    });
                }
            });
            if( !_.has(obj,'D')){
                Object.defineProperty(obj, 'D', {
                    value: _.reduce(_.range(10),function(m,d){
                            Object.defineProperty(m, d, {
                                value: {},
                                enumerable: true,
                                readonly: true
                            });
                            return m;
                        },{}),
                    enumerable: false,
                    readonly: true
                });
            }


            // Raw value
			Object.defineProperty(obj, pname, {
                enumerable: true,
				set: function(v){
                    if(v!==pvalue) {
                        pvalue=v;
                        prepareUpdate(full_pname,v);
                    }
				},
				get: function(){
					return pvalue;
				}
			});
            
            // string value
			Object.defineProperty(obj.S, pname, {
                enumerable: true,
				set: function(v){
                    var val=v.toString();
                    if(val !== pvalue) {
                        pvalue=val;
                        prepareUpdate(full_pname,val);
                    }
				},
				get: function(){
					return pvalue.toString();
				}
			});

            // int value
			Object.defineProperty(obj.I, pname, {
                enumerable: true,
				set: function(v){
                    var val=parseInt(v,10) || 0;
                    if(val !== pvalue){
                        pvalue=val;
                        prepareUpdate(full_pname,val);
                    }
				},
				get: function(){
					return parseInt(pvalue,10) || 0;
				}
			});

            // float value
			Object.defineProperty(obj.F, pname, {
                enumerable: true,
				set: function(v){
                    var val=parseFloat(v) || 0;
                    if(val !== pvalue) {
                        pvalue=val;
                        prepareUpdate(full_pname,val);
                    }
				},
				get: function(){
					return parseFloat(pvalue) || 0;
				}
			});
            _.each(_.range(10),function(d){
                Object.defineProperty(obj.D[d], pname, {
                    enumerable: true,
                    set: function(v){
                        var val=(parseFloat(v) || 0).toFixed(d);
                        if(val !== pvalue){
                            pvalue=val;
                            prepareUpdate(full_pname,val);
                        }
                    },
                    get: function(){
                        return (parseFloat(pvalue) || 0).toFixed(d);
                    }
                });
            });

		}());
	},
	
	repeating = function( section ) {
		return (function(s){
			var sectionName = s,
				attrNames = [],
				fieldNames = [],
				operations = [],
                after = [],
			
			repAttrs = function TAS_Repeating_Attrs(){
				attrNames = namesFromArgs(arguments,attrNames);
				return this;
			},
			repFields = function TAS_Repeating_Fields(){
				fieldNames = namesFromArgs(arguments,fieldNames);
				return this;
			},
			repReduce = function TAS_Repeating_Reduce(func, initial, final, context) { 
				operations.push({
                    type: 'reduce',
                    func: (func && _.isFunction(func) && func) || _.noop,
                    memo: (_.isUndefined(initial) && 0) || initial,
                    final: (final && _.isFunction(final) && final) || _.noop,
                    context: context || {}
                });
				return this;
			},
			repMap = function TAS_Repeating_Map(func, final, context) {
				operations.push({
                    type: 'map',
                    func: (func && _.isFunction(func) && func) || _.noop,
                    final: (final && _.isFunction(final) && final) || _.noop,
                    context: context || {}
                });
				return this;
			},
            repEach = function TAS_Repeating_Each(func, final, context) {
				operations.push({
                    type: 'each',
                    func: (func && _.isFunction(func) && func) || _.noop,
                    final: (final && _.isFunction(final) && final) || _.noop,
                    context: context || {}
                });
				return this;
            },
            repTap = function TAS_Repeating_Tap(final, context) {
				operations.push({
                    type: 'tap',
                    final: (final && _.isFunction(final) && final) || _.noop,
                    context: context || {}
                });
				return this;
            },
            repAfter = function TAS_Repeating_After(callback,context) {
				after.push({
                    callback: (callback && _.isFunction(callback) && callback) || _.noop,
                    context: context || {}
                });
				return this;
            },
			repExecute = function TAS_Repeating_Execute(callback,context){
				var rowSet = {},
					attrSet = {},
					fieldIds = [],
					fullFieldNames = [];

                repAfter(callback,context);

				// call each operation per row.
				// call each operation's final
				getSectionIDs("repeating_"+sectionName,function(ids){
					fieldIds = ids;
					fullFieldNames = _.reduce(fieldIds,function(memo,id){
						return memo.concat(_.map(fieldNames,function(name){
							return 'repeating_'+sectionName+'_'+id+'_'+name;  
						}));
					},[]);
					getAttrs( _.uniq(attrNames.concat(fullFieldNames)), function(values){
						_.each(attrNames,function(aname){
							if(values.hasOwnProperty(aname)){
								addProp(attrSet,aname,values[aname]);
							}
						});

						rowSet = _.reduce(fieldIds,function(memo,id){
							var r={};
							addId(r,id);
							_.each(fieldNames,function(name){
								var fn = 'repeating_'+sectionName+'_'+id+'_'+name;  
								addProp(r,name,values[fn],fn);
							});

							memo[id]=r;

							return memo;
						},{});

                        _.each(operations,function(op){
                            var res;
                            switch(op.type){
                                case 'tap':
                                    _.bind(op.final,op.context,rowSet,attrSet)();
                                    break;

                                case 'each':
                                    _.each(rowSet,function(r){
                                        _.bind(op.func,op.context,r,attrSet,r.id,rowSet)();
                                    });
                                    _.bind(op.final,op.context,rowSet,attrSet)();
                                    break;

                                case 'map':
                                    res = _.map(rowSet,function(r){
                                        return _.bind(op.func,op.context,r,attrSet,r.id,rowSet)();
                                    });
                                    _.bind(op.final,op.context,res,rowSet,attrSet)();
                                    break;

                                case 'reduce':
                                    res = op.memo;
                                    _.each(rowSet,function(r){
                                        res = _.bind(op.func,op.context,res,r,attrSet,r.id,rowSet)();
                                    });
                                    _.bind(op.final,op.context,res,rowSet,attrSet)();
                                    break;
                            }
                        });

                        // finalize attrs
                        applyQueuedUpdates();
                        _.each(after,function(op){
                            _.bind(op.callback,op.context)();
                        });
					});
				});
			};
				
			return {
				attrs: repAttrs,
				attr: repAttrs,

				column: repFields,
				columns: repFields,
				field: repFields,
				fields: repFields,

				reduce: repReduce,
				inject: repReduce,
				foldl: repReduce,

				map: repMap,
				collect: repMap,

				each: repEach,
                forEach: repEach,

                tap: repTap,
                'do': repTap,

				after: repAfter,
				last: repAfter,
				done: repAfter,

				execute: repExecute,
				go: repExecute,
				run: repExecute
			};
		}(section));
	},


    repeatingSimpleSum = function(section, field, destination){
        repeating(section)
            .attr(destination)
            .field(field)
            .reduce(function(m,r){
                return m + (r.F[field]);
            },0,function(t,r,a){
                a.S[destination]=t;
            })
            .execute();
    };

	console.log('%c•.¸¸.•*´¨`*•.¸¸.•*´¨`*•.¸  The Aaron Sheet  v'+version+'  ¸.•*´¨`*•.¸¸.•*´¨`*•.¸¸.•','background: linear-gradient(to right,green,white,white,green); color:black;text-shadow: 0 0 8px white;');
	console.log('%c•.¸¸.•*´¨`*•.¸¸.•*´¨`*•.¸  Last update: '+(new Date(lastUpdate*1000))+'  ¸.•*´¨`*•.¸¸.•*´¨`*•.¸¸.•','background: linear-gradient(to right,green,white,white,green); color:black;text-shadow: 0 0 8px white;');


    return {
        /* Repeating Sections */
        repeatingSimpleSum: repeatingSimpleSum,
		repeating: repeating,

        /* Configuration */
        config: setConfigOption,

        /* Debugging */
        callback: wrapCallback,
        callstack: logCallstack,
        debugMode: debugMode,
        _fn: wrapCallback,

        /* Logging */
        debug: logDebug,
        error: logError,
        warn: logWarn,
        info: logInfo,
        notice: logNotice,
        log: logLog
    };
}());

/* ---- END: TheAaronSheet.js ---- */



/*** EXPORTS FROM exports-loader ***/
module.exports = TAS;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = window._

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = {
	/* Pathfinder SHEET constants */
	version: 1.58,
	/***************************************Lists of Fields ************************************************************/
	//add any new repeating sections here. This is the word after "repeating_"
	repeatingSections: ["weapon", "ability", "class-ability", "feat", "racial-trait", "trait", "item", "npc-spell-like-abilities", "mythic-ability", "mythic-feat", "buff", "spells"],
	//repeating sections that have used and used|max and max-calculation fields
	repeatingMaxUseSections: ["class-ability", "feat", "racial-trait", "trait", "mythic-ability", "mythic-feat", "ability"],

	//attribute of a dropdown mapped to attribute to write evaluated number to.
	//all simple dropdowns that do not need to call any other function when evaluating besides setDropdownValue and findAbilityInString
	dropdowns: {
		"HP-ability": "HP-ability-mod",
		"init-ability": "init-ability-mod",
		"Fort-ability": "Fort-ability-mod",
		"Ref-ability": "Ref-ability-mod",
		"Will-ability": "Will-ability-mod",
		"melee-ability": "melee-ability-mod",
		"melee2-ability": "melee2-ability-mod",
		"ranged-ability": "ranged-ability-mod",
		"ranged2-ability": "ranged2-ability-mod",
		"CMB-ability": "CMB-ability-mod",
		"CMB2-ability": "CMB2-ability-mod",
		"sanity-ability": "sanity-ability-mod"
	},
	//attribute of a macro, mapped to attribute to write evaluation to
	//all simple macros that do not need to call other functions besides evaluateAndSetNumber
	equationMacros: {
		"init-misc": "init-misc-mod",
		"HP-formula-macro-text": "HP-formula-mod",
		"Max-Skill-Ranks-Misc": "Max-Skill-Ranks-mod",
		"SR-macro-text": "SR",
		"spellclass-0-SP_misc": "spellclass-0-SP-mod",
		"spellclass-1-SP_misc": "spellclass-1-SP-mod",
		"spellclass-2-SP_misc": "spellclass-2-SP-mod",
		"customa1": "customa1-mod",
		"customa2": "customa2-mod",
		"customa3": "customa3-mod",
		"customa4": "customa4-mod_max",
		"customa5": "customa5-mod_max",
		"customa6": "customa6-mod_max",
		"customa7": "customa7-mod_max",
		"customa8": "customa8-mod_max",
		"customa9": "customa9-mod_max",
		"customa10": "customa10-mod",
		"customa11": "customa11-mod",
		"customa12": "customa12-mod",
		"sanity_score_misc": "sanity_score_misc-mod",
		"sanity_threshold_misc": "sanity_threshold_misc-mod"
	},
	//the 3 spell classes at top of spells page
	spellClassIndexes: ["0", "1", "2"],
	silentParams: { silent: true },
	minusreg: /\-|&Mdash;|&\#8212;|\u2013|\u2014|\u2212|\u02d7/,
	dashtominusreg: /&Mdash;|&\#8212;|\u2013|\u2014|\u2212|\u02d7/g,
	critreg: /\/(\d+)[\-|\u2013|\u2014|\u2212|\u02d7]20(?:[x\u00d7](\d+)){0,1}/,
	critmultreg: /[x\u00d7](\d+)/,
	diceDiereg: /(\d+)d(\d+)\s*(?:([\+|\-|\u2013|\u2014|\u2212|\u02d7])(\d+)){0,1}/,
	diceDieregOneGroup: /(\d+d\d+\s*(?:[\+|\-|\u2013|\u2014|\u2212|\u02d7]\d+){0,1})/g,
	findBadNegDice: /(\d+)d([123468])([13456789])/g, // invalid: 2nd digit not 0 or 2 actually what if it's d10-1? d101?d1012?
	findBadCritRange: /\/(\d+)20/g
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.findAndReplaceFields = findAndReplaceFields;
exports.evaluateExpression = evaluateExpression;
exports.evaluateAndSetNumber = evaluateAndSetNumber;
exports.getDropdownValue = getDropdownValue;
exports.setDropdownValue = setDropdownValue;
exports.getRowTotal = getRowTotal;
exports.updateRowTotal = updateRowTotal;
exports.escapeForRegExp = escapeForRegExp;
exports.escapeForMacroCall = escapeForMacroCall;
exports.escapeForRollTemplate = escapeForRollTemplate;
exports.escapeForChatLinkButton = escapeForChatLinkButton;
exports.getRowId = getRowId;
exports.getAttributeName = getAttributeName;
exports.getRepeatingIDStr = getRepeatingIDStr;
exports.cartesianAppend = cartesianAppend;
exports.cartesianProduct = cartesianProduct;
exports.trimBoth = trimBoth;
exports.splitByCommaIgnoreParens = splitByCommaIgnoreParens;
exports.deleteRepeating = deleteRepeating;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _ExExp = __webpack_require__(32);

var ExExp = _interopRequireWildcard(_ExExp);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* for interaction with ExExp, and some basic utils that have nothing to do with Pathfinder rules. */
/** Determines if string can be evaluated to a number
 * ensures:  no macro calls, dropdowns, or keep highest/lowest more than 1
 * allows: floor, abs, kh1, kl1,  ceil, round, max, min
 *@param {string} preeval string to examine
 *@returns {boolean} true if string will evaluate to a number.
 */
function validNumericStr(preeval) {
	var anyIllegal = preeval.match(/\||\?|&|\{|\}|k[h,l][^1]/);
	if (anyIllegal) {
		return false;
	}
	anyIllegal = preeval.replace(/floor|ceil|round|abs|max|min|kh1|kl1/g, '');
	anyIllegal = anyIllegal.match(/[a-zA-Z]/);
	if (anyIllegal) {
		return false;
	}
	return true;
}
/** searches a string for @{attribute} and replaces those with their values, passes result to the callback
 * if error then passes null
 * @param {string} stringToSearch = string containing one or more @{fieldname}
 * @param {function(string)} callback when done passes resultant string to callback
 */
function findAndReplaceFields(stringToSearch, callback) {
	var fieldnames;
	if (typeof callback !== "function") {
		return;
	}
	if (!stringToSearch) {
		callback(null);
		return;
	}
	try {
		stringToSearch = stringToSearch.split("selected|").join("");
		stringToSearch = stringToSearch.split("target|").join("");
		stringToSearch = stringToSearch.replace(/\|max\}/g, '_max}');
		fieldnames = stringToSearch.match(/\@\{[^}]+\}/g);
		if (!fieldnames) {
			callback(stringToSearch);
			return;
		}
		fieldnames = fieldnames.sort();
		fieldnames = _underscore2.default.uniq(fieldnames, true);
		fieldnames = _underscore2.default.map(fieldnames, function (field) {
			return field.slice(2, -1);
		});
		getAttrs(fieldnames, function (values) {
			var evalstr = stringToSearch,
			    innermatches = null,
			    initialsplit;
			try {
				_underscore2.default.each(fieldnames, function (field) {
					//evalstr = evalstr.replace(  new RegExp(escapeForRegExp('@{'+field+'}'),'g'), values[field]);
					initialsplit = evalstr.split('@{' + field + '}');
					evalstr = initialsplit.join(values[field]);
				});
				innermatches = evalstr.match(/\@\{[^}]+\}/g);
			} catch (err2) {
				_exportsLoaderTASTheAaronSheet2.default.error("SWUtils.findAndReplaceFields err2", err2);
				evalstr = null;
			} finally {
				if (innermatches) {
					findAndReplaceFields(evalstr, callback);
				} else {
					callback(evalstr);
				}
			}
		});
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("SWUtils.findAndReplaceFields", err);
		callback(null);
	}
}
/** Replaces kl1 and kh1 with min and max
 * example: replaces {x,y}kh1 with min(x,y)
 * @param {string} str the string to search
 * @returns {string} the resultant string after performing the replace
 */
function convertKL1KH1toMinMax(str) {
	var matches;
	//TAS.debug("at convertKL1KH1toMinMax for "+str) ;
	if (str) {
		matches = str.match(/(\{[^}]+\})(kh1|kl1)(?!.*\1)/g);
		//TAS.debug("matches are:",matches);
		if (matches && matches.length > 0) {
			str = _underscore2.default.reduce(matches, function (memo, match) {
				var isMin = /kl1$/.test(match),
				    isMax = /kh1$/.test(match),
				    newFunc = isMin ? "min" : isMax ? "max" : "",
				    newMatch = match.slice(1, match.length - 4),
				    replaceStr = newFunc + "(" + newMatch + ")";
				return memo.replace(match, replaceStr);
			}, str);
		}
	}
	return str;
}
/** Reads in the string, evaluates it to a single number, passes that number to a callback
 * calls callback with: the number, 0 (if exprStr empty), or null if an error is encountered
 *@param {string} exprStr A string containing a mathematical expression, possibly containing references to fields such as @{myfield}
 *@param {function(Number)} callback a function taking one parameter - could be int or float
 */
function evaluateExpression(exprStr, callback) {
	var bmatches1 = 0,
	    bmatches2 = 0,
	    pmatches1 = 0,
	    pmatches2 = 0,
	    smatches1 = 0,
	    smatches2 = 0;
	if (typeof callback !== "function") {
		return;
	}
	if (exprStr === "" || exprStr === null || exprStr === undefined) {
		callback(0);
		return;
	}
	//verify that same number of parenthesis exists
	bmatches1 = (exprStr.match(/\(/g) || []).length;
	bmatches2 = (exprStr.match(/\)/g) || []).length;
	pmatches1 = (exprStr.match(/\{/g) || []).length;
	pmatches2 = (exprStr.match(/\}/g) || []).length;
	smatches1 = (exprStr.match(/\[/g) || []).length;
	smatches2 = (exprStr.match(/\]/g) || []).length;
	if (bmatches1 !== bmatches2 || pmatches1 !== pmatches2 || smatches1 !== smatches2) {
		_exportsLoaderTASTheAaronSheet2.default.warn("evaluateExpression: Mismatched brackets, cannot evaluate:" + exprStr);
		callback(null);
		return;
	}

	findAndReplaceFields(exprStr, function (replacedStr) {
		var evaluated, newexprStr;
		//TAS.debug("search and replace of " + exprStr + " resulted in " + replacedStr);
		if (replacedStr === null || replacedStr === undefined) {
			callback(null);
			return;
		}
		try {
			replacedStr = replacedStr.replace(/\s+/g, '').replace(/\[\[/g, "(").replace(/\]\]/g, ")").replace(/\[/g, "(").replace(/\]/g, ")");
			newexprStr = convertKL1KH1toMinMax(replacedStr);
			//TAS.debug("replacedStr is now "+newexprStr);
			if (newexprStr !== replacedStr) {
				replacedStr = newexprStr;
			}
			if (!isNaN(Number(replacedStr)) && isFinite(replacedStr)) {
				evaluated = parseFloat(replacedStr);
				if (!isNaN(evaluated)) {
					callback(evaluated);
					return;
				}
			}
			if (typeof replacedStr !== "undefined" && replacedStr !== null && validNumericStr(replacedStr)) {
				evaluated = ExExp.handleExpression(replacedStr);
				if (!isNaN(evaluated)) {
					callback(evaluated);
				} else {
					_exportsLoaderTASTheAaronSheet2.default.warn("cannot evaluate this to number: " + exprStr + " came back with " + replacedStr);
					callback(null);
				}
			} else {
				_exportsLoaderTASTheAaronSheet2.default.warn("cannot evaluate this to number: " + exprStr + " came back with " + replacedStr);
				callback(null);
			}
		} catch (err3) {
			_exportsLoaderTASTheAaronSheet2.default.error("error trying to convert to number:" + err3);
			callback(null);
		}
	});
}
/** evaluateAndSetNumber
 * Examines the string in readField, and tests to see if it is a number
 * if it's a number immediately write it to writeField.
 * if not, then replace any @{field} references with numbers, and then evaluate it
 * as a mathematical expression till we find a number.
 *
 * note this is NOT recursive, you can't point one field of
 *
 * @param {string} readField= field to read containing string to parse
 * @param {string} writeField= field to write to
 * @param {number} defaultVal= optional, default to set if we cannot evaluate the field. If not supplied assume 0
 * @param {function} callback - function(newval, oldval, ischanged)
 * @param {boolean} silently if true set new val with {silent:true}
 * @param {boolean} dontSetErrorFlag if true and we could not evaluate, then set attribute named writeField+"_error" to 1
 * @param {function} errcallback  call if there was an error parsing string function(newval, oldval, ischanged)
 */
function evaluateAndSetNumber(readField, writeField, defaultVal, callback, silently, errcallback) {
	var done = function done(a, b, c, currError) {
		var donesetter = {};
		if (currError) {
			donesetter[writeField + '_error'] = 0;
			setAttrs(donesetter, { silent: true });
		}
		if (typeof callback === "function") {
			callback(a, b, c);
		}
	},
	    errordone = function errordone(a, b, c, currError) {
		var donesetter = {};
		//TAS.debug("leaving set of "+ writeField+" with old:"+b+", new:"+c+" is changed:"+ c+" and curreerror:"+currError);
		if (!currError) {
			donesetter[writeField + '_error'] = 1;
			setAttrs(donesetter, { silent: true });
		}
		if (typeof errcallback === "function") {
			errcallback(a, b, c);
		} else if (typeof callback === "function") {
			callback(a, b, c);
		}
	};
	getAttrs([readField, writeField, writeField + "_error"], function (values) {
		var setter = {},
		    params = {},
		    trueDefault = 0,
		    currVal = 0,
		    isError = 0,
		    currError = 0,
		    isChanged = false,
		    value = 0;
		try {
			if (silently) {
				params.silent = true;
			}
			currError = parseInt(values[writeField + "_error"], 10) || 0;
			trueDefault = defaultVal || 0;
			currVal = parseInt(values[writeField], 10);
			value = Number(values[readField]);
			//check for blank
			if (typeof values[readField] === "undefined" || !values[readField] || values[readField] === null || values[readField] === "") {
				//if value of readField is blank then set to defaultval.
				value = trueDefault;
				if (currVal !== value || isNaN(currVal)) {
					setter[writeField] = value;
					setAttrs(setter, params, function () {
						done(value, currVal, true, currError);
					});
				} else {
					done(value, currVal, false, currError);
				}
			} else if (!isNaN(value)) {
				//check for number
				if (currVal !== value) {
					setter[writeField] = value;
					setAttrs(setter, params, function () {
						done(value, currVal, true, currError);
					});
				} else {
					done(value, currVal, false, currError);
				}
			} else {
				//pass to evaluateExpression 
				evaluateExpression(values[readField], function (value2) {
					try {
						if (value2 === null || value2 === undefined || isNaN(value2)) {
							isError = 1;
							value2 = trueDefault;
							//TAS.debug("setting "+ writeField+" to " +value2);
						}
						if (isNaN(currVal) || currVal !== value2) {
							setter[writeField] = value2;
						}
						if (_underscore2.default.size(setter) > 0) {
							isChanged = true;
						}
					} catch (err2) {
						_exportsLoaderTASTheAaronSheet2.default.error("SWUtils.evaluateAndSetNumber error after call to evaluateExpression ", err2);
						isError = 1;
					} finally {
						setAttrs(setter, params, function () {
							if (!isError) {
								done(value2, currVal, isChanged, currError);
							} else {
								errordone(value2, currVal, isChanged, currError);
							}
						});
					}
				});
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("SWUtils.evaluateAndSetNumber", err);
			errordone(0, 0, 0, 0);
			//setter[writeField+'_error']=1;
			//setAttrs(setter,{silent:true},function(){errordone(value, currVal, false,currError);});
		}
	});
}
/** Reads dropdown value
 * determines attribute referenced, gets that attribute value, passes it to callback.
 * similar to evaluateAndSetNumber but uses a synchronus function to perform search and replace, and assumes the string is only one value not an expression.
 * necessary because some dropdowns have other text in the dropdowns, so we can't use the dropdown value exactly as is.
 * called by setDropdownValue
 * @param {string} readField the attribute name of dropdown we are looking at
 * @param {function} synchrousFindAttributeFunc reads in the value of the dropdown field, and returns the exact name of the attribute to look up (since some dropdowns have other text in value)
 * @param {function(int)} callback pass the value the dropdown selection represents
 *   exceptions: if readField is not found pass in "", if readField is 0 or starts with 0 pass in 0.
 */
function getDropdownValue(readField, synchrousFindAttributeFunc, callback) {
	if (!readField || callback && typeof callback !== "function" || typeof synchrousFindAttributeFunc !== "function") {
		return;
	}
	getAttrs([readField], function (values) {
		var fieldToFind = values[readField],
		    foundField = "";
		if (typeof fieldToFind === "undefined" || fieldToFind === null) {
			callback("");
		} else if (fieldToFind === "0" || fieldToFind === 0 || fieldToFind.indexOf("0") === 0) {
			//select = none
			callback(0);
		} else {
			foundField = synchrousFindAttributeFunc(fieldToFind);
			getAttrs([foundField], function (v) {
				var valueOf = parseInt(v[foundField], 10) || 0;
				callback(valueOf, foundField);
			});
		}
	});
}
/** Looks at a dropdown value, and sets writeField(s) with the number to which selected option refers.
 * calls getDropdownValue
 * @param {string} readField the dropdown field
 * @param {string_or_Array} writeFields Field(s) to write the value to
 * @param {function} synchrousFindAttributeFunc takes value of @readField and says what the lookup field is.
 * @param {function(int)} callback (optional) if we need to update the field, call this function
 *         with the value we set as the only parameter.
 * @param {boolean} silently if true call setAttrs with {silent:true}
 */
function setDropdownValue(readField, writeFields, synchrousFindAttributeFunc, callback, silently) {
	var done = function done(newval, currval, changed) {
		if (typeof callback === "function") {
			callback(newval, currval, changed);
		}
	};
	getDropdownValue(readField, synchrousFindAttributeFunc, function (valueOf) {
		var params = {};
		if (silently) {
			params.silent = true;
		}
		if (Array.isArray(writeFields) && writeFields.length === 1) {
			writeFields = writeFields[0];
		}
		if (typeof writeFields === "string") {
			getAttrs([writeFields], function (v) {
				var currValue = parseInt(v[writeFields], 10),
				    setter = {};
				//TAS.debug("setDropdownValue, readField:" + readField + ", currValue:" + currValue + ", newValue:" + valueOf);
				if (currValue !== valueOf || isNaN(currValue)) {
					setter[writeFields] = valueOf;
					setAttrs(setter, params, function () {
						done(valueOf, currValue, true);
					});
				} else {
					done(valueOf, currValue, false);
				}
			});
		} else if (Array.isArray(writeFields)) {
			getAttrs(writeFields, function (v) {
				var i = 0,
				    setter = {};
				for (i = 0; i < writeFields.length; i++) {
					if (parseInt(v[writeFields[i]], 10) !== valueOf) {
						setter[writeFields[i]] = valueOf;
					}
				}
				if (_underscore2.default.size(setter) > 0) {
					setAttrs(setter, params, function () {
						done(valueOf, 0, true);
					});
				} else {
					done(valueOf, 0, false);
				}
			});
		}
	});
}
/** getRowTotal return newvalue, currentvalue, allvalues in callback. Summed up floats and round total to int. 
 * THIS IS PROBABLY SLOWER THAN DOING IT YOURSELF, just wrote to make things simpler.
 * @param {Array} fields array of field names to be added up, EXCEPT the first field which is ignored (at index 0) which is the total current value
 * @param {number} bonus a number that is added to the other fields.
 * @param {Array} penalties array of fieldnames whose values are to be subtracted from the total
 * @param {boolean} totalIsFloat true if we should not round the total to int.
 * @param {function(number,number)} callback call this with: new total, current total
 * @param {function} errorCallback call if error attempting to add.
 */
function getRowTotal(fields, bonus, penalties, totalIsFloat, callback, errorCallback) {
	var readFields;
	if (typeof callback !== "function" || typeof errorCallback !== "function") {
		return;
	}
	try {
		if (!fields || !Array.isArray(fields) || fields.length === 0) {
			return;
		}
		if (penalties && Array.isArray(penalties) && penalties.length > 0) {
			readFields = fields.concat(penalties);
		} else {
			readFields = fields;
		}
	} catch (err2) {
		_exportsLoaderTASTheAaronSheet2.default.error("SWUtils.getRowTotal catastrophic error: ", err2);
		errorCallback();
		return;
	}
	getAttrs(readFields, function (v) {
		var currValue = totalIsFloat ? parseFloat(v[fields[0]]) : parseInt(v[fields[0]], 10),
		    newValue = 0,
		    penalty = 0,
		    i; //, setter = {}
		try {
			//remember start at 1
			for (i = 1; i < fields.length; i++) {
				newValue += parseFloat(v[fields[i]]) || 0;
			}
			if (bonus && !isNaN(parseInt(bonus, 10))) {
				newValue += parseFloat(bonus);
			}
			if (penalties) {
				for (i = 0; i < penalties.length; i++) {
					penalty += parseFloat(v[penalties[i]]) || 0;
				}
				newValue -= penalty;
			}
			if (!totalIsFloat) {
				newValue = Math.floor(newValue);
			}
			callback(newValue, currValue);
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("SWUtils.getRowTotal", err);
			errorCallback();
		}
	});
}
/** Adds up numbers and puts it in the first field of the fields array.
 * All numbers are added up as FLOATS, and then FLOOR is used to round the sum down
 * @param {Array} fields array of field names to be added up, EXCEPT the first field. fields[0] MUST be the total field
 * @param {number} bonus a number that is added to the other fields.
 * @param {Array} penalties array of fieldnames whose values are to be subtracted from the total
 * @param {boolean} totalIsFloat true if we should not round the total to int.
 * @param {function(number,number)} callback optional call this with two values: the new total, old total
 * @param {boolean} silently if true call setAttrs with {silent:true}
 */
function updateRowTotal(fields, bonus, penalties, totalIsFloat, callback, silently, force) {
	var done = function done() {
		if (typeof callback === "function") {
			callback();
		}
	};
	getRowTotal(fields, bonus, penalties, totalIsFloat, function (newValue, currValue) {
		var setter = {},
		    params = {};
		if (force || newValue !== currValue) {
			setter[fields[0]] = newValue;
		}
		if (_underscore2.default.size(setter) > 0) {
			if (silently) {
				params.silent = true;
			}
			setAttrs(setter, params, done);
		} else {
			done();
		}
	}, done);
}
/** Escapes special chars for regex
 *@param {string} str the string to examine
 *@param {boolean} escapeSpaces if we should replace any space with \s* (caller can use it for matching purposes)
 *@returns {string} resultant string after search and replace
 */
function escapeForRegExp(str, escapeSpaces) {
	var regexEscapes = /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|\~\!\@\#]/g,
	    tempstr = '';
	if (str) {
		tempstr = str.replace(regexEscapes, "\\$&");
		if (escapeSpaces) {
			//replace space plus multiple spaces with non escaped 0 or * space.
			tempstr = tempstr.replace(/\t+|\s+/g, '\\s*');
		}
	}
	return tempstr;
}
/** Escapes special chars for macros - to create sub queries - this is not used currently
 *@param {string} str the string to examine
 *@returns {string} resultant string after search and replace
 */
function escapeForMacroCall(str) {
	var macroCallEscapes = [[/\{\{/g, '&#123;&#123;'], [/\}\}/g, '&#125;&#125;'], [/\(/g, '&#40;'], [/\)/g, '&#41;'], [/\,/g, '&#44;'], [/\?/g, '&#63;'], [/'/g, '&#39;'], [/"/g, '&#34;'], [/\=/g, '&#61;']];
	if (str) {
		return _underscore2.default.reduce(macroCallEscapes, function (currStr, pair) {
			return currStr.replace(pair[0], pair[1]);
		}, str);
	}
	return "";
}
/** Escapes '{{' for passing to a rolltemplate
 *@param {string} str the string to examine
 *@returns {string} resultant string after search and replace
 */
function escapeForRollTemplate(str) {
	if (!str) {
		return str;
	}
	return str.replace(/\{\{/g, '&#123;&#123;');
}
/** escapes string so it can be used in the name section of another link button
 *if it finds [name](link) in a string it will remove the [ and ] and the (link)
 * replaces [ and ] with escaped versions everywhere else.
 *@param {string] str the string we want to use inside a link button
 *@returns {string} safe to use new name for button
 */
function escapeForChatLinkButton(str) {
	var markdownLinkreg = /^([^\[]*?)\[([^\]]*?)\]\(([^\)]*?)\)(.*)$/,
	    retstr = "",
	    matches;
	if (!str) {
		return str;
	}
	matches = markdownLinkreg.exec(str);
	if (matches) {
		if (matches[1]) {
			retstr += matches[1];
		}
		if (matches[2]) {
			retstr += matches[2];
		}
		if (matches[4]) {
			retstr += matches[4];
		}
	} else {
		retstr = str;
	}
	retstr = retstr.replace(/\[/g, '&#91;').replace(/\]/g, '&#93;');
	return retstr;
}
/** returns id portion of a source Attribute or repeating row attribute name
 * @param {string} sourceAttribute from eventInfo object
 * @returns {string} the id portion of string, or blank.
 */
function getRowId(sourceAttribute) {
	if (!sourceAttribute) {
		return "";
	}
	var strs = sourceAttribute.split('_');
	//only 3 if is is from remove:repeating_section, 4 otherwise
	if (strs && _underscore2.default.size(strs) >= 3) {
		return strs[2];
	}
	return "";
}
function getAttributeName(source) {
	if (!source) {
		return "";
	}
	var itemId = getRowId(source),
	    attrib = "";
	if (itemId) {
		attrib = source.substring(source.indexOf(itemId) + itemId.length + 1, source.length);
	}
	return attrib;
}
/** getRepeatingIDStr - if id is not empty, then returns the ID with an underscore on the right. else returns empty string
 * this is used so the same function can be written for loops from getIDs or direct from the event with no ID
 *@param {string} id the id of the row or blank
 *@returns {string} id_  or blank
 */
function getRepeatingIDStr(id) {
	var idStr = "";
	if (!(id === null || id === undefined)) {
		idStr = id + "_";
	}
	return idStr;
}
/** Append values of multiple arrays of strings together to return one NEW array of strings that is the cartesian product.
 * @example cartesianAppend(["a","b"],["c","d"], ["e","f"]);
 * // returns ["ace","acf","ade","adf","bce","bcf","bde","bdf"]
 * @example cartesianAppend(["pre_"] , ["a","b","c"], ["_post"] );
 * //returns ["pre_a_post","pre_b_post","pre_c_post"]
 * @param {Array} [...] Arrays of strings
 * @returns {Array} of all values in other arrays
 */
function cartesianAppend() {
	return _underscore2.default.reduce(arguments, function (a, b) {
		return _underscore2.default.flatten(_underscore2.default.map(a, function (x) {
			return _underscore2.default.map(b, function (y) {
				return String(x) + String(y);
			});
		}), true);
	}, [[]]);
}
/** Concatenates cartesian product of all arrays together returns one flattened NEW array.
 * @param {Array} [...] Arrays
 * @returns {Array} cartesian product of all arrays (concatenated nothing else)
 */
function cartesianProduct() {
	return _underscore2.default.reduce(arguments, function (a, b) {
		return _underscore2.default.flatten(_underscore2.default.map(a, function (x) {
			return _underscore2.default.map(b, function (y) {
				return x.concat([y]);
			});
		}), true);
	}, [[]]);
}
/** trimBoth removes spaces at beginning and end of string, or of each string in an array.
 * performs a deep match, so if array is of arrays, will call trim on every string. 
 * if object is not an array or string, just return object.
 * therefore, non immutable objects are not cloned and array will contain links to them.
 *@param {Array or string} val string or array of strings
 *@returns {Array or string} same object type as passed in 
 */
function trimBoth(val) {
	if (Array.isArray(val)) {
		return _underscore2.default.map(val, trimBoth);
	}
	if (typeof val === 'string') {
		return val.replace(/^\s*|\s*$/g, '');
	}
	return val;
}
/** Splits string into array, based on commas (ignoring commas between parenthesis) 
 * @param {string} str 
 * @returns {[string]} array of items
 */
function splitByCommaIgnoreParens(str) {
	var ret = [];
	if (!str) {
		return [];
	}
	ret = str.match(/((?:[^(),]|\([^()]*\))+)/g);
	ret = trimBoth(ret);
	return ret;
}
function deleteRepeating(callback, section) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	if (!section) {
		done();
		return;
	}
	_exportsLoaderTASTheAaronSheet2.default.debug("SWUtils.deleteFeatures", section);
	getSectionIDs(section, function (ids) {
		var prefix = "repeating_" + section + "_";
		if (ids && _underscore2.default.size(ids)) {
			ids.forEach(function (id) {
				_exportsLoaderTASTheAaronSheet2.default.debug("deleting " + prefix + id);
				removeRepeatingRow(prefix + id);
			});
			done();
		} else {
			done();
		}
	});
}

_PFLog.PFConsole.log('   SWUtils module loaded          ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.findAbilityInString = findAbilityInString;
exports.calculateSpellRanges = calculateSpellRanges;
exports.findSpellRange = findSpellRange;
exports.getWoundPenalty = getWoundPenalty;
exports.isOptionTemplateReversed = isOptionTemplateReversed;
exports.getOptionsCompiledRegexMap = getOptionsCompiledRegexMap;
exports.shouldNotDisplayOption = shouldNotDisplayOption;
exports.deleteOption = deleteOption;
exports.getAvgHP = getAvgHP;
exports.getAutoHPPercentMultiplier = getAutoHPPercentMultiplier;
exports.parseSpellRangeText = parseSpellRangeText;
exports.replaceMissingNegatives_BadDice = replaceMissingNegatives_BadDice;
exports.replaceMissingNegatives_CritRange = replaceMissingNegatives_CritRange;
exports.convertDashToMinus = convertDashToMinus;
exports.getCostInGP = getCostInGP;
exports.getIntFromString = getIntFromString;
exports.getCritFromString = getCritFromString;
exports.getDiceDieFromString = getDiceDieFromString;
exports.replaceDiceDieString = replaceDiceDieString;
exports.getDiceDieString = getDiceDieString;
exports.getSpecialAbilityTypeFromString = getSpecialAbilityTypeFromString;
exports.removeUptoFirstComma = removeUptoFirstComma;
exports.getDCString = getDCString;
exports.replaceDCString = replaceDCString;
exports.getNoteAfterNumber = getNoteAfterNumber;
exports.getCompendiumFunctionSet = getCompendiumFunctionSet;
exports.getCompendiumIntSet = getCompendiumIntSet;
exports.removeWhisperFromMacro = removeWhisperFromMacro;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/****************************SYNCHRONOUS UTILITIES ***********************************
NO asynchronous FUNCTIONS SHOULD GO HERE
************************************************************************************** */
/** findAbilityInString - returns the attribute referenced by a dropdown option value.
 * Looks at a string for instances of an ability modifier DEX-mod, STR-mod,  etc and returns the modifier it finds.
 * if none are found, or if the first character is "0", return ""
 * NOTE: YOU MUST PUT ANY NEW DROPDOWN VALUES HERE! 
 * (if they are references to other fields. obviously, dropdowns with 0, 1, 2 as values are not needed here)
 *@param {string} stringToSearch the value of the dropdown option selected
 *@returns {string} the attribute referenced by a dropdown option value.
 */
function findAbilityInString(stringToSearch) {
    if (!stringToSearch) {
        return "";
    }
    if (stringToSearch.slice(0, 1) === "0") {
        return "";
    }
    if (/str.mod/i.test(stringToSearch)) {
        return "STR-mod";
    }
    if (/dex.mod/i.test(stringToSearch)) {
        return "DEX-mod";
    }
    if (/con.mod/i.test(stringToSearch)) {
        return "CON-mod";
    }
    if (/int.mod/i.test(stringToSearch)) {
        return "INT-mod";
    }
    if (/wis.mod/i.test(stringToSearch)) {
        return "WIS-mod";
    }
    if (/cha.mod/i.test(stringToSearch)) {
        return "CHA-mod";
    }
    if (/melee2/i.test(stringToSearch)) {
        return "attk-melee2";
    }
    if (/melee/i.test(stringToSearch)) {
        return "attk-melee";
    }
    if (/ranged2/i.test(stringToSearch)) {
        return "attk-ranged2";
    }
    if (/ranged/i.test(stringToSearch)) {
        return "attk-ranged";
    }
    if (/cmb2/i.test(stringToSearch)) {
        return "CMB2";
    }
    if (/cmb/i.test(stringToSearch)) {
        return "CMB";
    }
    if (/str/i.test(stringToSearch)) {
        return "STR";
    }
    if (/dex/i.test(stringToSearch)) {
        return "DEX";
    }
    if (/con/i.test(stringToSearch)) {
        return "CON";
    }
    if (/int/i.test(stringToSearch)) {
        return "INT";
    }
    if (/wis/i.test(stringToSearch)) {
        return "WIS";
    }
    if (/cha/i.test(stringToSearch)) {
        return "CHA";
    }
    if (/npc.type/i.test(stringToSearch)) {
        return "npc-type";
    }
    if (/race/i.test(stringToSearch)) {
        return "race";
    }
    if (/class.0.level/i.test(stringToSearch)) {
        return "class-0-level";
    }
    if (/\{level\}/i.test(stringToSearch)) {
        return "level";
    }
    if (/npc.hd.num/i.test(stringToSearch)) {
        return "npc-hd-num";
    }
    if (/class.1.level/i.test(stringToSearch)) {
        return "class-1-level";
    }
    if (/class.2.level/i.test(stringToSearch)) {
        return "class-2-level";
    }
    if (/class.3.level/i.test(stringToSearch)) {
        return "class-3-level";
    }
    if (/class.4.level/i.test(stringToSearch)) {
        return "class-4-level";
    }
    if (/class.5.level/i.test(stringToSearch)) {
        return "class-5-level";
    }
    return "";
}
/** calculateSpellRanges - returns {close:x, medium:y , long:z} for casterlevel 
 *@param {int} casterlevel level of caster
 *@returns {jsobject} mapping like this: {close:int,medium:int,long:int}
 */
function calculateSpellRanges(casterlevel) {
    casterlevel = casterlevel || 0;
    return {
        close: 25 + 5 * Math.floor(casterlevel / 2),
        medium: 100 + 10 * casterlevel,
        "long": 400 + 40 * casterlevel
    };
}
/**findSpellRange -  calculates range number based on spell settings
 * @param {int} customRangeVal value that is in the custom range field, for "per level" or "custom" choices
 * @param {string} rangeDropdown selected value from spell range dropdown
 * @param {int} casterlevel the level of caster
 * @returns {int_or_""} the spell range
 */
function findSpellRange(customRangeVal, rangeDropdown, casterlevel) {
    var newRange = 0,
        ranges = calculateSpellRanges(casterlevel);
    casterlevel = casterlevel || 0;
    rangeDropdown = rangeDropdown || 'blank';
    if (rangeDropdown[0] === "{") {
        rangeDropdown = rangeDropdown.slice(2, rangeDropdown.indexOf("="));
    }
    //TAS.debug("at find SpellRange. rangetext:"+customRangeVal +", rangeDropdown:"+rangeDropdown+", area:"+area+", casterlevel:"+casterlevel);
    switch (rangeDropdown) {
        case 'number':
        case 'custom':
            newRange = parseInt(customRangeVal, 10) || 0;
            break;
        case 'perlevel':
            newRange = (parseInt(customRangeVal, 10) || 0) * casterlevel;
            break;
        case 'close':
            newRange = ranges.close;
            break;
        case 'medium':
            newRange = ranges.medium;
            break;
        case 'long':
            newRange = ranges["long"];
            break;
        case 'see text':
        case 'touch':
        case 'personal':
        case 'blank':
        default:
            newRange = 0;
            break;
    }
    //TAS.debug("returning customRangeVal "+newRange+" for "+rangeDropdown);
    return newRange;
}
/** getWoundPenalty - applies Endurance feat or Gritty Mode to wound level.
 *@param {int} woundLevel value of wounds attribute
 *@param {boolean} hasEndurance if char has Endurance feat (lessens penalty by 1)
 *@param {boolean} grittyMode if using grittyMode (doubles penalty, applied before hasEndurance)
 *@returns {int} value to apply.
 */
function getWoundPenalty(woundLevel, hasEndurance, grittyMode) {
    return woundLevel !== 0 ? -1 * (woundLevel * (grittyMode + 1) - hasEndurance) : 0;
}

function isOptionTemplateReversed(spellOptionKey) {
    return spellOptionKey === "range_pick";
}
/** getOptionsCompiledRegexMap - finds {{key=*}} in a string to search rolltemplate macros
 * uses lookahead and lookbehind  to ensure must be preceeded by start or }} , followed by end or {{ 
 * @param {jsobj map} options map {} of key , only key looked at.
 * @returns {jsobj map} of key to "{{key=*}}" but as a compiled regex 
 */
function getOptionsCompiledRegexMap(options) {
    return _underscore2.default.mapObject(options, function (outputstr, key) {
        if (!isOptionTemplateReversed(key)) {
            return new RegExp("\\s*((?=\\{\\{)|(?=^))\\{\\{" + key + "\\=.*?\\}\\}\\s*((?=\\{\\{)|(?=$))");
        }
        return new RegExp("((?=\\{\\{)|(?=^))\\s*\\{\\{\\.*?\\=" + key + "\\}\\}\\s*((?=\\{\\{)|(?=$))");
    });
}
/** shouldNotDisplayOption- returns true if the value is the default so we know not to bother displaying in roll.
 * @param {string} attr: can pass either the attribute or the option name it will be sent to
 * @param {string} val : the value of the attribute
 * @returns {boolean}
 */
function shouldNotDisplayOption(attr, val) {
    if (!val) {
        return true;
    }
    switch (attr) {
        case 'sr':
            return !/^y/i.test(val);
        case 'save':
        case 'saving_throw':
            return (/^n/i.test(val) || /harmless/i.test(val)) && !/and|or/i.test(val);
        case 'spell_fail':
            return (parseInt(val, 10) || 0) !== 0;
        default:
            return false;
    }
}
/** deleteOption - removes option text from string and adds {{optionKey=}}
 * @param {string} optionText the string of a rolltemplate macro
 * @param {string} optionKey the key from rolltemplate setting, as in: {{optionKey=xxxx}}
 * @param {string} regexMap output of keys, what to search for from getOptionsCompiledRegexMap()
 * @returns {string} optionText with the optionKey portion of macro replaced with empty value
 */
function deleteOption(optionText, optionKey, regexMap) {
    var repStr = isOptionTemplateReversed(optionKey) ? "{{=" + optionKey + "}}" : "{{" + optionKey + "=}}";
    //TAS.debug("deleteOption optionKey"+optionKey+", regexMap[optionKey]:"+regexMap[optionKey]+", repStr:"+repStr);
    if (optionKey && optionText && regexMap[optionKey]) {
        optionText = optionText.replace(regexMap[optionKey], repStr);
    }
    return optionText;
}
/**getAvgHP returns average hp for given hit dice and die
 * also can return 75% or 100% of max hp
 * @param {int} hdice # of dice
 * @param {int} hdie # of sides (4,6,8,10,12,etc)
 * @param {float} mult optional percent of max to average, must be .5 (average), .75, or 1. If null then assume .5
 * @param {boolean} firstMax if true then 1st level gets 100% hp
 * @param {boolean} ispfs if true then round up EVERY level.
 * @returns {int} hit point average. 
 */
function getAvgHP(hdice, hdie, mult, firstMax, ispfs) {
    var hp = 0,
        bonus = 1;
    //TAS.debug("PFUtils.getAvgHP called with hdice:"+hdice+", hdie:"+hdie+", mult:"+mult+", firstMax:"+firstMax);
    if (hdie === 0) {
        return 0;
    }
    if (!(mult === 0.5 || mult === 0.75 || mult === 1)) {
        mult = 0.5;
    }
    if (ispfs) {
        bonus = 2;
        mult = 0.5;
    }
    if (mult === 1) {
        hp = hdie * hdice;
    } else {
        if (firstMax) {
            hdice--;
        }
        hp = Math.floor(100 * (hdie + bonus) * mult * hdice / 100);
        if (firstMax) {
            hp += hdie;
        }
    }
    return hp;
}
/** takes value of auto hit point radio and returns percent it represents 50,75,100.
 * @param {int} autohp_percent the value of attr_autohp_percent 
 * @returns {decimal} either 0.5, 0.75,  or 1.00
 */
function getAutoHPPercentMultiplier(autohp_percent) {
    var newhealth = 0;
    autohp_percent = parseInt(autohp_percent, 10) || 0;
    switch (autohp_percent) {
        case 1:
            newhealth = 0.5;break;
        case 2:
            newhealth = 0.75;break;
        case 3:
            newhealth = 1;break;
        default:
            newhealth = 0.5;break;
    }
    //TAS.debug("at getAutoHPPercentMultiplier called with "+autohp_percent+", returning with :" + newhealth);
    return newhealth;
}
/** parseSpellRangeText - Initial parse of a string from spell , it returns the value to set in the dropdown,
 * plus whether to run the range text through a secondary parse for numbers.
 * returns object with keys: dropdown, useorig, number, rangetext
 * (number only returned if number is a flat number)
 * @param {string} range the range string from a spell
 * @param {string} area the area or target string from a spell (whichever filled in, only 1 will be)
 * @returns {jsobj} map format: {"dropdown":newRangeDropdown,"useorig":useOrigRangeText if special,"number":flatRange,"rangetext":newRangeText if we need to fill in text}
 */
function parseSpellRangeText(range, area) {
    var newRangeDropdown = "",
        tempRange = 0,
        tempMatches,
        tempMatches2,
        useOrigRangeText = false,
        flatRange = -1,
        areaRange,
        newRangeText = "";
    //TAS.debug("at parseSpellRangeText: range:"+range+", area:"+area);
    try {
        if (!range) {
            //if range is blank, use the number in area/effect/targets since it will be "30ft emanation" or something similar
            if (!area) {
                return {
                    "dropdown": "blank",
                    "useorig": false,
                    "rangetext": "",
                    "number": 0
                };
            }
            areaRange = parseSpellRangeText(area, null);
            if (areaRange.dropdown === "unknownrange") {
                areaRange.dropdown = "blank";
            }
            if (!(areaRange.dropdown === "number" || areaRange.dropdown === "perlevel")) {
                areaRange.useorig = false;
                areaRange.rangetext = "";
            }
            return areaRange;
        }
        //begin
        range = range.toLowerCase();
        //if unlimited use area/target field
        if (!newRangeDropdown && range === "unlimited") {
            areaRange = parseSpellRangeText(area, null);
            if (areaRange.dropdown === "unknownrange") {
                newRangeDropdown = "blank";
            } else {
                newRangeDropdown = areaRange.dropdown;
                if (!/short|medium|long/.test(newRangeDropdown)) {
                    useOrigRangeText = areaRange.useorig;
                    if (useOrigRangeText && areaRange.rangetext) {
                        range = areaRange.rangetext;
                    }
                }
            }
        }
        if (!newRangeDropdown) {
            //and or or - use the value after and/or if there is one, and keep rangetext
            tempMatches = range.match(/(.*?)\s+(or|and)\s+/);
            if (tempMatches && tempMatches[1]) {
                areaRange = parseSpellRangeText(range.substring(tempMatches[0].length), null);
                if (areaRange && !(areaRange.dropdown === "unknownrange" || areaRange.dropdown === "blank")) {
                    newRangeDropdown = areaRange.dropdown;
                    if (areaRange.rangetext) {
                        //If second value is a flat number or per level
                        // then move it BEFORE the and/or so parseInt on rangetext works.
                        if (newRangeDropdown === "number") {
                            if (areaRange.rangetext) {
                                range = areaRange.rangetext + " " + tempMatches[2] + " " + tempMatches[1];
                            } else {
                                range = areaRange.number + " ft. " + tempMatches[2] + " " + tempMatches[1];
                            }
                        } else if (newRangeDropdown === "perlevel") {
                            //must add /level when it is and/or but otherwise not.
                            if (areaRange.rangetext) {
                                range = areaRange.rangetext + "/level " + tempMatches[2] + " " + tempMatches[1];
                            } else {
                                range = areaRange.number + "ft. /level  " + tempMatches[2] + " " + tempMatches[1];
                            }
                        } else {
                            range = tempMatches[1] + " " + tempMatches[2] + " " + areaRange.rangetext;
                        }
                    }
                    useOrigRangeText = true;
                }
            }
        }
        if (!newRangeDropdown) {
            if (range === "you") {
                newRangeDropdown = "personal";
            } else {
                tempMatches = range.match(/close|short|medium|long|touch|see text|personal|special|\/level/);
                if (tempMatches && tempMatches[0]) {
                    switch (tempMatches[0]) {
                        case 'close':
                        case 'medium':
                        case 'long':
                        case 'personal':
                        case 'touch':
                        case 'see text':
                            newRangeDropdown = tempMatches[0];
                            break;
                        case 'short':
                            newRangeDropdown = "close";
                            break;
                        case 'special':
                            newRangeDropdown = "see_text";
                            break;
                        case '/level':
                            tempMatches2 = range.match(/(\d+)(\D*)\/level/);
                            if (tempMatches2 && tempMatches2[1]) {
                                tempRange = parseInt(tempMatches2[1], 10) || 0;
                                range = tempMatches2[1] + (tempMatches2[2] || "");
                                useOrigRangeText = true;
                                newRangeDropdown = "perlevel";
                                flatRange = tempRange;
                            }
                            break;
                    }
                }
            }
        }
        if (!newRangeDropdown) {
            //number in front usually emanation, line, cone, etc
            tempRange = parseInt(range, 10);
            if (!isNaN(tempRange) && tempRange > 0) {
                newRangeDropdown = "number";
                flatRange = tempRange;
                useOrigRangeText = true;
            } else {
                //number in middle after "more than" or "within"
                tempMatches2 = range.match(/within\s|more\sthan\s/);
                if (tempMatches2 && tempMatches2[0]) {
                    range = range.substring(tempMatches2[0].index + tempMatches2[0].length);
                    tempRange = parseInt(range, 10);
                    if (!isNaN(tempRange) && tempRange > 0) {
                        newRangeDropdown = "number";
                        flatRange = tempRange;
                        useOrigRangeText = true;
                    }
                }
            }
        }
        if (!newRangeDropdown && area) {
            //give up , retry using the text in area/target/effect
            areaRange = parseSpellRangeText(area, null);
            newRangeDropdown = areaRange.dropdown;
            if (newRangeDropdown === "number" || newRangeDropdown === "perlevel") {
                useOrigRangeText = true;
                range = areaRange.rangetext;
            }
        }
    } catch (errorParsing) {
        _exportsLoaderTASTheAaronSheet2.default.error("parseSpellRangeText, error", errorParsing);
        newRangeDropdown = "unknownrange";
        useOrigRangeText = true;
    }
    if (!newRangeDropdown) {
        newRangeDropdown = "unknownrange";
        useOrigRangeText = true;
    }
    if (useOrigRangeText === true) {
        if (newRangeDropdown !== "unknownrange") {
            //erase everything in parenthesis - also ltrim and rtrim
            newRangeText = range.replace(/\s*\(.*?\)/, '').replace(/^\s+/, '').replace(/\s+$/, '').replace('feet', 'ft.');
        } else {
            newRangeText = range;
        }
    }
    return {
        "dropdown": newRangeDropdown,
        "useorig": useOrigRangeText,
        "number": flatRange,
        "rangetext": newRangeText
    };
}

function replaceMissingNegatives_BadDice(str) {
    return str.replace(_PFConst2.default.findBadNegDice, '$1d$2-$3');
}
function replaceMissingNegatives_CritRange(str) {
    return str.replace(_PFConst2.default.findBadCritRange, '/$1-20');
}
function convertDashToMinus(str) {
    return str.replace(_PFConst2.default.dashtominusreg, '-');
}

/** parseCost gets cost in gp 
 * @param {string} str the string containing the cost: 35gp, 20sp, etc 
 * @returns {int} cost in gp.
 */
function getCostInGP(str) {
    var temp = 0,
        matches = str.match(/(\d+)/);
    if (matches) {
        temp = parseInt(matches[1], 10) || 0;
        matches = str.match(/(gp|cp|sp|pp)/i);
        if (matches) {
            switch (matches[1]) {
                case 'pp':
                    temp = temp * 10;
                    break;
                case 'sp':
                    temp = temp / 10;
                    break;
                case 'cp':
                    temp = temp / 100;
                    break;
            }
        }
    }
    return temp;
}
function getIntFromString(str, cleanedup, atStart) {
    var temp = 0,
        matches;
    if (!cleanedup) {
        str = replaceMissingNegatives_CritRange(str);
        str = convertDashToMinus(str);
    }
    if (!atStart) {
        matches = str.match(/[\+\-]{0,1}\d+/);
    } else {
        matches = str.match(/^[\+\-]{0,1}\d+/);
    }
    if (matches) {
        temp = parseInt(matches[0], 10) || 0;
    }
    return temp;
}
/**Returns object of a crit string as mapped ints as: crit:minimum threat range (def 20), critmult: how much by which to multiply dice (def 2)
 * spaces: number of spaces string took 
 * @param {string} str the string that should have /19-20x2 or x2 in it.
 * @param {boolean} cleanedup if replaceMissingNegatives_CritRange already called on string
 * @param {boolean} atStart if true only look for dice at start of str
 * @returns {{'crit':number,'critmult':number,'spaces':number}}
 */
function getCritFromString(str, cleanedup, atStart) {
    var ret = { 'crit': 20, 'critmult': 2, 'spaces': 0 },
        matches;
    if (!cleanedup) {
        str = replaceMissingNegatives_CritRange(str);
        str = convertDashToMinus(str);
    }
    if ((matches = _PFConst2.default.critreg.exec(str)) !== null) {
        ret.crit = parseInt(matches[1], 10);
        if (matches[2]) {
            ret.critmult = parseInt(matches[2], 10);
        }
        ret.spaces = matches.length;
    } else if ((matches = _PFConst2.default.critmultreg.exec(str)) !== null) {
        ret.critmult = parseInt(matches[2], 10);
        ret.spaces = matches.length;
    }
    return ret;
}
/**Returns object of a dice string as mapped ints: dice:# of dice, die:# of sides, plus: plus or minus to roll, spaces:length of string found
 * @param {string} str the string that should have xdy+z in it.
 * @param {boolean} cleanedup if replaceMissingNegatives_BadDice already called on string
 * @param {boolean} atStart if true only look for dice at start of str
 * @returns {{'dice':number,'die':number,'plus':number,'spaces':number}}
 */
function getDiceDieFromString(str, cleanedup, atStart) {
    var matches,
        ret = { 'dice': 0, 'die': 0, 'plus': 0, 'spaces': 0 },
        sign = 1;
    if (!str) {
        return ret;
    }
    if (!cleanedup) {
        str = replaceMissingNegatives_BadDice(str);
        str = convertDashToMinus(str);
    }
    matches = _PFConst2.default.diceDiereg.exec(str);
    if (matches) {
        if (!atStart || matches.index === 0) {
            ret.spaces = matches.length;
            ret.dice = parseInt(matches[1], 10) || 0;
            ret.die = parseInt(matches[2], 10) || 0;
            if (matches[3] === '-') {
                sign = -1;
            }
            if (matches[4]) {
                ret.plus = sign * (parseInt(matches[4], 10) || 0);
            }
        }
    }
    //TAS.debug("at getDiceDieFromString parsing "+str,matches);
    return ret;
}
/**replaceDiceDieString puts inline roll brackets [[ ]] around 'xdy +z' dice strings (z exists or not)
 *@param {string} str a string which includes a diceroll substring xdy or xdy +/-z
 *@returns {string} same string with brackets around dice roll
 */
function replaceDiceDieString(str) {
    var tempstr = "",
        tempstrs;
    str = replaceMissingNegatives_BadDice(str);
    return str.replace(_PFConst2.default.diceDieregOneGroup, '[[ $1 ]]');
}
/* like replaceDiceDieString but instead of replacing returns the first dice match with [[ ]] around it.
 *@param {string} str a string which includes a diceroll substring xdy or xdy +/-z
 *@returns {string} brackets around dice roll or ""
 */
function getDiceDieString(str) {
    var matches;
    str = replaceMissingNegatives_BadDice(str);
    matches = _PFConst2.default.diceDieregOneGroup.exec(str);
    if (matches) {
        return "[[ " + matches[0] + " ]]";
    }
    return "";
}

function getSpecialAbilityTypeFromString(str) {
    var ret = '',
        matches;
    if (!str) {
        return '';
    }
    matches = /\b(Su|Ex|Sp)\b/i.exec(str);
    if (matches) {
        return matches[1][0].toUpperCase() + matches[1][2].toLowerCase();
    }
    return '';
}
/** returns string after first comma ( that is after an opening parenthesis )
 * or after first comma if there is no opening parenthesis
 * @param {string} str the string to split
 * @param {boolean} putOutside if true then return whateever is before first comma and after opening paren.
 *      if false, then return everything up to first paren then between 1st and 2nd comma. why? who the hell knows?
 * @returns {?} ?
 */
function removeUptoFirstComma(str, putOutside) {
    var parensplit, commasplit, retstr, i;
    if (str.indexOf('(') < 0 || str.indexOf(',') < 0) {
        return str;
    }
    parensplit = str.split(/\s*\(\s*/);
    if (parensplit.length > 1) {
        commasplit = parensplit[1].split(/,\s*/);
    } else {
        commasplit = str.split(/,\s*/);
    }
    retstr = putOutside ? commasplit[0] : parensplit[0] + '(' + commasplit[1];
    //rejoin rest of string this is really slow, why bother doing it this way?
    if (commasplit.length > 2) {
        for (i = 2; i < commasplit.length; i++) {
            retstr += ',' + commasplit[i];
        }
    }
    return retstr;
}
/**getDCString - gets macro formula for special ability calculating DC using ability score, what the level attribute is, and 
 * whether to divide that level by 2 or not.
 * @param {string} ability the ability score string the DC is based on. Usually CON for special abilities.
 * @param {string} levelAttr optional the level attribute , either "level" or "class-0-level" or "npc-hd-num" etc
 * @param {boolean} isUndead flag if undead, if true, then if ability is 'CON' change to 'CHA'
 * @param {int} miscBonus a flat number to add in
 * @param {boolean} doNotDivideByTwo if true then do not divide level attr value by 2 
 * @returns {string} default is: "DC [[ 10 + @{" + ability + "-mod} + floor(@{"+levelAttr+"}/2) ]]";
 */
function getDCString(ability, levelAttr, isUndead, miscBonus, doNotDivideByTwo) {
    var tempstr = '',
        pre = 'floor(',
        post = '/2)';

    tempstr = "DC [[ 10 ";
    if (ability) {
        if (isUndead && ability === 'CON') {
            ability = 'CHA';
        }
        tempstr += "+ @{" + ability + "-mod} ";
    }
    if (levelAttr) {
        if (doNotDivideByTwo) {
            pre = '';post = '';
        } else {
            tempstr += "+ " + pre + "@{" + levelAttr + "}" + post + " ";
        }
    }
    if (miscBonus) {
        tempstr += "+ " + miscBonus;
    }
    tempstr += " ]]";

    return tempstr;
}
/**replaceDCString looks for DC n, and replaces "n" with the [[ calculated DC  ]] by calling getDCString
 * @param {string} str the string to search and replace
 * @param {string} ability the ability score string the DC is based on. Usually CON for special abilities.
 * @param {string} levelAttr optional the level attribute , either "level" or "class-0-level" or "npc-hd" etc
 * @param {boolean} isUndead flag if undead, if true, then if ability is 'CON' change to 'CHA'
 * @param {int} levelFlatNum optional the level, if levelAttr is blank, this must be filled in, or vice versa
 * @param {boolean} doNotDivideByTwo if true then do not divide level by 2 to calculate DC
 * @returns {string} default is: "DC [[ 10 + @{" + ability + "-mod} + floor(@{"+levelAttr+"}/2) ]]"
 */
function replaceDCString(str, ability, levelAttr, isUndead, levelFlatNum, doNotDivideByTwo) {
    var tempstr = '',
        matches,
        pre = '',
        post = '',
        retstr = str,
        rawDC = 10;
    try {
        matches = str.match(/D[Cc]\s*\d+/);
        if (matches) {
            tempstr = matches[0].match(/\d+/);
            rawDC = parseInt(tempstr, 10) || 0;
            tempstr = getDCString(ability, levelAttr, isUndead, levelFlatNum, doNotDivideByTwo);
            pre = str.slice(0, matches.index) || '';
            post = str.slice(matches.index + matches[0].length) || '';
            retstr = pre + tempstr + post;
        }
    } catch (er) {
        _exportsLoaderTASTheAaronSheet2.default.error("at replaceDCString, cannot find DC string in " + str, er);
    } finally {
        return retstr;
    }
}
/** returns rest of string after number 
 *@param {string} str the string
 *@returns {string} rest of string after finding a number.
 */
function getNoteAfterNumber(str) {
    var match;
    if (str) {
        match = str.match(/\d+/);
        if (match) {
            str = SWUtils.trimBoth(str.slice(match.index + match.length));
        }
    }
    return str;
}
/**gets value of '<field>_compendium' from v,passes it to synchronous methodToCall mapping function, then adds 'field' to setter with val:
 *   setter[<prefix>(<setField>|<field>)] = methodToCall(v[<prefix><field>_compendium])
 *@param {string} prefix the repeating_section_id_  string
 *@param {string} field the name of compendium field , must have _compendium at end. Without '_compendium' this is the write field
 *@param {function} methodToCall synchronous function that maps value of field_compendium to another val to set
 *@param {Map<string,any>} v the values returned from getAttrs
 *@param {Map<string,any>} setter to pass to setAttrs
 *@param {string} setField optional if the attr to write to is not 'field' it will be prefix+setField
*/
function getCompendiumFunctionSet(prefix, field, methodToCall, v, setter, setField) {
    var temp = 0,
        attr = v[prefix + field + '_compendium'];
    if (attr) {
        temp = methodToCall(attr);
        if (temp) {
            setField = setField || field;
            setter[prefix + setField] = temp;
        }
    }
    return setter;
}
/**gets int value 'field_compendium' from v, then sets in 'field':
 *   setter[<prefix>(<setField>|<field>)] = getIntFromString(v[<prefix><field>_compendium])
 *@param {string} prefix the repeating_section_id_  string
 *@param {string} field the name of compendium field , must have _compendium at end. Without '_compendium' this is the write field
 *@param {Map<string,any>} v the values returned from getAttrs
 *@param {Map<string,any>} setter to pass to setAttrs
 *@param {string} setField optional if the attr to write to is not 'field' it will be prefix+setField
 */
function getCompendiumIntSet(prefix, field, v, setter, setField) {
    var tempInt = 0,
        attr;
    try {
        attr = v[prefix + field + '_compendium'];
        if (attr) {
            tempInt = getIntFromString(attr);
            //TAS.debug("get int field:"+field+", val="+attr+", int:"+tempInt);
            if (tempInt) {
                setField = setField || field;
                setter[prefix + field] = tempInt;
            }
        }
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("getCompendiumIntSet error on :" + prefix + ", field:" + field + ", setField:" + setField, err);
    } finally {
        return setter;
    }
}

function removeWhisperFromMacro(macrostr) {
    var matches;
    if (!macrostr) {
        return macrostr;
    }
    //use hisper since some have capital W others not
    matches = macrostr.match(/whisper\}/i);
    if (matches) {
        return SWUtils.trimBoth(macrostr.slice(matches.index + matches[0].length));
    }
    return macrostr;
}

_PFLog.PFConsole.log('   PFUtils module loaded          ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.migrateRepeatingDamage = migrateRepeatingDamage;
exports.migrateMaxDexAndACP = migrateMaxDexAndACP;
exports.migrateSpellRanges = migrateSpellRanges;
exports.migrateSpells = migrateSpells;
exports.migrateRollTemplateImages = migrateRollTemplateImages;
exports.addNumberToMacro = addNumberToMacro;
exports.migrateMoveIntIntoMacro = migrateMoveIntIntoMacro;
exports.migrateHPMisc = migrateHPMisc;
exports.migrateMaxSkills = migrateMaxSkills;
exports.migrateNPC = migrateNPC;
exports.migrateAltAttackGridrowFlags = migrateAltAttackGridrowFlags;
exports.migrateExperience = migrateExperience;
exports.migrateUsesSpellFlag = migrateUsesSpellFlag;
exports.migrateRepeatingItemAttributes = migrateRepeatingItemAttributes;
exports.migrateAbilityListFlags = migrateAbilityListFlags;
exports.migrateSpellPointFlag = migrateSpellPointFlag;
exports.migrateWhisperDropdowns = migrateWhisperDropdowns;
exports.migrateConfigFlags = migrateConfigFlags;
exports.getAllMigrateFlags = getAllMigrateFlags;
exports.setAllMigrateFlags = setAllMigrateFlags;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFLog = __webpack_require__(0);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//all user editable fields at the time
var oldSpellUserFieldDefaults = {
    "spellclass_number": {
        "type": "int",
        "val": 0
    },
    "used": {
        "type": "int",
        "val": 0
    },
    "spell_level": {
        "type": "int",
        "val": -1
    },
    "CL_misc": {
        "type": "int",
        "val": 0
    },
    "SP_misc": {
        "type": "int",
        "val": 0
    },
    "Concentration_misc": {
        "type": "int",
        "val": 0
    },
    "range": {
        "type": "text",
        "val": ""
    },
    "name": {
        "type": "text",
        "val": ""
    },
    "school": {
        "type": "text",
        "val": ""
    },
    "cast-time": {
        "type": "text",
        "val": ""
    },
    "components": {
        "type": "text",
        "val": ""
    },
    "targets": {
        "type": "text",
        "val": ""
    },
    "duration": {
        "type": "text",
        "val": ""
    },
    "save": {
        "type": "text",
        "val": ""
    },
    "sr": {
        "type": "text",
        "val": ""
    },
    "description": {
        "type": "text",
        "val": ""
    },
    "macro-text": {
        "type": "text",
        "val": "@{PC-whisper} &{template:pf_spell} {{color}} {{header_image=@{header_image-pf_spell}}} {{name=@{name}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} @{spell_options}"
    },
    "npc-macro-text": {
        "type": "text",
        "val": "@{NPC-whisper} &{template:pf_spell} {{color}} {{header_image=@{header_image-pf_spell}}} {{name=@{name}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} @{spell_options}"
    },
    "isDomain": {
        "type": "checkbox",
        "val": "0"
    }
};

/** breaks the damage dropdown into 2 dropdowns, one for the multiplier and one for the attribute
 * done as part of migration to .60
 *@param {Array} ids array of strings which are the row ids
 *@param {function} callback when done
 */
function migrateRepeatingDamage(ids, callback) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    }),
        setter = {},
        fields = [],

    /** findMultiplier - OLD not used anymore  - returns old damage multiplier when it was in the dropdown.
    * @param {string} str = the value of the damage ability
    * @returns {float} a number indicating the multiplier for the ability mod. Must be 1, .5, 1.5, 2. 
    */
    findMultiplier = function findMultiplier(str) {
        var retNum;
        if (!str) {
            return 0;
        }
        if (str.indexOf("1.5") >= 0) {
            retNum = 1.5;
        } else if (str.indexOf(".5") >= 0) {
            retNum = 0.5;
        } else if (str.indexOf("1/2") >= 0) {
            retNum = 0.5;
        } else if (str.indexOf("3/2") >= 0) {
            retNum = 1.5;
        } else if (str.indexOf("1 1/2") >= 0) {
            retNum = 1.5;
        } else if (str.indexOf("2") >= 0) {
            retNum = 2;
        } else {
            retNum = 1;
        }
        return retNum;
    };
    _underscore2.default.each(ids, function (id) {
        var dmgDropdownField = "repeating_weapon_" + id + "_damage-ability",
            abilityMultField = "repeating_weapon_" + id + "_damage_ability_mult";
        fields.push(dmgDropdownField);
        fields.push(abilityMultField);
    });
    getAttrs(fields, function (v) {
        var setter = {};
        try {
            //TAS.debug("migrateRepeatingDamage", "values", v);
            _underscore2.default.each(ids, function (id) {
                var dmgDropdownField = "repeating_weapon_" + id + "_damage-ability",
                    abilityMultField = "repeating_weapon_" + id + "_damage_ability_mult",
                    ability,
                    multStr,
                    strToSet,
                    multval;
                try {
                    ability = PFUtils.findAbilityInString(v[dmgDropdownField]);
                    multStr = findMultiplier(v[dmgDropdownField]);
                    strToSet = "@{" + ability + "}";
                    multval = parseFloat(multStr, 10);
                    //multfield is blank but multstr is not.
                    if (!v[abilityMultField] && multStr && ability) {
                        if (!isNaN(multval)) {
                            if (multval !== 1.0) {
                                setter[abilityMultField] = multStr;
                            }
                        }
                        if (ability) {
                            setter[dmgDropdownField] = strToSet;
                        }
                    }
                } catch (errinner) {
                    _exportsLoaderTASTheAaronSheet2.default.error("migrateRepeatingDamage dropdown to mult: could not migrate str " + v[dmgDropdownField] + " in attack row " + id, errinner);
                }
            });
            setter["migrated_damage-multiplier"] = "1";
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("migrateRepeatingDamage outer error!? SHOULD NOT HAPPEN", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                setAttrs(setter, _PFConst2.default.silentParams, done);
            } else {
                done();
            }
        }
    });
}
/** sets old dropdown  max dex and acp values to new ones for Magik's updates. 
 * because old values were so different, new values are set to either "none" or "armor and load"
 */
function migrateMaxDexAndACP() {
    getAttrs(["max-dex-source"], function (v) {
        var newMaxDex = 0,
            currMaxDex = parseInt(v["max-dex-source"], 10) || 0,
            setter = {};
        if (currMaxDex >= 99) {
            setAttrs(setter, { silent: true });
        }
    });
}
/** updates repeating_spells ranges from text to dropdown and custom text field, and range number 
 * @param {function} callback call after finishing */
function migrateSpellRanges(callback) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    };
    getAttrs(["spellranges_migrated"], function (m) {
        var rangeFields = ["casterlevel", "range", "range_numeric", "range_pick", "targets", "name"];
        if (parseInt(m["spellranges_migrated"], 10) === 1) {
            done();
            return;
        }
        getSectionIDs("repeating_spells", function (ids) {
            var fields = [];
            fields = _underscore2.default.reduce(ids, function (memo, id) {
                var prefix = "repeating_spells_" + SWUtils.getRepeatingIDStr(id),
                    row = _underscore2.default.map(rangeFields, function (field) {
                    return prefix + field;
                });
                return memo.concat(row);
            }, []);
            getAttrs(fields, function (v) {
                var setter = {};
                _underscore2.default.each(ids, function (id) {
                    var prefix = "repeating_spells_" + SWUtils.getRepeatingIDStr(id),
                        casterlevel = parseInt(v[prefix + "casterlevel"], 10) || 1,
                        chosenRange = v[prefix + "range_pick"],
                        rangeText = v[prefix + "range"] || "",
                        areaEffect = v[prefix + "targets"] || "",
                        name = v[prefix + "name"],
                        newRange = 0,
                        rangeUpdates,
                        resetDropdown = false;
                    //if dropdown is blank but text filled in try to migrate
                    if (!chosenRange && !rangeText) {
                        setter[prefix + "range"] = "";
                        setter[prefix + "range_numeric"] = 0;
                        setter[prefix + "range_pick"] = "blank";
                    } else if ((!chosenRange || chosenRange === "blank") && rangeText) {
                        rangeUpdates = PFUtils.parseSpellRangeText(rangeText, areaEffect);
                        chosenRange = rangeUpdates.dropdown;
                        if (chosenRange === "number" || chosenRange === "perlevel" || rangeUpdates.useorig) {
                            rangeText = rangeUpdates.rangeText;
                        }
                        //otherwise leave it in case user had something they wanted.
                        newRange = PFUtils.findSpellRange(rangeText, chosenRange, casterlevel) || 0;
                        setter[prefix + "range"] = rangeText;
                        setter[prefix + "range_numeric"] = newRange;
                        setter[prefix + "range_pick"] = chosenRange;
                    } else if (resetDropdown) {
                        newRange = PFUtils.findSpellRange(rangeText, chosenRange, casterlevel) || 0;
                        setter[prefix + "range_numeric"] = newRange;
                        setter[prefix + "range_pick"] = chosenRange;
                    }
                });
                setter["spellranges_migrated"] = "1";
                if (_underscore2.default.size(setter) > 0) {
                    setAttrs(setter, {
                        silent: true
                    }, callback);
                } else {
                    done();
                }
            });
        });
    });
}
/** copies spells from repeating-lvl-*-spells and npc spells to repeating_spells 
 * there are bugs in this, but it's so old we never were able to find them all and fix them. 
 * @param {function} callback call when done
 * @param {boolean} silently if true call setAttrs with PFConst.silentParams 
 */
function migrateSpells(callback) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    },

    /* determines spell class from class dropdown in the spell repeating row 
    * this is not a migrate function, just an old utility function  called by migrate
    */
    handleOldSpellClassDropdown = function handleOldSpellClassDropdown(selected, class0name, class1name, class2name) {
        if (!selected) {
            return 0;
        } //it is undefined if it is default set to the first one
        if (selected.indexOf("0") >= 0) {
            return 0;
        }
        if (selected.indexOf("1") >= 0) {
            return 1;
        }
        if (selected.indexOf("2") >= 0) {
            return 2;
        }
        if (selected === class0name) {
            return 0;
        }
        if (selected === class1name) {
            return 1;
        }
        if (selected === class2name) {
            return 2;
        }
        return 0;
    },

    /** this is the old version of updateSpell. This also is not a migrate function but called by migrate 
    * @param {string} section the repeating_*** name since old spells had 10 different repeating lists
    * @param {string} id the id of row to update
    * @param {eventInfo} eventInfo object from on method, not used in this.
    * @param {boolean} forceRange if true recalculate range
    * @param {function} callback call when done
    */
    updateOldSpell = function updateOldSpell(section, id, eventInfo, forceRange, callback) {
        if (section.indexOf("lvl") !== 0 && section.indexOf("npc") !== 0) {
            return;
        }
        var idStr = SWUtils.getRepeatingIDStr(id),
            isNPC = section.indexOf("npc") >= 0 ? 1 : 0,
            prefix = "repeating_" + section + "_" + idStr,
            spellclassField = prefix + "spellclass",
            spellLevelField = isNPC ? prefix + "level" : prefix + "spell_level";
        getAttrs([spellLevelField, spellclassField, "spellclass-0-name", "spellclass-1-name", "spellclass-2-name"], function (va) {
            var currSpellLevel = parseInt(va[spellLevelField], 10),
                spellLevel = isNPC ? isNaN(currSpellLevel) ? 0 : currSpellLevel : isNaN(currSpellLevel) ? parseInt(section.substring(4), 10) : currSpellLevel,
                classNum = isNPC ? section.indexOf("1") >= 0 ? 0 : section.indexOf("2") >= 0 ? 1 : 0 : handleOldSpellClassDropdown(va[spellclassField], va["spellclass-0-name"], va["spellclass-1-name"], va["spellclass-2-name"]) || 0,
                hiddenclassNumField = prefix + "spellclass_number",
                spellDefCastDCField = prefix + "cast_def_dc",
                spellDefConField = prefix + "cast_def-mod",
                spellDCField = prefix + "savedc",
                spellDCUserField = prefix + "DC_misc",
                spellCLField = prefix + "casterlevel",
                spellCLUserField = prefix + "CL_misc",
                spellConField = prefix + "Concentration-mod",
                spellConUserField = prefix + "Concentration_misc",
                spellSpellPenField = prefix + "SP-mod",
                spellSpellPenUserField = prefix + "SP_misc",
                classCLField = "spellclass-" + classNum + "-level-total",
                classDCField = "spellclass-" + classNum + "-level-" + spellLevel + "-savedc",
                classConField = "Concentration-" + classNum,
                classDefConField = "Concentration-" + classNum + "-def",
                classSpellPenField = "spellclass-" + classNum + "-SP-mod",
                spellRangeText = prefix + "range",
                spellRangeNum = prefix + "range_numeric",
                spellRangeTarget = prefix + "targets";
            getAttrs([hiddenclassNumField, spellDCField, spellDCUserField, spellCLField, spellCLUserField, spellConField, spellConUserField, spellDefConField, spellDefCastDCField, spellSpellPenField, spellSpellPenUserField, classDCField, classCLField, classConField, classDefConField, classSpellPenField, spellRangeText, spellRangeNum, spellRangeTarget], function (v) {
                var newDC,
                    newCL,
                    newCon,
                    newDefCon,
                    newSpellPen,
                    currDC = parseInt(v[spellDCField], 10),
                    currCL = parseInt(v[spellCLField], 10),
                    currCon = parseInt(v[spellConField], 10),
                    currDefCon = parseInt(v[spellDefConField], 10),
                    currdefDC = parseInt(v[spellDefCastDCField], 10),
                    currSpellPen = parseInt(v[spellSpellPenField], 10),
                    classDC = parseInt(v[classDCField], 10) || 0,
                    classCL = parseInt(v[classCLField], 10) || 0,
                    classCon = parseInt(v[classConField], 10) || 0,
                    classDefConMod = parseInt(v[classDefConField], 10) || 0,
                    classSpellPen = classCL + (parseInt(v[classSpellPenField], 10) || 0),
                    defDC = 15 + spellLevel * 2,
                    currClassNum = parseInt(v[hiddenclassNumField], 10),
                    currRange = parseInt(v[spellRangeNum], 10),
                    newRange = 0,
                    setter = {},
                    setAny = 0,
                    classLevelDelta = 0,
                    updateRange = false;
                if (classNum !== currClassNum || isNaN(currClassNum)) {
                    setter[hiddenclassNumField] = classNum;
                    setAny = 1;
                    //updateRange = true;
                }
                //prepare for migration of npc spells
                if (isNPC) {
                    if (classNum === 0) {
                        //set dropdown
                        setter["spellclass"] = "@{spellclass-0-name}";
                        if (!va["spellclass-0-name"]) {
                            setter["spellclass-0-name"] = "NPC 1";
                        }
                        setAny = 1;
                    } else if (classNum === 1) {
                        setter["spellclass"] = "@{spellclass-1-name}";
                        if (!va["spellclass-1-name"]) {
                            setter["spellclass-1-name"] = "NPC 2";
                        }
                        setAny = 1;
                    }
                }
                if (!isNaN(spellLevel) && (currSpellLevel !== spellLevel || isNaN(currSpellLevel))) {
                    setter[spellLevelField] = spellLevel;
                    setAny = 1;
                }
                newCL = (parseInt(v[spellCLUserField], 10) || 0) + classCL;
                if (newCL !== currCL || isNaN(currCL)) {
                    setter[spellCLField] = newCL;
                    setAny = 1;
                    updateRange = true;
                }
                if (defDC !== currdefDC || isNaN(currdefDC)) {
                    setter[spellDefCastDCField] = defDC;
                    setAny = 1;
                }
                classLevelDelta = newCL - classCL;
                newDC = (parseInt(v[spellDCUserField], 10) || 0) + classDC;
                if (newDC !== currDC || isNaN(currDC)) {
                    setter[spellDCField] = newDC;
                    setAny = 1;
                }
                newCon = (parseInt(v[spellConUserField], 10) || 0) + classCon + classLevelDelta;
                if (newCon !== currCon || isNaN(currCon)) {
                    setter[spellConField] = newCon;
                    setAny = 1;
                }
                newDefCon = newCon + classDefConMod;
                if (newDefCon !== currDefCon || isNaN(currDefCon)) {
                    setter[spellDefConField] = newDefCon;
                    setAny = 1;
                }
                newSpellPen = classSpellPen + (parseInt(v[spellSpellPenUserField], 10) || 0) + classLevelDelta;
                if (newSpellPen !== currSpellPen || isNaN(currSpellPen)) {
                    setter[spellSpellPenField] = newSpellPen;
                    setAny = 1;
                }
                if (updateRange || forceRange || isNaN(currRange)) {
                    newRange = PFUtils.findSpellRange(v[spellRangeText], newCL);
                    if (isNaN(newRange)) {
                        if (isNaN(currRange)) {
                            newRange = -1;
                        } else {
                            newRange = currRange;
                            currRange--;
                        }
                    }
                    if (newRange !== currRange || isNaN(currRange)) {
                        setter[spellRangeNum] = newRange;
                        setAny = 1;
                    }
                }
                if (setAny) {
                    setAttrs(setter, {
                        silent: true
                    });
                }
                //cannot wait for callback of setAttrs since it will not call if there were no changes.
                if (typeof callback === "function") {
                    callback();
                }
            });
        });
    },
        migrateCheckedSpells = function migrateCheckedSpells() {
        var countofSpells = 0,
            spellsUpdated = 0,
            spellUserFields = [],
            countofSections = 12,
            sectionsCounted = 0,
            idmap = {},
            sectionsToMigrate = ["lvl-0-spells", "lvl-1-spells", "lvl-2-spells", "lvl-3-spells", "lvl-4-spells", "lvl-5-spells", "lvl-6-spells", "lvl-7-spells", "lvl-8-spells", "lvl-9-spells", "npc-spells1", "npc-spells2"],
            finishUp = function finishUp() {
            var params = {};
            setAttrs({
                "spellmap": JSON.stringify(idmap),
                "migrated_spells": "1"
            }, _PFConst2.default.silentParams, done);
        },
            updateAtEnd,
            migrateSpell = function migrateSpell(section, id, callback) {
            var prefix = "",
                prefixLen = 0,
                oldAttribList = [];
            if (id === undefined || id === null || section === undefined || section === null) {
                callback();
                return;
            }
            prefix = "repeating_" + section + "_" + id + "_";
            prefixLen = prefix.length;
            _underscore2.default.each(spellUserFields, function (field) {
                oldAttribList.push(prefix + field);
            });
            //TAS.debug(oldAttribList);
            getAttrs(oldAttribList, function (v) {
                var spellLevel = 0,
                    newId = "",
                    newPrefix = "",
                    setter = {},
                    allNonBlank = true;
                //undefined for any attribute indicates it is outlined in red
                //for some reason checking name and === works better than checking typeof
                if (v[prefix + "name"] === undefined) {
                    _exportsLoaderTASTheAaronSheet2.default.error("cannot migrate " + id);
                    updateAtEnd();
                    return;
                }
                //if any are null or undefined skip this row,
                _underscore2.default.each(v, function (val) {
                    //saw some that were undefined but typeof came back something else? how?
                    if (val === undefined || val === null || typeof val === "undefined") {
                        _exportsLoaderTASTheAaronSheet2.default.error("cannot migrate " + id);
                        updateAtEnd();
                        return;
                    }
                    if (val !== "" || (parseInt(val, 10) || 0) !== 0) {
                        allNonBlank = false;
                    }
                });
                //if all are blank or zero then skip this row
                if (allNonBlank) {
                    _exportsLoaderTASTheAaronSheet2.default.error("cannot migrate " + id);
                    updateAtEnd();
                    return;
                }
                //passed check, so generate new id and attribute list
                newId = generateRowID();
                //TAS.debug("Passed test, migrating " + id +" to new "+newId);
                newPrefix = "repeating_spells_" + newId + "_";
                idmap["repeating_" + section + "_" + id + "_"] = "repeating_spells_" + newId + "_";
                _underscore2.default.each(v, function (val, field) {
                    var col = field.substring(prefixLen);
                    switch (oldSpellUserFieldDefaults[col].type) {
                        case 'int':
                            setter[newPrefix + col] = parseInt(val, 10) || 0;
                            break;
                        case 'text':
                            if (col !== "macro-text" && col !== "npc-macro-text") {
                                setter[newPrefix + col] = val;
                            } else {
                                try {
                                    if (val !== oldSpellUserFieldDefaults[col].val) {
                                        setter[newPrefix + col] = val;
                                    }
                                } catch (errrrr) {}
                            }
                            break;
                        case 'checkbox':
                            setter[newPrefix + col] = val;
                            break;
                        default:
                            setter[newPrefix + col] = val;
                    }
                });
                spellLevel = parseInt(v[prefix + "spell_level"], 10);
                //redo spell level since default is -1 instead of 0
                if (isNaN(spellLevel)) {
                    setter[newPrefix + "spell_level"] = "";
                    setter[newPrefix + "spell_level_r"] = -1;
                } else {
                    setter[newPrefix + "spell_level"] = spellLevel;
                    setter[newPrefix + "spell_level_r"] = spellLevel;
                }
                setter[newPrefix + "spell_class_r"] = parseInt(v[prefix + "spellclass_number"], 10) || 0;
                //TAS.debug("Setting "+newPrefix+"spellclass_number:"+ setter[newPrefix+"spellclass_number"] +", spell_level_r:"+setter[newPrefix+"spell_level"]+" and ensure undefined old level "+ setter[prefix+"spell_level"]+" for spell new "+setter[newPrefix+"name"]+", old:" + v[prefix+"name"]);
                //TAS.log(setter);
                setAttrs(setter, {
                    silent: true
                }, function () {
                    updateAtEnd();
                    return;
                });
            });
        },
            migrateUpdatedSpells = function migrateUpdatedSpells() {
            _underscore2.default.each(sectionsToMigrate, function (section) {
                var repeatingsection = "repeating_" + section;
                getSectionIDs(repeatingsection, function (ids) {
                    _underscore2.default.each(ids, function (id) {
                        migrateSpell(section, id);
                    });
                });
            });
        },
            updateOldSpells = function updateOldSpells() {
            //re-update each spell before migrating, in case some are very old.
            _underscore2.default.each(sectionsToMigrate, function (section) {
                var repeatingsection = "repeating_" + section;
                getSectionIDs(repeatingsection, function (ids) {
                    _underscore2.default.each(ids, function (id) {
                        updateOldSpell(section, id, null, true, function () {
                            spellsUpdated++;
                            if (spellsUpdated === countofSpells) {
                                migrateUpdatedSpells();
                            }
                        });
                    });
                });
            });
        };
        //create array from keys from oldSpellUserFieldDefaults
        _underscore2.default.each(oldSpellUserFieldDefaults, function (defMap, field) {
            spellUserFields.push(field);
        });
        //get total count of spells to migrate
        _underscore2.default.each(sectionsToMigrate, function (section) {
            getSectionIDs("repeating_" + section, function (ids) {
                countofSpells += ids.length;
                sectionsCounted++;
                if (sectionsCounted === countofSections) {
                    updateAtEnd = _underscore2.default.after(countofSpells, function () {
                        finishUp();
                    });
                    updateOldSpells();
                }
            });
        });
    };
    getAttrs(["migrated_spells"], function (vm) {
        if (parseInt(vm["migrated_spells"], 10) === 1) {
            done();
        } else {
            migrateCheckedSpells();
        }
    });
}
/* fixes rolltemplate image urls in dropdown to update urls from solid bkg to transparent. (from old to new val) */
function migrateRollTemplateImages() {
    getAttrs(['migrated_rolltemplateimages', 'header_image-pf_spell', 'header_image-pf_attack-melee', 'header_image-pf_attack-ranged', 'header_image-pf_attack-cmb', 'header_image-pf_defense'], function (v) {
        var isMigrated = parseInt(v.migrated_rolltemplateimages, 10) || 0,
            setter = {};
        try {
            if (!isMigrated) {
                setter = _underscore2.default.chain(v).filter(function (val, attr) {
                    return (/\[default\]/.test(val)
                    );
                }).reduce(function (memo, val, attr) {
                    var newval = "";
                    try {
                        switch (attr) {
                            case 'header_image-pf_spell':
                                if (val !== "[default](http://imgur.com/9yjOsAD.png)") {
                                    newval = "[default](http://imgur.com/9yjOsAD.png)";
                                }
                                break;
                            case 'header_image-pf_attack-melee':
                                if (val !== "[default](http://i.imgur.com/AGq5VBG.png)") {
                                    newval = "[default](http://i.imgur.com/AGq5VBG.png)";
                                }
                                break;
                            case 'header_image-pf_attack-ranged':
                                if (val !== "[default](http://imgur.com/58j2e8P.png)") {
                                    newval = "[default](http://imgur.com/58j2e8P.png)";
                                }
                                break;
                            case 'header_image-pf_attack-cmb':
                                if (val !== "[default](http://imgur.com/RUJfMGe.png)") {
                                    newval = "[default](http://imgur.com/RUJfMGe.png)";
                                }
                                break;
                            case 'header_image-pf_defense':
                                if (val !== "[default](http://imgur.com/02fV6wh.png)") {
                                    newval = "[default](http://imgur.com/02fV6wh.png)";
                                }
                                break;
                        }
                        if (newval) {
                            memo[attr] = newval;
                        }
                    } catch (err) {
                        _exportsLoaderTASTheAaronSheet2.default.error("migrateRollTemplateImages: inner error on " + attr, err);
                    }
                    return memo;
                }, {}).value();
            }
        } catch (erro) {
            _exportsLoaderTASTheAaronSheet2.default.error("migrateRollTemplateImages outer error", erro);
        } finally {
            setter['migrated_rolltemplateimages'] = 1;
            if (_underscore2.default.size(setter) > 0) {
                setAttrs(setter, _PFConst2.default.silentParams);
            }
        }
    });
}
/**addNumberToMacro adds the value to the end of the macro string. 
 * so the evaluated value of the returned string equals macroVal + miscVal
 * either "macroText + miscVal" or "macroText - miscVal"
 * This is for conversions only, if we are removing the miscfield. it is pretty useless otherwise.
 *@param {string} macroText the text of the macro to add to. if it is wrapped in [[ ]] make sure to remove that before passing macro in or it will be added outside of the brackets!
 *@param {int} macroVal the value the macro currently evaluates to.
 *@param {string} miscMacroText text of 2nd macro to add to macroText if there is one
 *@param {int} miscVal the value we are adding to macroText , it is value of miscMacroText if there is a macro
 *@returns {string} the resulting new macro text
 */
function addNumberToMacro(macroText, macroVal, miscMacroText, miscVal) {
    //TAS.debug("at addNumberToMacro:" );
    macroText = macroText || "";
    miscMacroText = miscMacroText || "";
    if (macroText || macroVal) {
        macroVal += miscVal;
        if (miscMacroText) {
            macroText += " " + miscMacroText;
        } else if (miscVal) {
            if (miscVal > 0) {
                macroText += " + ";
            } else {
                macroText += " - ";
            }
            macroText += String(Math.abs(miscVal));
        }
    } else if (miscVal) {
        macroText = String(miscVal);
        macroVal = miscVal;
    } else {
        macroText = "";
        macroVal = 0;
    }
    return { 'macroText': macroText, 'macroVal': macroVal };
}
/** adds the value to the end of the macro string. either "macro + miscVal" or "macro - miscVal"
 * saves new macro to the sheet
 *@param {function} callback call when done
 *@param {migrateFlag} the sheet attribute to check, if 1 do nothing, if 1 then perform migration then set to 1
 *@param {string} macroAttr the attribute name of macro we will update
 *@param {string} modAttr the attribute name containing the # evaluated from macroAttr
 *@param {string} miscMacroAttr the attribute name of macro to remove and whose value to add to macroAttr
 *@param {string} miscAttr the attribute name of a number field, standalone if macroAttr is null, or it is the 
            field containing evaluted number of miscMacroAttr
 */
function migrateMoveIntIntoMacro(callback, migrateFlag, macroAttr, modAttr, miscMacroAttr, miscAttr) {
    var done = _underscore2.default.once(function () {
        //TAS.debug("leaving PFMigrate.migrateMoveIntIntoMacro: "+ macroAttr);
        if (typeof callback === "function") {
            callback();
        }
    }),
        fields = [macroAttr, modAttr, miscAttr, migrateFlag];
    if (miscMacroAttr) {
        fields.push(miscMacroAttr);
    }
    getAttrs(fields, function (v) {
        var miscVal = 0,
            formVal = 0,
            newFormula = {},
            setter = {},
            miscFormula = "";
        try {
            //TAS.debug("PFMigrate.migrateMoveIntIntoMacro: ",v);
            if (!parseInt(v[migrateFlag], 10)) {
                miscVal = parseInt(v[miscAttr], 10) || 0;
                formVal = parseInt(v[modAttr], 10) || 0;
                if (miscMacroAttr) {
                    miscFormula = v[miscMacroAttr];
                }
                newFormula = addNumberToMacro(v[macroAttr], formVal, miscFormula, miscVal);
                if (newFormula.macroText && newFormula.macroText !== v[macroAttr]) {
                    setter[macroAttr] = newFormula.macroText;
                    setter[modAttr] = newFormula.macroVal;
                }
                setter[migrateFlag] = 1;
                setter[miscAttr] = "";
                if (miscMacroAttr) {
                    setter[miscMacroAttr] = "";
                }
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFMigrate.migrateMoveIntIntoMacro:" + migrateFlag, err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                setAttrs(setter, _PFConst2.default.silentParams, done);
            } else {
                done();
            }
        }
    });
}
/**migrateHPMisc copies HP-misc into HP-formula-macro-text and HP-formula-mod 
 * This modifies the same fields aas migrateNPC so make sure to call them in sequence not at the same time!
 *@param {function} callback when done.
 */
function migrateHPMisc(callback) {
    //TAS.debug("at migrateHPMisc");
    migrateMoveIntIntoMacro(callback, "migrated_hp_misc", "HP-formula-macro-text", "HP-formula-mod", "", "HP-misc");
}
/**migrateHPMisc copies Max-Skill-Ranks-Misc2 into Max-Skill-Ranks-Misc
 *@param {function} callback when done.
 */
function migrateMaxSkills(callback) {
    //TAS.debug("at migrateMaxSkills");
    migrateMoveIntIntoMacro(callback, "migrated_maxskill_misc", "Max-Skill-Ranks-Misc", "Max-Skill-Ranks-mod", "", "Max-Skill-Ranks-Misc2");
}
/** updates NPC from pre v 1.00 to version 1.00 
 * @param {function} callback call when done
 * @param {number} oldversion the sheet attribute PFVersion.
 */
function migrateNPC(callback, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("Leaving migrateNPC");
        if (typeof callback === "function") {
            callback();
        }
    }),
        migrateNPCConfig = function migrateNPCConfig(callback) {
        setAttrs({ 'normal_macro_show': 1,
            'use_traits': 0, 'use_racial_traits': 0, 'npc-compimport-show': 0 }, _PFConst2.default.silentParams, callback);
    },

    /* updates hp and hp|max, resets npc-hp as avg of hit dice only (npc-hd and npc-hd-num) ,
    * sets class-0-hd and class-0-level to values of  npc-hd2 and npc-hd-num2 
    * if undead then sets ability to CHA */
    migrateNPCHP = function migrateNPCHP(callback) {
        var done = _underscore2.default.once(function () {
            _exportsLoaderTASTheAaronSheet2.default.debug("Leaving PFMigrate.migrateNPCHP");
            if (typeof callback === "function") {
                callback();
            }
        });
        getAttrs(["HP-ability", "HP-ability-mod", "npc-type", "CON-mod", "CHA-mod", "total-hp", "level", "bab", "HP-formula-macro-text", "HP-formula-mod", "class-0-level", "class-1-level", "class-2-level", "class-3-level", "class-4-level", "class-5-level", "class-0-hp", "class-1-hp", "class-2-hp", "class-3-hp", "class-4-hp", "class-5-hp", "is_undead", "npc-hd-misc", "npc-hd-misc-mod", "npc-hd", "npc-hd-num", "npc-hd2", "npc-hd-num2", 'npc-bab'], function (v) {
            var isUndead = 0,
                abilityMod = 0,
                ability = '',
                classLevels = 0,
                classhd = 0,
                level = 0,
                totalhp = 0,
                hitdice = 0,
                hitdie = 0,
                basehp = 0,
                tempInt = 0,
                classhp = 0,
                classNum = 0,
                abilityModTot = 0,
                tempLvl = 0,
                temphp = 0,
                currLevel = 0,
                currHP = 0,
                setter = {},
                bab = 0,
                npcbab = 0,
                newbab = 0,
                newFormula = {},
                hdMiscVal = 0,
                currhpFormVal = 0;
            try {
                hitdice = parseInt(v['npc-hd-num'], 10) || 0;
                hitdie = parseInt(v["npc-hd"], 10) || 0;
                if (hitdice > 0 && hitdie > 0) {
                    setter["auto_calc_hp"] = "1";
                }
                classLevels = parseInt(v['npc-hd-num2'], 10) || 0;
                classhd = parseInt(v['npc-hd2'], 10) || 0;

                //get basic numbers
                isUndead = /undead/i.test(v["npc-type"]) || parseInt(v.is_undead, 10) || 0;
                setter["is_undead"] = isUndead;

                currLevel = parseInt(v.level, 10) || 0;
                currHP = parseInt(v.HP, 10) || 0;

                bab = parseInt(v.bab, 10) || 0;
                npcbab = parseInt(v['npc-bab'], 10) || 0;
                newbab = bab + npcbab;
                if (newbab !== bab) {
                    setter["bab"] = newbab;
                }

                abilityMod = isUndead ? parseInt(v["CHA-mod"], 10) || 0 : parseInt(v["HP-ability-mod"], 10) || 0;
                abilityModTot = abilityMod * (currLevel || hitdice);
                ability = isUndead ? '@{CHA-mod}' : '@{CON-mod}';
                setter["HP-ability"] = ability;
                setter["HP-ability-mod"] = abilityMod;

                //get the +xx portion and move to correct field.
                hdMiscVal = parseInt(v["npc-hd-misc-mod"], 10) || 0;
                currhpFormVal = parseInt(v["HP-formula-mod"], 10) || 0;
                if (hdMiscVal || v["HP-formula-macro-text"]) {
                    setter["npc-hd-misc"] = "";
                    setter["npc-hd-misc-mod"] = "";
                }
                if (hdMiscVal) {
                    hdMiscVal -= abilityModTot;
                }
                newFormula = addNumberToMacro(v["HP-formula-macro-text"], currhpFormVal, v["npc-hd-misc"], hdMiscVal);
                if (newFormula.macroText && newFormula.macroText !== v["HP-formula-macro-text"]) {
                    setter["HP-formula-macro-text"] = newFormula.macroText;
                    setter["HP-formula-mod"] = newFormula.macroVal;
                }
                basehp = PFUtils.getAvgHP(hitdice, hitdie);
                setter["NPC-HP"] = basehp;

                if (classLevels > 0) {
                    //should be class-0-name, if not, something is really wrong.
                    for (classNum = 0; classNum < 6; classNum++) {
                        tempInt = parseInt(v['class-' + classNum + '-level'], 10);
                        temphp = parseInt(v['class-' + classNum + '-hp'], 10);
                        if (!tempInt && !temphp) {
                            break;
                        }
                    }
                    if (classNum < 6) {
                        classhp = PFUtils.getAvgHP(classLevels, classhd);
                        setter['class-' + classNum + '-hp'] = classhp;
                        setter['class-' + classNum + '-level'] = classLevels;
                        setter['class-' + classNum + '-hd'] = classhd;
                    } else {
                        _exportsLoaderTASTheAaronSheet2.default.error("Cannot convert npc class hit dice, the class grid is full! class levels:" + classLevels + ", class hit die:" + classhd);
                        classLevels = 0;
                    }
                }
                totalhp = currHP + basehp + classhp;
                level = currLevel + classLevels + hitdice;
                if (totalhp !== currHP) {
                    setter['total-hp'] = totalhp;
                }
                if (level !== currLevel) {
                    setter['level'] = level;
                }
            } catch (err) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFMigrate.MigrateNPC", err);
            } finally {
                setter["migrated_npc"] = 1;
                if (_underscore2.default.size(setter) > 0) {
                    setAttrs(setter, _PFConst2.default.silentParams, done);
                } else {
                    done();
                }
            }
        });
    },

    /* copies or appends sense to vision */
    migrateNPCSenses = function migrateNPCSenses(callback) {
        var done = function done() {
            if (typeof callback === "function") {
                callback();
            }
        };
        getAttrs(["senses", "vision", "character-description"], function (v) {
            var a = '',
                b = '',
                c = '',
                setter = {};
            try {
                a = v.senses || '';
                b = v.vision || '';
                if (a && b) {
                    c = a + ', ' + b;
                } else {
                    c = a || b;
                }
                if (c) {
                    setter.vision = c;
                }
                if (a) {
                    setter.senses = '';
                }
            } catch (err) {
                _exportsLoaderTASTheAaronSheet2.default.error("migrateNPCSenses", err);
            } finally {
                if (_underscore2.default.size(setter) > 0) {
                    setAttrs(setter, _PFConst2.default.silentParams, done);
                } else {
                    done();
                }
            }
        });
    };

    getAttrs(["migrated_npc", "is_npc"], function (v) {
        var isNPC = 0,
            isMigrated = 0,
            doneSub = _underscore2.default.after(3, done);
        try {
            isNPC = parseInt(v["is_npc"], 10) || 0;
            isMigrated = parseInt(v["migrated_npc"], 10) || 0;
            if (!isNPC) {
                if (!isMigrated) {
                    setAttrs({ "migrated_npc": 1 }, _PFConst2.default.silentParams, done);
                } else {
                    done();
                }
            }
            if (!isMigrated) {
                migrateNPCSenses(doneSub);
                migrateNPCConfig(doneSub);
                migrateNPCHP(doneSub);
            } else {
                done();
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFMigrate.migrateNPC", err);
            done();
        }
    });
}
/** looks at dropdowns for cmb2 and ranged2 and if they are set to anything then check the 'show' checkboxes on config 
 * @param {function} callback call when done */
function migrateAltAttackGridrowFlags(callback) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    };
    getAttrs(["ranged_2_show", "cmb_2_show", "ranged2-ability", "CMB2-ability", "migratedAttack2row"], function (v) {
        var setter = {};
        try {
            if ((parseInt(v['migratedAttack2row'], 10) || 0) === 0) {
                if (PFUtils.findAbilityInString(v["ranged2-ability"]) && parseInt(v.ranged_2_show, 10) !== 1) {
                    setter.ranged_2_show = 1;
                }
                if (PFUtils.findAbilityInString(v["CMB2-ability"]) && parseInt(v.cmb_2_show, 10) !== 1) {
                    setter.cmb_2_show = 1;
                }
                setter["migratedAttack2row"] = 1;
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFMigrate.migrateAltAttackGridrowFlags", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                setAttrs(setter, { silent: true }, done);
            } else {
                done();
            }
        }
    });
}
function migrateExperience(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving migrateExperience");
        if (typeof callback === "function") {
            callback();
        }
    });
    getAttrs(['migrated_experience', 'use_prestige_fame', 'use_hero_points', 'prestige', 'fame', 'hero-points', 'faction_notes'], function (v) {
        var mig = parseInt(v.migrated_experience, 10) || 0,
            setter = {};
        if (mig) {
            done();
            return;
        }
        if ((parseInt(v.prestige, 10) || 0 || parseInt(v.fame, 10) || 0 || v.faction_notes) && !parseInt(v.use_prestige_fame, 10)) {
            setter.use_prestige_fame = 1;
        }
        if ((parseInt(v['hero-points'], 10) || 0) && !parseInt(v.use_hero_points, 10)) {
            setter.use_hero_points = 1;
        }
        setter.skill_onetimecolumns_show = 1;
        setter.misc_skill_num_show = 1;
        setter.migrated_experience = 1;
        setter.custom_skill_num_show = 1;
        setAttrs(setter, { silent: true }, done);
    });
}
function migrateUsesSpellFlag(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving migrateUsesSpellFlag");
        if (typeof callback === "function") {
            callback();
        }
    }),
        setFlag = function setFlag() {
        setAttrs({ 'migrated_spellflag': 1 }, _PFConst2.default.silentParams, done);
    },
        tryTwoJustCountRows = function tryTwoJustCountRows() {
        getSectionIDs('repeating_spells', function (ids) {
            if (ids && _underscore2.default.size(ids) > 0) {
                setAttrs({ 'use_spells': 1 }, _PFConst2.default.silentParams, setFlag);
            } else {
                setAttrs({ 'use_spells': 0 }, _PFConst2.default.silentParams, setFlag);
            }
        });
    };
    getAttrs(['spellclass-0-level', 'spellclass-1-level', 'spellclass-2-level', 'use_spells', 'migrated_spellflag'], function (v) {
        var lvl1 = 0,
            lvl2 = 0,
            lvl3 = 0,
            usesSpells = 0,
            setter = {};
        try {
            usesSpells = parseInt(v.use_spells, 10) || 0;
            if ((parseInt(v.migrated_spellflag, 10) || 0) !== 1 && !usesSpells) {
                lvl1 = parseInt(v['spellclass-0-level'], 10) || 0;
                lvl2 = parseInt(v['spellclass-1-level'], 10) || 0;
                lvl3 = parseInt(v['spellclass-3-level'], 10) || 0;
                if (lvl1 || lvl2 || lvl3) {
                    usesSpells = 1;
                    setter['use_spells'] = 1;
                }
                if (lvl1 && lvl2 || lvl2 && lvl3 || lvl1 && lvl3) {
                    setter['spellclasses_multiclassed'] = 1;
                }
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("FMigrate.migrateUsesSpellFlag", err);
        } finally {
            if (usesSpells) {
                setAttrs(setter, _PFConst2.default.silentParams, setFlag);
            } else {
                tryTwoJustCountRows();
            }
        }
    });
}

/** migrates repeating_item name, short-description, type, and weight to have item- prefix to avoid duplicate attributes
 * @param {function} callback call after finishing */
function migrateRepeatingItemAttributes(callback) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    };
    getAttrs(["migrated_repeating_item_attributes"], function (m) {
        var duplicateFields = ["weight", "hp", "hp_max"],
            // repeating fields can have duplicate attrbitues with other repeating lists, but not non-repeating list attrbiutes
        resetFields = ["qty", "qty_max"];
        if (parseInt(m["migrated_repeating_item_attributes"], 10)) {
            //TAS.debug"Duplicate repeating_item attributes already migrated; exiting");
            done();
            return;
        }
        getSectionIDs("repeating_item", function (ids) {
            var fields = [];
            if (!(ids && _underscore2.default.size(ids) > 0)) {
                setAttrs({ 'migrated_repeating_item_attributes': 1 }, _PFConst2.default.silentParams, done);
                return;
            }
            fields = _underscore2.default.reduce(ids, function (memo, id) {
                var prefix = "repeating_item_" + SWUtils.getRepeatingIDStr(id),
                    row = [];
                _underscore2.default.each(duplicateFields, function (field) {
                    row.push(prefix + field);
                });
                _underscore2.default.each(resetFields, function (field) {
                    row.push(prefix + field);
                });
                return memo.concat(row);
            }, []);

            getAttrs(fields, function (v) {
                var setter = {};
                try {
                    _underscore2.default.each(ids, function (id) {
                        var prefix = "repeating_item_" + SWUtils.getRepeatingIDStr(id);
                        duplicateFields.forEach(function (attr) {
                            var newInt = parseInt(v[prefix + attr], 10) || 0;
                            if (v[prefix + attr] && newInt !== 0) {
                                setter[prefix + "item-" + attr] = newInt;
                                setter[prefix + attr] = "";
                            }
                        });

                        //new default is 1, old was undefined 
                        if (isNaN(parseInt(v[prefix + "qty"], 10))) {
                            setter[prefix + "qty"] = 1;
                        }
                        if (isNaN(parseInt(v[prefix + "qty_max"], 10))) {
                            setter[prefix + "qty_max"] = 0;
                        }
                    });
                    setter["migrated_repeating_item_attributes"] = "1";
                } catch (err) {
                    _exportsLoaderTASTheAaronSheet2.default.error("migrateRepeatingItemAttributes", err);
                } finally {
                    _exportsLoaderTASTheAaronSheet2.default.debug("##### PFMigrate.migrateRepeatingItemAttributes setting  ", setter);
                    if (_underscore2.default.size(setter) > 0) {
                        setAttrs(setter, {}, done);
                    } else {
                        done();
                    }
                }
            });
        });
    });
}
function migrateAbilityListFlags(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving migrateAbilityListFlags");
        if (typeof callback === "function") {
            callback();
        }
    }),
        setFlag = _underscore2.default.after(5, function () {
        setAttrs({ 'migrated_abilityflags109': 1 }, _PFConst2.default.silentParams, done);
    });
    getAttrs(['migrated_abilityflags109', 'uses_feats', 'uses_traits', 'use_racial_traits', 'use_class_features', 'use_npc-spell-like-abilities'], function (vm) {
        if (!parseInt(vm['migrated_abilityflags109'], 10)) {
            getSectionIDs('repeating_npc-spell-like-abilities', function (ids) {
                if (ids && _underscore2.default.size(ids) > 0) {
                    setAttrs({ 'use_npc-spell-like-abilities': 1 }, _PFConst2.default.silentParams, setFlag);
                } else {
                    setAttrs({ 'use_npc-spell-like-abilities': 0 }, _PFConst2.default.silentParams, setFlag);
                }
            });
            getSectionIDs('repeating_feat', function (ids) {
                if (ids && _underscore2.default.size(ids) > 0) {
                    setAttrs({ 'use_feats': 1 }, _PFConst2.default.silentParams, setFlag);
                } else {
                    setAttrs({ 'use_feats': 0 }, _PFConst2.default.silentParams, setFlag);
                }
            });
            getSectionIDs('repeating_class-ability', function (ids) {
                if (ids && _underscore2.default.size(ids) > 0) {
                    setAttrs({ 'use_class_features': 1 }, _PFConst2.default.silentParams, setFlag);
                } else {
                    setAttrs({ 'use_class_features': 0 }, _PFConst2.default.silentParams, setFlag);
                }
            });
            getSectionIDs('repeating_trait', function (ids) {
                if (ids && _underscore2.default.size(ids) > 0) {
                    setAttrs({ 'use_traits': 1 }, _PFConst2.default.silentParams, setFlag);
                } else {
                    setAttrs({ 'use_traits': 0 }, _PFConst2.default.silentParams, setFlag);
                }
            });
            getSectionIDs('repeating_racial-trait', function (ids) {
                if (ids && _underscore2.default.size(ids) > 0) {
                    setAttrs({ 'use_racial_traits': 1 }, _PFConst2.default.silentParams, setFlag);
                } else {
                    setAttrs({ 'use_racial_traits': 0 }, _PFConst2.default.silentParams, setFlag);
                }
            });
        } else {
            done();
        }
    });
}
function migrateSpellPointFlag(callback, oldversion) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    _exportsLoaderTASTheAaronSheet2.default.debug("AT PFMigrate.migrateSpellPointFlag: oldversion:" + oldversion);
    if (oldversion > 1.18) {
        done();
    }
    getAttrs(['spellclass-0-spell-points-class', 'spellclass-0-spell-points-bonus', 'spellclass-0-spell-points-misc', 'spellclass-1-spell-points-class', 'spellclass-1-spell-points-bonus', 'spellclass-1-spell-points-misc', 'spellclass-2-spell-points-class', 'spellclass-2-spell-points-bonus', 'spellclass-2-spell-points-misc', 'use_spell_points'], function (v) {
        var usesPoints = parseInt('spellclass-0-spell-points-class', 10) || parseInt('spellclass-0-spell-points-bonus', 10) || parseInt('spellclass-0-spell-points-misc', 10) || parseInt('spellclass-1-spell-points-class', 10) || parseInt('spellclass-1-spell-points-bonus', 10) || parseInt('spellclass-1-spell-points-misc', 10) || parseInt('spellclass-2-spell-points-class', 10) || parseInt('spellclass-2-spell-points-bonus', 10) || parseInt('spellclass-2-spell-points-misc', 10);
        _exportsLoaderTASTheAaronSheet2.default.debug("PFMigrate.migrateSpellPointFlag found ", v);
        if (usesPoints && !parseInt(v.use_spell_points, 10)) {
            setAttrs({ 'uses_spell_points': 1 }, _PFConst2.default.silentParams, done);
        } else {
            done();
        }
    });
}

function migrateWhisperDropdowns(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFMigrate migrateConfigFlags");
        if (typeof callback === "function") {
            callback();
        }
    });
    getAttrs(['migrated_whispers', 'PC-whisper', 'NPC-whisper'], function (v) {
        var setter = {};
        try {
            if (!parseInt(v.migrated_whispers, 10)) {
                if (v['PC-whisper'] === '&nbsp;' || v['PC-whisper'] === ' ' || v['PC-whisper'] && v['PC-whisper'] !== '/w gm') {
                    setter['PC-whisper'] = '';
                }
                if (v['NPC-whisper'] === '&nbsp;' || v['NPC-whisper'] === ' ' || v['NPC-whisper'] && v['NPC-whisper'] !== '/w gm') {
                    setter['NPC-whisper'] = '';
                }
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFMigrate.migrateWhispers", err);
        } finally {
            if (_underscore2.default.size(setter)) {
                setAttrs(setter, _PFConst2.default.silentParams, done);
            } else {
                done();
            }
        }
    });
}

function migrateConfigFlags(callback, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFMigrate migrateConfigFlags");
        if (typeof callback === "function") {
            callback();
        }
    });
    migrateNPC(function () {
        migrateHPMisc(done);
    });
    migrateRollTemplateImages();
    migrateAltAttackGridrowFlags();
    migrateUsesSpellFlag();
    migrateAbilityListFlags();
    migrateExperience();
    migrateSpellPointFlag(null, oldversion);
    migrateWhisperDropdowns();
}

function getAllMigrateFlags(v) {
    _exportsLoaderTASTheAaronSheet2.default.debug("at PFMigrate.getAllMigrateFlags");
    v = v || {};
    v['migrated_buffs'] = 1;
    v['migrated_effects'] = 1;
    v['classSkillsMigrated'] = 1;
    v['migrated_spells'] = 1;
    v['spellranges_migrated'] = 1;
    v['migrated_damage-multiplier'] = 1;
    v['migrated_experience'] = 1;
    v['migrated_spellflag'] = 1;
    v['migratedAttack2row'] = 1;
    v['migrated_npc'] = 1;
    v['migrated_worn_equipment'] = 1;
    v['migrated_repeating_item_attributes'] = 1;
    v['migrated_skill_macrosv1'] = 1;
    v['migrated_attack_macrosv1'] = 1;
    v['migrated_spells_macrosv1'] = 1;
    v['migrated_feature_macrosv109'] = 1;
    v['migrated_ability_macrosv112'] = 1;
    v['migrated_item_macrosv1'] = 1;
    v['migrated_hp_misc'] = 1;
    v['migrated_maxskill_misc'] = 1;
    v['migrated_featurelists_defaults'] = 1;
    v['migrated_attacklist_defaults111'] = 1;
    v['migrated_itemlist_defaults'] = 1;
    v['migrated_abilityflags109'] = 1;
    v["migrated_buffs_rangeddmg_abiilty"] = 1;
    return v;
}
function setAllMigrateFlags(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFMigrate setAllMigrateFlags");
        if (typeof callback === "function") {
            callback();
        }
    });
    setAttrs(getAllMigrateFlags(), _PFConst2.default.silentParams, done);
}

_PFLog.PFConsole.log('   PFMigrate module loaded        ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.attackGridFields = undefined;
exports.applyConditions = applyConditions;
exports.updateAttack = updateAttack;
exports.setTopMacros = setTopMacros;
exports.resetCommandMacro = resetCommandMacro;
exports.updateAttackGrid = updateAttackGrid;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

var _PFMenus = __webpack_require__(14);

var PFMenus = _interopRequireWildcard(_PFMenus);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var attackGridFields = exports.attackGridFields = {
    "melee": {
        "size": "size",
        "atk": "attk-melee",
        "buff": "buff_Melee-total",
        "abilityMod": "melee-ability-mod",
        "misc": "attk-melee-misc",
        "crit": "attk_melee_crit_conf",
        "attackmacro": "@{toggle_global_melee_macro_insert}",
        "damagemacro": "@{toggle_global_melee_damage_macro_insert}"
    },
    "melee2": {
        "size": "size",
        "atk": "attk-melee2",
        "buff": "buff_Melee-total",
        "abilityMod": "melee2-ability-mod",
        "misc": "attk-melee2-misc",
        "crit": "attk_melee2_crit_conf",
        "attackmacro": "@{toggle_global_melee_macro_insert}",
        "damagemacro": "@{toggle_global_melee_damage_macro_insert}"
    },
    "ranged": {
        "size": "size",
        "atk": "attk-ranged",
        "buff": "buff_Ranged-total",
        "abilityMod": "ranged-ability-mod",
        "misc": "attk-ranged-misc",
        "crit": "attk_ranged_crit_conf",
        "attackmacro": "@{toggle_global_ranged_macro_insert}",
        "damagemacro": "@{toggle_global_ranged_damage_macro_insert}"
    },
    "ranged2": {
        "size": "size",
        "atk": "attk-ranged2",
        "buff": "buff_Ranged-total",
        "abilityMod": "ranged2-ability-mod",
        "misc": "attk-ranged2-misc",
        "crit": "attk_ranged2_crit_conf",
        "attackmacro": "@{toggle_global_ranged_macro_insert}",
        "damagemacro": "@{toggle_global_ranged_damage_macro_insert}"
    },
    "CMB": {
        "size": "CMD-size",
        "atk": "CMB",
        "buff": "buff_CMB-total",
        "abilityMod": "CMB-ability-mod",
        "misc": "attk-CMB-misc",
        "crit": "attk_cmb_crit_conf",
        "attackmacro": "@{toggle_global_cmb_macro_insert}",
        "damagemacro": "@{toggle_global_cmb_damage_macro_insert}"
    },
    "CMB2": {
        "size": "CMD-size",
        "atk": "CMB2",
        "buff": "buff_CMB-total",
        "abilityMod": "CMB2-ability-mod",
        "misc": "attk-CMB2-misc",
        "crit": "attk_cmb2_crit_conf",
        "attackmacro": "@{toggle_global_cmb_macro_insert}",
        "damagemacro": "@{toggle_global_cmb_damage_macro_insert}"
    }
};
var attkpenaltyAddToFields = ["condition-Invisible", "acp-attack-mod", "condition-Drained"],
    attkpenaltySubtractFromFields = ["condition-Dazzled", "condition-Entangled", "condition-Grappled", "condition-Fear", "condition-Prone", "condition-Sickened", "condition-Wounds"],
    attkpenaltySumRow = ["attk-penalty"].concat(attkpenaltyAddToFields),
    groupMapForMenu = { '0': 'none', '@{attk-melee}': 'melee', '@{attk-melee2}': 'melee',
    '@{attk-ranged}': 'ranged', '@{attk-ranged2}': 'ranged2',
    '@{CMB}': 'combat-maneuver-bonus-abbrv', '@{CMB2}': 'combat-maneuver-bonus-abbrv' };

/** updates the attk-penalty for attacks based on conditions including wearing armor you are not proficient in 
 *@param {function} callback optional call when done
 *@param {boolean} silently optional if true call setAttrs with PFConst.silentParams
 *@param {eventInfo} eventInfo unused eventInfo from on method
 */
function applyConditions(callback, silently, eventInfo) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    SWUtils.updateRowTotal(attkpenaltySumRow, 0, attkpenaltySubtractFromFields, false, done, silently);
}
/** updateAttack - updates one row of attack grid (left most column in grid)
 * Updates the attack type totals at top of attack page for one row of grid
 * @param {string} attype = key for attackGridFields to indicate which row from attack grid
 * @param {eventInfo } eventInfo unused
 * @param {function} callback optional call when done
 * @param {boolean} silently optional if true call setAttrs with PFConst.silentParams
 */
function updateAttack(attype, eventInfo, callback, silently) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    }),
        fields;
    if (attackGridFields[attype]) {
        fields = [attackGridFields[attype].atk, "bab", "attk-penalty", attackGridFields[attype].abilityMod, attackGridFields[attype].misc, attackGridFields[attype].size, attackGridFields[attype].buff];
        if (attype === 'CMB') {
            fields.push('buff_Melee-total');
        }
        SWUtils.updateRowTotal(fields, 0, [], false, done, silently);
    } else {
        _exportsLoaderTASTheAaronSheet2.default.error("PFAttackGrid.updateAttack attack grid fields do not exist for: " + attype);
        done();
    }
}

function getTopMacros(setter, v) {
    var header = "{{row01= **^{base-attacks}** }} {{row02=[^{melee}](~@{character_id}|Melee-Attack-Roll) [^{ranged}](~@{character_id}|Ranged-Attack-Roll) [^{combat-maneuver-bonus-abbrv}](~@{character_id}|CMB-Check) [^{melee2}](~@{character_id}|Melee2-Attack-Roll)",
        npcHeader = "{{row01= **^{base-attacks}** }} {{row02=[^{melee}](~@{character_id}|NPC-Melee-Attack-Roll) [^{ranged}](~@{character_id}|NPC-Ranged-Attack-Roll) [^{combat-maneuver-bonus-abbrv}](~@{character_id}|NPC-CMB-Check) [^{melee2}](~@{character_id}|NPC-Melee2-Attack-Roll)",
        extraattacks = "",
        npcextraattacks = "",
        ranged2BaseAttacks = " [^{ranged2}](~@{character_id}|Ranged2-Attack-Roll)",
        cmb2BaseAttacks = " [^{combat-maneuver-bonus-abbrv2}](~@{character_id}|CMB2-Check)",
        npcranged2BaseAttacks = " [^{ranged2}](~@{character_id}|npc-Ranged2-Attack-Roll)",
        npccmb2BaseAttacks = " [^{combat-maneuver-bonus-abbrv2}](~@{character_id}|npc-CMB2-Check)";
    try {
        //TAS.debug("at PFAttackGrid.getTopMacros",v);
        setter = setter || {};
        if (parseInt(v.ranged_2_show, 10)) {
            extraattacks += ranged2BaseAttacks;
            npcextraattacks += npcranged2BaseAttacks;
        }
        if (parseInt(v.cmb_2_show, 10)) {
            extraattacks += cmb2BaseAttacks;
            npcextraattacks += npccmb2BaseAttacks;
        }
        header += extraattacks + " }}";
        npcHeader += npcextraattacks + " }}";
        //TAS.debug("PFAtackGrid.getTopMenus new macros are: ", header, npcHeader);
        if (v.attacks_header_macro !== header || v["NPC-attacks_header_macro"] !== npcHeader) {
            setter.attacks_header_macro = header;
            setter["NPC-attacks_header_macro"] = npcHeader;
        }
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFAttackGrid.getTopMacros", err);
    } finally {
        return setter;
    }
}
function setTopMacros(callback) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    //TAS.debug("at PFAttackGrid.setTopMacros");
    getAttrs(["attacks_header_macro", "NPC-attacks_header_macro", "ranged_2_show", "cmb_2_show"], function (v) {
        var setter = {};
        getTopMacros(setter, v);
        if (_underscore2.default.size(setter) && (v.attacks_header_macro !== setter.attacks_header_macro || v["NPC-attacks_header_macro"] !== setter["NPC-attacks_header_macro"])) {
            setAttrs(setter, _PFConst2.default.silentParams, done);
        } else {
            done();
        }
    });
}

function resetCommandMacro(callback) {
    var done = _underscore2.default.after(2, function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    _exportsLoaderTASTheAaronSheet2.default.debug("at PFAttackGrid.resetCommandMacro");
    PFMenus.resetOneCommandMacro('attacks', false, done, " @{attacks_header_macro}", groupMapForMenu);
    PFMenus.resetOneCommandMacro('attacks', true, done, " @{NPC-attacks_header_macro}", groupMapForMenu);
}
/**
 * 
 * @param {string} buffType buff column without 'buff_' or '-total'
 * @param {*} eventInfo 
 */
function updateAttackGrid(buffType, eventInfo) {
    switch (buffType.toLowerCase()) {
        case 'melee':
            updateAttack('melee', eventInfo);
            updateAttack('melee2', eventInfo);
            updateAttack('CMB', eventInfo);
            updateAttack('CMB2', eventInfo);
            break;
        case 'ranged':
            updateAttack('ranged', eventInfo);
            updateAttack('ranged2', eventInfo);
            break;
        case 'cmb':
            updateAttack('CMB', eventInfo);
            updateAttack('CMB2', eventInfo);
            break;
    }
}

function migrate(callback, oldversion) {
    var done = function done() {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAttackGrid.migrate");
        if (typeof callback === "function") {
            callback();
        }
    };
    PFMigrate.migrateAltAttackGridrowFlags();
    done();
}
/** recalculates all write-to fields in module 
 * @param {function} callback optional call when done
 * @param {boolean} silently optional if true call setAttrs with PFConst.silentParams
 * @param {number} oldversion the version upgrading from 
 */
function recalculate(callback, silently, oldversion) {
    var done = function done() {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAttackGrid.recalculate");
        if (typeof callback === "function") {
            callback();
        }
    },
        doneAttack = _underscore2.default.after(6, done),
        callUpdateAttacksAndDamage = _underscore2.default.once(function () {
        _underscore2.default.each(attackGridFields, function (attrMap, attack) {
            updateAttack(attack, null, doneAttack, silently);
        });
    }),
        callApplyConditions = _underscore2.default.once(function () {
        applyConditions(callUpdateAttacksAndDamage, silently);
    });
    //TAS.debug"At PFAttackGrid.recalculate");
    migrate(callApplyConditions, oldversion);
    setTopMacros();
}
function registerEventHandlers() {
    _underscore2.default.each(attackGridFields, function (attackFields, attack) {
        on("change:bab change:" + attackFields.size, _exportsLoaderTASTheAaronSheet2.default.callback(function eventBABSizeAbilityModchange(eventInfo) {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            updateAttack(attack);
        }));
        on("change:" + attackFields.misc, _exportsLoaderTASTheAaronSheet2.default.callback(function eventAttackMisc(eventInfo) {
            if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                updateAttack(attack);
            }
        }));
        on("change:attk-penalty change:" + attackFields.abilityMod, _exportsLoaderTASTheAaronSheet2.default.callback(function eventAttackPenalty(eventInfo) {
            if (eventInfo.sourceType === "sheetworker") {
                _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                updateAttack(attack);
            }
        }));
    });

    on("change:acp-attack-mod", _exportsLoaderTASTheAaronSheet2.default.callback(function PFAttackGrid_applyConditions(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        applyConditions();
    }));
    on("change:cmb_2_show change:ranged_2_show", _exportsLoaderTASTheAaronSheet2.default.callback(function displayRangedOrCMB2(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            setTopMacros();
        }
    }));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFAttackGrid module loaded     ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.recalculate = exports.linkedAttackType = exports.updateCharAttrs = exports.sizeFieldsLU = exports.sizeFields = exports.updateRowAttrsLU = exports.updateRowAttrs = exports.damageRowAttrsLU = exports.damageRowAttrs = undefined;
exports.updateRepeatingWeaponDamages = updateRepeatingWeaponDamages;
exports.updateAssociatedAttacksFromParents = updateAssociatedAttacksFromParents;
exports.syncAllDefaultDamageDiceAsync = syncAllDefaultDamageDiceAsync;
exports.adjustAllDamageDiceAsync = adjustAllDamageDiceAsync;
exports.recalculateRepeatingWeapons = recalculateRepeatingWeapons;
exports.removeLinkedAttack = removeLinkedAttack;
exports.setDualWieldVals = setDualWieldVals;
exports.createDualWield = createDualWield;
exports.setNewDefaults = setNewDefaults;
exports.migrateRepeatingMacro = migrateRepeatingMacro;
exports.migrateLinkedAttacks = migrateLinkedAttacks;
exports.migrate = migrate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFUtilsAsync = __webpack_require__(9);

var PFUtilsAsync = _interopRequireWildcard(_PFUtilsAsync);

var _PFMacros = __webpack_require__(10);

var PFMacros = _interopRequireWildcard(_PFMacros);

var _PFMenus = __webpack_require__(14);

var PFMenus = _interopRequireWildcard(_PFMenus);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

var _PFAttackOptions = __webpack_require__(12);

var PFAttackOptions = _interopRequireWildcard(_PFAttackOptions);

var _PFAttackGrid = __webpack_require__(7);

var PFAttackGrid = _interopRequireWildcard(_PFAttackGrid);

var _PFInventory = __webpack_require__(30);

var PFInventory = _interopRequireWildcard(_PFInventory);

var _PFSpells = __webpack_require__(17);

var PFSpells = _interopRequireWildcard(_PFSpells);

var _PFAbility = __webpack_require__(18);

var PFAbility = _interopRequireWildcard(_PFAbility);

var _PFSize = __webpack_require__(15);

var PFSize = _interopRequireWildcard(_PFSize);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** module for repeating_weapon section  */
/* **********************************ATTACKS PAGE ********************************** */
var damageRowAttrs = exports.damageRowAttrs = ["damage-ability-max", "damage-ability-mod", "damage-mod", "damage_ability_mult", "enhance", "total-damage", "isranged"],
    damageRowAttrsLU = exports.damageRowAttrsLU = _underscore2.default.map(damageRowAttrs, function (a) {
	return '_' + a;
}),
    updateRowAttrs = exports.updateRowAttrs = ["attack-mod", "attack-type", "attack-type-mod", "crit_conf_mod", "crit_confirm", "isranged", "masterwork", "proficiency", "total-attack", "attack-type_macro_insert", "damage-type_macro_insert"].concat(damageRowAttrs),
    updateRowAttrsLU = exports.updateRowAttrsLU = _underscore2.default.map(updateRowAttrs, function (a) {
	return '_' + a;
}),
    sizeFields = exports.sizeFields = ['default_damage-dice-num', 'default_damage-die', 'default_size', 'not_default_size', 'damage-dice-num', 'damage-die', 'size_affects'],
    sizeFieldsLU = exports.sizeFieldsLU = ['_default_damage-dice-num', '_default_damage-die', '_default_size', '_not_default_size', '_damage-dice-num', '_damage-die', '_size_affects'],
    updateCharAttrs = exports.updateCharAttrs = ["attk_ranged_crit_conf", "attk_ranged2_crit_conf", "attk_melee_crit_conf", "attk_melee2_crit_conf", "attk_cmb_crit_conf", "attk_cmb2_crit_conf", "condition-Sickened", "buff_DMG-total", "buff_DMG_Ranged-total", "size", "default_char_size", "modify_dmg_by_size"],
    linkedAttackType = exports.linkedAttackType = { 'equipment': 1, 'spell': 2, 'ability': 3, 'weapon': 4 };

var defaultRepeatingMacro = '&{template:pf_attack} @{toggle_attack_accessible} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=@{name}}} {{attack=[[ 1d20cs>[[ @{crit-target} ]] + @{attack_macro} ]]}} {{damage=[[@{damage-dice-num}d@{damage-die} + @{damage_macro}]]}} {{crit_confirm=[[ 1d20 + @{attack_macro} + [[ @{crit_conf_mod} ]] ]]}} {{crit_damage=[[ [[ @{damage-dice-num} * (@{crit-multiplier} - 1) ]]d@{damage-die} + ((@{damage_macro}) * [[ @{crit-multiplier} - 1 ]]) ]]}} {{type=@{type}}} {{weapon_notes=@{notes}}} @{iterative_attacks} @{macro_options} {{vs=@{vs}}} {{vs@{vs}=@{vs}}} {{precision_dmg1=@{precision_dmg_macro}}} {{precision_dmg1_type=@{precision_dmg_type}}} {{precision_dmg2=@{global_precision_dmg_macro}}} {{precision_dmg2_type=@{global_precision_dmg_type}}} {{critical_dmg1=@{critical_dmg_macro}}} {{critical_dmg1_type=@{critical_dmg_type}}} {{critical_dmg2=@{global_critical_dmg_macro}}} {{critical_dmg2_type=@{global_critical_dmg_type}}} {{attack1name=@{iterative_attack1_name}}}',
    defaultRepeatingMacroMap = {
	'&{template:': { 'current': 'pf_attack}', old: ['pf_generic}', 'pf_block}'] },
	'@{toggle_attack_accessible}': { 'current': '@{toggle_attack_accessible}' },
	'@{toggle_rounded_flag}': { 'current': '@{toggle_rounded_flag}' },
	'{{color=': { 'current': '@{rolltemplate_color}}}' },
	'{{character_name=': { 'current': '@{character_name}}}' },
	'{{character_id=': { 'current': '@{character_id}}}' },
	'{{subtitle}}': { 'current': '{{subtitle}}' },
	'{{name=': { 'current': '@{name}}}' },
	'{{attack=': { 'current': '[[ 1d20cs>[[ @{crit-target} ]] + @{attack_macro} ]]}}', 'old': ['{{attack=[[ 1d20cs>[[ @{crit-target} ]] + [[ @{total-attack} ]] ]]}}'], 'replacements': [{ 'from': '[[ @{total-attack} ]]', 'to': '@{attack_macro}' }, { 'from': '@{total-attack}', 'to': '@{attack_macro}' }] },
	'{{damage=': { 'current': '[[@{damage-dice-num}d@{damage-die} + @{damage_macro}]]}}', 'old': ['[[ @{damage-dice-num}d@{damage-die} + [[ @{total-damage} ]] ]]}}'], 'replacements': [{ 'from': '[[ @{total-damage} ]]', 'to': '@{damage_macro}' }, { 'from': '@{total-damage}', 'to': '@{damage_macro}' }] },
	'{{crit_confirm=': { 'current': '[[ 1d20 + @{attack_macro} + [[ @{crit_conf_mod} ]] ]]}}', 'old': ['[[ 1d20 + [[ @{total-attack} ]] ]]}}'], 'replacements': [{ 'from': '[[ @{total-attack} ]]', 'to': '@{attack_macro} + [[ @{crit_conf_mod} ]]' }, { 'from': '@{total-attack}', 'to': '@{attack_macro} + [[ @{crit_conf_mod} ]]' }] },
	'{{crit_damage=': { 'current': '[[ [[ @{damage-dice-num} * (@{crit-multiplier} - 1) ]]d@{damage-die} + ((@{damage_macro}) * [[ @{crit-multiplier} - 1 ]]) ]]}}', 'old': ['[[ [[ (@{damage-dice-num} * (@{crit-multiplier} - 1)) ]]d@{damage-die} + [[ (@{total-damage} * (@{crit-multiplier} - 1)) ]] ]]}}'], 'replacements': [{ 'from': '@{total-damage}', 'to': '(@{damage_macro})' }] },
	'{{type=': { 'current': '@{type}}}' },
	'{{weapon_notes=': { 'current': '@{notes}}}' },
	'@{iterative_attacks}': { 'current': '@{iterative_attacks}' },
	'@{macro_options}': { 'current': '@{macro_options}' },
	'{{vs=': { 'current': '@{vs}}}' },
	'{{vs@{vs}=': { 'current': '@{vs}}}' },
	'{{precision_dmg1=': { 'current': '@{precision_dmg_macro}}}' },
	'{{precision_dmg1_type=': { 'current': '@{precision_dmg_type}}}' },
	'{{precision_dmg2=': { 'current': '@{global_precision_dmg_macro}}}' },
	'{{precision_dmg2_type=': { 'current': '@{global_precision_dmg_type}}}' },
	'{{critical_dmg1=': { 'current': '@{critical_dmg_macro}}}' },
	'{{critical_dmg1_type=': { 'current': '@{critical_dmg_type}}}' },
	'{{critical_dmg2=': { 'current': '@{global_critical_dmg_macro}}}' },
	'{{critical_dmg2_type=': { 'current': '@{global_critical_dmg_type}}}' },
	'{{attack1name=': { 'current': '@{iterative_attack1_name}}}' }
},
    defaultDeletedMacroAttrs = ['{{description=@{notes}}}', '@{toggle_accessible_flag}'],
    defaultIterativeRepeatingMacro = '{{attackREPLACE=[[ 1d20cs>[[ @{crit-target} ]] + [[ @{attack_macro} + @{iterative_attackREPLACE_value} ]] [iterative] ]]}} {{damageREPLACE=[[ @{damage-dice-num}d@{damage-die} + @{damage_macro} ]]}} {{crit_confirmREPLACE=[[ 1d20 + [[ @{attack_macro} + @{iterative_attackREPLACE_value} ]] [iterative] + [[ @{crit_conf_mod} ]] ]]}} {{crit_damageREPLACE=[[ [[ @{damage-dice-num} * [[ @{crit-multiplier} - 1 ]] ]]d@{damage-die} + ((@{damage_macro}) * [[ @{crit-multiplier} - 1 ]]) ]]}} {{precision_dmgREPLACE1=@{precision_dmg_macro}}} {{precision_dmgREPLACE2=@{global_precision_dmg_macro}}} {{critical_dmgREPLACE1=@{critical_dmg_macro}}} {{critical_dmgREPLACE2=@{global_critical_dmg_macro}}} {{attackREPLACEname=@{iterative_attackREPLACE_name}}}',
    defaultIterativeRepeatingMacroMap = {
	'{{attackREPLACE=': { 'current': '[[ 1d20cs>[[ @{crit-target} ]] + [[ @{attack_macro} + @{iterative_attackREPLACE_value} ]] [iterative] ]]}}', 'old': ['[[ 1d20cs>[[ @{crit-target} ]] + [[ @{total-attack} + @{iterative_attackREPLACE_value} ]] ]]}}'], 'replacements': [{ 'from': '[[ @{total-attack} ]]', 'to': '@{attack_macro}' }, { 'from': '@{total-attack}', 'to': '@{attack_macro}' }] },
	'{{damageREPLACE=': { 'current': '[[ @{damage-dice-num}d@{damage-die} + @{damage_macro} ]]}}', 'old': ['[[ @{damage-dice-num}d@{damage-die} + [[ @{total-damage} ]] ]]}}'], 'replacements': [{ 'from': '[[ @{total-damage} ]]', 'to': '@{damage_macro}' }, { 'from': '@{total-damage}', 'to': '@{damage_macro}' }] },
	'{{crit_confirmREPLACE=': { 'current': '[[ 1d20 + [[ @{attack_macro} + @{iterative_attackREPLACE_value} ]] [iterative] + [[ @{crit_conf_mod} ]] ]]}}', 'old': ['[[ 1d20 + [[ @{total-attack} + @{iterative_attackREPLACE_value} ]] ]]}}'], 'replacements': [{ 'from': '[[ @{total-attack} + @{iterative_attackREPLACE_value} ]]', 'to': '[[ @{attack_macro} + @{iterative_attackREPLACE_value} ]] [iterative] + [[ @{crit_conf_mod} ]]' }, { 'from': '@{total-attack} + @{iterative_attackREPLACE_value}', 'to': '@{attack_macro} + @{iterative_attackREPLACE_value} + @{crit_conf_mod}' }] },
	'{{crit_damageREPLACE=': { 'current': '[[ [[ @{damage-dice-num} * [[ @{crit-multiplier} - 1 ]] ]]d@{damage-die} + ((@{damage_macro}) * [[ @{crit-multiplier} - 1 ]]) ]]}}', 'old': ['[[ [[ (@{damage-dice-num} * (@{crit-multiplier} - 1)) ]]d@{damage-die} + [[ (@{total-damage} * (@{crit-multiplier} - 1)) ]] ]]}}'], 'replacements': [{ 'from': '@{total-damage}', 'to': '(@{damage_macro})' }] },
	'{{precision_dmgREPLACE1=': { 'current': '@{precision_dmg_macro}}}' },
	'{{precision_dmgREPLACE2=': { 'current': '@{global_precision_dmg_macro}}}' },
	'{{critical_dmgREPLACE1=': { 'current': '@{critical_dmg_macro}}}' },
	'{{critical_dmgREPLACE2=': { 'current': '@{global_critical_dmg_macro}}}' },
	'{{attackREPLACEname=': { 'current': '@{iterative_attackREPLACE_name}}}' }
},
    defaultIterativeDeletedMacroAttrs = null,
    defaultIterativeAttrName = 'var_iterative_attackREPLACE_macro',
    defaultIterativeReplaceArray = ['2', '3', '4', '5', '6', '7', '8'];

function getRepeatingAddInMacroPortion(macro, toggle, portion) {
	if (!(macro === "" || macro === "0" || macro === undefined || macro === null || toggle === "" || toggle === "0" || toggle === undefined || toggle === null)) {
		return " " + portion;
	}
	return "";
}

function updateRepeatingAddInMacro(id, eventInfo) {
	var idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = "repeating_weapon_" + idStr,
	    attackType = prefix + "attack-type",
	    tattackPlusNm = prefix + "toggle_attack_macro_insert",
	    tdamagePlusNm = prefix + "toggle_damage_macro_insert",
	    attackPlusNm = prefix + "attack_macro_insert",
	    damagePlusNm = prefix + "damage_macro_insert",
	    tattackGlobalNm = "toggle_global_attack_macro_insert",
	    tdamageGlobalNm = "toggle_global_damage_macro_insert",
	    attackGlobalNm = "global_attack_macro_insert",
	    damageGlobalNm = "global_damage_macro_insert",
	    attackMacroNm = prefix + "attack_macro",
	    damageMacroNm = prefix + "damage_macro",
	    fields = ["adv_macro_show", attackType, attackGlobalNm, damageGlobalNm, attackPlusNm, damagePlusNm, attackMacroNm, damageMacroNm];
	getAttrs(fields, function (v) {
		var showMacros = parseInt(v.adv_macro_show, 10) || 0,
		    newAtkMacro = "[[ @{total-attack} ]]",
		    newDmgMacro = "[[ @{total-damage} ]]",
		    setter = {};
		if (showMacros) {
			newAtkMacro += getRepeatingAddInMacroPortion(v[attackPlusNm], v[tattackPlusNm], "@{toggle_attack_macro_insert}");
			newAtkMacro += " @{attack-type_macro_insert}";
			newAtkMacro += getRepeatingAddInMacroPortion(v[attackGlobalNm], v[tattackGlobalNm], "@{toggle_global_attack_macro_insert}");
			newDmgMacro += " @{damage-type_macro_insert}";
			newDmgMacro += getRepeatingAddInMacroPortion(v[damagePlusNm], v[tdamagePlusNm], "@{toggle_damage_macro_insert}");
			newDmgMacro += getRepeatingAddInMacroPortion(v[damageGlobalNm], v[tdamageGlobalNm], "@{toggle_global_damage_macro_insert}");
		}
		if (newAtkMacro !== v[attackMacroNm]) {
			setter[attackMacroNm] = newAtkMacro;
		}
		if (newDmgMacro !== v[damageMacroNm]) {
			setter[damageMacroNm] = newDmgMacro;
		}
		if (_underscore2.default.size(setter)) {
			setAttrs(setter);
		}
	});
}
function setAdvancedMacroCheckbox() {
	getAttrs(["adv_macro_show", "global_melee_macro_insert", "global_ranged_macro_insert", "global_cmb_macro_insert", "global_attack_macro_insert", "global_melee_damage_macro_insert", "global_ranged_damage_macro_insert", "global_cmb_damage_macro_insert", "global_damage_macro_insert"], function (v) {
		var showAdv = parseInt(v.adv_macro_show, 10) || 0,
		    hasAnyMacros = _underscore2.default.reduce(v, function (tot, value, fieldname) {
			if (fieldname !== "adv_macro_show" && !(value === "" || value === "0" || value === undefined || value === null)) {
				tot += 1;
			}
			return tot;
		}, 0);
		//TAS.debug("setAdvancedMacroCheckbox, checked:" + showAdv + " , has macros:" + hasAnyMacros);
		if (hasAnyMacros && !showAdv) {
			setAttrs({
				adv_macro_show: 1
			}, _PFConst2.default.silentParams);
		}
	});
}

/********* REPEATING WEAPON FIELDSET *********/
function setRepeatingWeaponInsertMacro(id, eventInfo) {
	var done = function done() {},
	    //updateRepeatingAddInMacro(id,eventInfo);},
	idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = "repeating_weapon_" + idStr,
	    attkTypeField = prefix + "attack-type";
	getAttrs([attkTypeField], function (v) {
		var attkType = PFUtils.findAbilityInString(v[attkTypeField]),
		    setter = {};
		if (attkType) {
			attkType = attkType.replace('attk-', '');
			setter[prefix + "attack-type_macro_insert"] = PFAttackGrid.attackGridFields[attkType].attackmacro;
			setter[prefix + "damage-type_macro_insert"] = PFAttackGrid.attackGridFields[attkType].damagemacro;
		} else {
			setter[prefix + "attack-type_macro_insert"] = "0";
		}
		//TAS.debug("setRepeatingWeaponInsertMacro",setter);
		setAttrs(setter, _PFConst2.default.silentParams, done);
	});
}
/** updateRepeatingWeaponAttack - calculates total-attack
 * also updates attk-effect-total-copy
 * @param {string} id optional = id of row, if blank we are within the context of the row
 * @param {string} overrideAttr optional = if we are passing in a value this is the fieldname after "repeating_weapon_"
 * @param {number} overrideValue optional = if overrideAttr then this should be a number usually int but it won't check
 */
function updateRepeatingWeaponAttack(id, eventInfo) {
	//is it faster to not do the idstr each time? try it with ?:
	var resetOptionsWhenDone = function resetOptionsWhenDone() {
		PFAttackOptions.resetOption(id, eventInfo);
	},
	    idStr = SWUtils.getRepeatingIDStr(id),
	    enhanceField = "repeating_weapon_" + idStr + "enhance",
	    mwkField = "repeating_weapon_" + idStr + "masterwork",
	    attkTypeModField = "repeating_weapon_" + idStr + "attack-type-mod",
	    profField = "repeating_weapon_" + idStr + "proficiency",
	    attkMacroModField = "repeating_weapon_" + idStr + "attack-mod",
	    totalAttackField = "repeating_weapon_" + idStr + "total-attack";
	getAttrs([enhanceField, mwkField, attkTypeModField, profField, attkMacroModField, totalAttackField], function (v) {
		var enhance = parseInt(v[enhanceField], 10) || 0,
		    masterwork = parseInt(v[mwkField], 10) || 0,
		    attkTypeMod = parseInt(v[attkTypeModField], 10) || 0,
		    prof = parseInt(v[profField], 10) || 0,
		    attkMacroMod = parseInt(v[attkMacroModField], 10) || 0,
		    currTotalAttack = parseInt(v[totalAttackField], 10) || 0,
		    newTotalAttack = 0,
		    setter = {};
		newTotalAttack = Math.max(enhance, masterwork) + attkTypeMod + prof + attkMacroMod;
		if (newTotalAttack !== currTotalAttack || isNaN(currTotalAttack)) {
			setter[totalAttackField] = newTotalAttack;
			setAttrs(setter, _PFConst2.default.silentParams, resetOptionsWhenDone);
		}
	});
}
/* updateRepeatingWeaponDamage - updates total-damage*/
function updateRepeatingWeaponDamage(id, eventInfo) {
	var resetOptionsWhenDone = function resetOptionsWhenDone() {
		PFAttackOptions.resetOption(id, eventInfo);
	},
	    rangedUpdate = false,
	    idStr = SWUtils.getRepeatingIDStr(id),
	    maxname = "repeating_weapon_" + idStr + "damage-ability-max",
	    modname = "repeating_weapon_" + idStr + "damage-ability-mod",
	    totalDamageField = "repeating_weapon_" + idStr + "total-damage",
	    enhanceField = "repeating_weapon_" + idStr + "enhance",
	    miscDmgField = "repeating_weapon_" + idStr + "damage-mod",
	    abilityMultField = "repeating_weapon_" + idStr + "damage_ability_mult",
	    rangedField = "repeating_weapon_" + idStr + "isranged";
	//TAS.debug("at PFAttacks.updateRepeatingWeaponDamage evnetinfo: ",eventInfo);
	if (eventInfo && eventInfo.sourceAttribute.toLowerCase() === 'buff_dmg_ranged-total') {
		rangedUpdate = true;
	}
	getAttrs([maxname, modname, "buff_DMG-total", "buff_DMG_Ranged-total", "condition-Sickened", rangedField, totalDamageField, enhanceField, miscDmgField, abilityMultField], function (v) {
		var maxA,
		    ability,
		    abilityMult,
		    abilityTot,
		    damageBuffs,
		    currTotalDmg,
		    dmgConditions,
		    miscDmg,
		    enhance,
		    totalDamage,
		    rangedAttack,
		    setter = {};
		rangedAttack = parseInt(v[rangedField], 10) || 0;
		if (!rangedUpdate || rangedAttack) {
			ability = parseInt(v[modname], 10) || 0;
			abilityMult = 1;
			dmgConditions = parseInt(v["condition-Sickened"], 10) || 0;
			currTotalDmg = parseInt(v[totalDamageField], 10);
			miscDmg = parseInt(v[miscDmgField], 10) || 0;
			enhance = parseInt(v[enhanceField], 10) || 0;
			_exportsLoaderTASTheAaronSheet2.default.debug('PFAttacks update damage values are :', v);
			if (rangedAttack) {
				damageBuffs = parseInt(v["buff_DMG_Ranged-total"], 10) || 0;
			} else {
				damageBuffs = parseInt(v["buff_DMG-total"], 10) || 0;
			}

			if (v[abilityMultField]) {
				abilityMult = Number(v[abilityMultField].replace(',', '.'));
				if (!abilityMult) {
					abilityMult = 1;
				}
			}

			damageBuffs -= dmgConditions;
			maxA = parseInt(v[maxname], 10);
			if (!rangedAttack || isNaN(maxA)) {
				maxA = 990;
			}
			abilityTot = Math.floor(Math.min(abilityMult * ability, maxA));
			totalDamage = abilityTot + damageBuffs + miscDmg + enhance;
			if (totalDamage !== currTotalDmg || isNaN(currTotalDmg)) {
				//TAS.debug("setting damage to "+totalDamage);
				setter[totalDamageField] = totalDamage;
			}
			if (_underscore2.default.size(setter)) {
				setAttrs(setter, _PFConst2.default.silentParams, resetOptionsWhenDone);
			}
		}
	});
}
function updateRepeatingWeaponCrit(id, eventInfo) {
	var idStr = SWUtils.getRepeatingIDStr(id),
	    critConfirmTotalField = "repeating_weapon_" + idStr + "crit_conf_mod",
	    critConfirmField = "repeating_weapon_" + idStr + "crit_confirm",
	    attkTypeField = "repeating_weapon_" + idStr + "attack-type",
	    attrs = ["attk_ranged_crit_conf", "attk_ranged2_crit_conf", "attk_melee_crit_conf", "attk_melee2_crit_conf", "attk_cmb_crit_conf", "attk_cmb2_crit_conf", critConfirmTotalField, critConfirmField, attkTypeField];
	getAttrs(attrs, function (v) {
		try {
			var currCritBonus = parseInt(v[critConfirmTotalField], 10) || 0,
			    critConfirmBonus = parseInt(v[critConfirmField], 10) || 0,
			    attkType = PFUtils.findAbilityInString(v[attkTypeField]),
			    attkTypeForGrid = !attkType ? "" : attkType.replace('attk-', ''),
			    attackTypeBonusField = !attkTypeForGrid ? "" : PFAttackGrid.attackGridFields[attkTypeForGrid].crit,
			    attackTypeBonus = !attackTypeBonusField ? 0 : parseInt(v[attackTypeBonusField], 10) || 0,
			    newBonus = critConfirmBonus + attackTypeBonus,
			    setter = {};
			if (newBonus !== currCritBonus) {
				setter[critConfirmTotalField] = newBonus;
				setAttrs(setter, {
					silent: true
				});
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("updateRepeatingWeaponCrit:cannot find " + v[attkTypeField] + " in grid");
		}
	});
}
function updateRepeatingWeaponsFromCrit(attacktype, eventInfo) {
	var globalCritBonusField = PFAttackGrid.attackGridFields[attacktype].crit;
	getSectionIDs("repeating_weapon", function (ids) {
		var attrs = [globalCritBonusField];
		_underscore2.default.each(ids, function (id) {
			var idStr = SWUtils.getRepeatingIDStr(id);
			attrs.push("repeating_weapon_" + idStr + "crit_conf_mod");
			attrs.push("repeating_weapon_" + idStr + "crit_confirm");
			attrs.push("repeating_weapon_" + idStr + "attack-type");
		});
		//TAS.debug("about to get ",attrs);
		getAttrs(attrs, function (v) {
			var globalCritBonus = parseInt(v[globalCritBonusField], 10) || 0,
			    setter = {};
			_underscore2.default.each(ids, function (id) {
				var idStr = SWUtils.getRepeatingIDStr(id),
				    attackTypeField = "repeating_weapon_" + idStr + "attack-type",
				    rowCritTotField = "",
				    rowCrit = 0,
				    rowTot = 0,
				    currRowTot = 0;
				//TAS.debug("row:"+id+" attacktypefield:"+v[attackTypeField]+", ability:"+ PFUtils.findAbilityInString(v[attackTypeField]) +", type is:"+attacktype);
				if (PFUtils.findAbilityInString(v[attackTypeField]) === "attk-" + attacktype) {
					//TAS.debug("this row equal");
					rowCritTotField = "repeating_weapon_" + idStr + "crit_conf_mod";
					currRowTot = parseInt(v[rowCritTotField], 10) || 0;
					rowTot = globalCritBonus + (parseInt(v["repeating_weapon_" + idStr + "crit_confirm"], 10) || 0);
					//TAS.debug("global:"+globalCritBonus+", this row:"+currRowTot+", plus "+v["repeating_weapon_" + idStr + "crit_confirm"] );
					if (rowTot !== currRowTot) {
						setter[rowCritTotField] = rowTot;
					}
				}
			});
			if (_underscore2.default.size(setter) > 0) {
				setAttrs(setter, {
					silent: true
				});
			}
		});
	});
}
/** sets 'isranged' checkbox to 1 if attack-type is ranged or ranged2
 * @param {string} id the row id or null for current row
 */
function setRepeatingWeaponRangedFlag(id) {
	var idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = "repeating_weapon_" + idStr,
	    attypeAttr = prefix + "attack-type",
	    isRangedAttr = prefix + "isranged";
	getAttrs([attypeAttr, isRangedAttr], function (v) {
		var setter = {},
		    newIsRanged = 0,
		    attackType = "";
		attackType = PFUtils.findAbilityInString(v[attypeAttr]);
		if (/ranged/i.test(attackType)) {
			newIsRanged = 1;
		}
		if ((parseInt(v[isRangedAttr], 10) || 0) !== newIsRanged) {
			setter[isRangedAttr] = newIsRanged;
			setAttrs(setter, _PFConst2.default.silentParams);
		}
	});
}

function getRecalculatedDamageOnly(id, v) {
	var prefix = 'repeating_weapon_' + SWUtils.getRepeatingIDStr(id),
	    isRanged = parseInt(v[prefix + 'isranged'], 10) || 0,
	    enhance = parseInt(v[prefix + "enhance"], 10) || 0,
	    abilitydmg = parseInt(v[prefix + "damage-ability-mod"], 10) || 0,
	    abilityMult = 1,
	    currTotalDmg = parseInt(v[prefix + "total-damage"], 10),
	    dmgMacroMod = parseInt(v[prefix + "damage-mod"], 10) || 0,
	    maxAbility = parseInt(v[prefix + "damage-ability-max"], 10),
	    dmgConditions = v["condition-Sickened"],
	    meleeBuffs = v["buff_DMG-total"],
	    rangedBuff = v["buff_DMG_Ranged-total"],
	    damageBuffs = 0,
	    abilityTotDmg = 0,
	    newTotalDamage = 0,
	    localsetter = {};
	try {
		if (isRanged) {
			damageBuffs = rangedBuff;
		} else {
			damageBuffs = meleeBuffs;
		}
		if (!isRanged || isNaN(maxAbility)) {
			maxAbility = 999;
		}

		damageBuffs -= dmgConditions;
		if (v[prefix + "damage_ability_mult"]) {
			abilityMult = Number(v[prefix + "damage_ability_mult"].replace(',', '.'));
			if (!abilityMult) {
				abilityMult = 1;
			}
		}

		abilityTotDmg = Math.floor(Math.min(abilityMult * abilitydmg, maxAbility));
		newTotalDamage = abilityTotDmg + damageBuffs + dmgMacroMod + enhance;
		if (newTotalDamage !== currTotalDmg || isNaN(currTotalDmg)) {
			localsetter[prefix + "total-damage"] = newTotalDamage;
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFAttacks.recalculateAttack for id " + id, err);
	} finally {
		return localsetter;
	}
}
/* updateRepeatingWeaponDamages - updates all attacks when buff to damage changes */
function updateRepeatingWeaponDamages(callback, silently, eventInfo) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getSectionIDs('repeating_weapon', function (ids) {
		var fields;
		fields = SWUtils.cartesianAppend(['repeating_weapon_'], ids, damageRowAttrsLU);
		fields.push("buff_DMG-total");
		fields.push("buff_DMG_Ranged-total");
		fields.push("condition-Sickened");
		getAttrs(fields, function (v) {
			var setter;
			//replace with int versions
			v["buff_DMG-total"] = parseInt(v["buff_DMG-total"], 10) || 0;
			v["buff_DMG_Ranged-total"] = parseInt(v["buff_DMG_Ranged-total"], 10) || 0;
			v["condition-Sickened"] = parseInt(v["condition-Sickened"], 10) || 0;
			setter = _underscore2.default.reduce(ids, function (m, id) {
				var xtra = getRecalculatedDamageOnly(id, v);
				_underscore2.default.extend(m, xtra);
				return m;
			}, {});
			if (_underscore2.default.size(setter)) {
				setAttrs(setter, {}, done);
			} else {
				done();
			}
		});
	});
}

/* this is faster than looping through the 3 parent lists */
function updateAssociatedAttacksFromParents(callback) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getSectionIDs('repeating_weapon', function (ids) {
		var doneOne = _underscore2.default.after(_underscore2.default.size(ids), function () {
			done();
		}),
		    attrs = _underscore2.default.map(ids, function (id) {
			return ['repeating_weapon_' + id + '_source-item', 'repeating_weapon_' + id + '_source-spell', 'repeating_weapon_' + id + '_source-ability'];
		});
		attrs = _underscore2.default.flatten(attrs);
		getAttrs(attrs, function (v) {
			_underscore2.default.each(ids, function (id) {
				doneOne();
				if (v['repeating_weapon_' + id + '_source-spell']) {
					PFInventory.createAttackEntryFromRow('repeating_item_' + v['repeating_weapon_' + id + '_source-item'] + '_create-attack-entry', doneOne, true, id);
				} else if (v['repeating_weapon_' + id + '_source-item']) {
					PFSpells.createAttackEntryFromRow('repeating_spells_' + v['repeating_weapon_' + id + '_source-spell'] + '_create-attack-entry', doneOne, true, id);
				} else if (v['repeating_weapon_' + id + '_source-item']) {
					PFAbility.createAttackEntryFromRow('repeating_ability_' + v['repeating_weapon_' + id + '_source-ability'] + '_create-attack-entry', doneOne, true, id);
				} else {
					doneOne();
				}
			});
		});
	});
}

function getRecalculatedAttack(id, v, setter) {
	var prefix = 'repeating_weapon_' + id + '_',
	    isRanged = parseInt(v[prefix + "isranged"], 10) || 0,
	    enhance = parseInt(v[prefix + "enhance"], 10) || 0,
	    masterwork = parseInt(v[prefix + "masterwork"], 10) || 0,
	    attkTypeMod = parseInt(v[prefix + "attack-type-mod"], 10) || 0,
	    prof = parseInt(v[prefix + "proficiency"], 10) || 0,
	    attkMacroMod = parseInt(v[prefix + "attack-mod"], 10) || 0,
	    currTotalAttack = parseInt(v[prefix + "total-attack"], 10),
	    abilitydmg = parseInt(v[prefix + "damage-ability-mod"], 10) || 0,
	    abilityMult = 1,
	    currTotalDmg = parseInt(v[prefix + "total-damage"], 10),
	    dmgMacroMod = parseInt(v[prefix + "damage-mod"], 10) || 0,
	    maxAbility = parseInt(v[prefix + "damage-ability-max"], 10),
	    currCritBonus = parseInt(v[prefix + "crit_conf_mod"], 10) || 0,
	    critConfirmBonus = parseInt(v[prefix + "crit_confirm"], 10) || 0,
	    attkType = PFUtils.findAbilityInString(v[prefix + "attack-type"]),
	    damageBuffs = 0,
	    attkTypeForGrid = '',
	    attackTypeCritBonusField = '',
	    attackTypeCritBonus = 0,
	    newCritBonus = 0,
	    abilityTotDmg = 0,
	    newTotalDamage = 0,
	    newTotalAttack = 0,
	    localsetter;
	try {
		if (v[prefix + "damage_ability_mult"]) {
			abilityMult = Number(v[prefix + "damage_ability_mult"].replace(',', '.'));
			if (!abilityMult) {
				abilityMult = 1;
			}
		}

		if (isRanged) {
			damageBuffs = parseInt(v['buff_DMG_ranged-total'], 10) || 0;
		} else {
			damageBuffs = parseInt(v['buff_DMG-total'], 10) || 0;
		}
		damageBuffs -= parseInt(v['condition-Sickened'], 10) || 0;
		localsetter = setter || {};
		newTotalAttack = Math.max(enhance, masterwork) + attkTypeMod + prof + attkMacroMod;
		if (newTotalAttack !== currTotalAttack || isNaN(currTotalAttack)) {
			localsetter[prefix + "total-attack"] = newTotalAttack;
		}
		if (!isRanged || isNaN(maxAbility)) {
			maxAbility = 999;
		}
		abilityTotDmg = Math.floor(Math.min(abilityMult * abilitydmg, maxAbility));
		newTotalDamage = abilityTotDmg + damageBuffs + dmgMacroMod + enhance;
		if (newTotalDamage !== currTotalDmg || isNaN(currTotalDmg)) {
			localsetter[prefix + "total-damage"] = newTotalDamage;
		}
		if (attkType) {
			if (/range/i.test(attkType)) {
				if (!isRanged) {
					localsetter[prefix + "isranged"] = 1;
				}
			} else if (isRanged) {
				localsetter[prefix + "isranged"] = 0;
			}
			attkTypeForGrid = attkType.replace('attk-', '');
			//TAS.debug("at update attack attkTypeForGrid="+attkTypeForGrid+", comparing to:",PFAttackGrid.attackGridFields);
			if (attkTypeForGrid) {
				attackTypeCritBonusField = PFAttackGrid.attackGridFields[attkTypeForGrid].crit;
				attackTypeCritBonus = !attackTypeCritBonusField ? 0 : v[attackTypeCritBonusField];
				if (v[prefix + "attack-type_macro_insert"] !== PFAttackGrid.attackGridFields[attkTypeForGrid].attackmacro) {
					localsetter[prefix + "attack-type_macro_insert"] = PFAttackGrid.attackGridFields[attkTypeForGrid].attackmacro;
				}
				if (v[prefix + "damage-type_macro_insert"] !== PFAttackGrid.attackGridFields[attkTypeForGrid].damagemacro) {
					localsetter[prefix + "damage-type_macro_insert"] = PFAttackGrid.attackGridFields[attkTypeForGrid].damagemacro;
				}
			}
		}
		newCritBonus = critConfirmBonus + attackTypeCritBonus;
		if (newCritBonus !== currCritBonus) {
			localsetter[prefix + "crit_conf_mod"] = newCritBonus;
		}
		if (!attkTypeForGrid) {
			if (v[prefix + "attack-type_macro_insert"] !== "0") {
				localsetter[prefix + "attack-type_macro_insert"] = "0";
			}
			if (v[prefix + "damage-type_macro_insert"] !== "0") {
				localsetter[prefix + "damage-type_macro_insert"] = "0";
			}
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFAttacks.getRecalculatedAttack for id " + id, err);
	} finally {
		return localsetter;
	}
}
/**ONLY CALL IF modify_dmg_by_size = 0
 * 
 * @param {*} id 
 * @param {*} v 
 * @param {*} setter 
 */
function syncDefaultDamageDice(id, v, setter, useSizeMod, prefix) {
	if (!prefix) {
		prefix = 'repeating_weapon_' + SWUtils.getRepeatingIDStr(id);
	}
	if (!useSizeMod || !parseInt(v[prefix + 'size_affects'], 10)) {
		setter[prefix + 'default_damage-dice-num'] = v[prefix + 'damage-dice-num'];
		setter[prefix + 'default_damage-die'] = v[prefix + 'damage-die'];
	}
	return setter;
}
/**   Called when updating damage dice  on a row
 * 
 * @param {string} id 
 */
function syncDefaultDamageDiceAsync(id, eventInfo) {
	var idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = 'repeating_weapon_' + idStr;
	getAttrs(['modify_dmg_by_size', prefix + 'size_affects', prefix + 'damage-dice-num', prefix + 'damage-die'], function (v) {
		var setter = {},
		    useSizeMod = 0;
		useSizeMod = parseInt(v.modify_dmg_by_size, 10) || 0;
		syncDefaultDamageDice(id, v, setter, useSizeMod, prefix);
		if (_underscore2.default.size(setter)) {
			setAttrs(setter, _PFConst2.default.silentParams);
		}
	});
}
function syncAllDefaultDamageDiceAsync() {
	getAttrs(['modify_dmg_by_size'], function (vout) {
		var modifyDMG = parseInt(vout.modify_dmg_by_size, 10) || 0;
		getSectionIDs('repeating_weapons', function (ids) {
			var setter = {},
			    fields;
			if (_underscore2.default.size(ids)) {
				fields = SWUtils.cartesianAppend(['repeating_weapon_', ids, ['_damage-dice-num', '_damage-die', '_size_affects']]);
				getAttrs(fields, function (v) {
					_underscore2.default.each(ids, function (id) {
						syncDefaultDamageDice(id, v, setter, modifyDMG);
					});
					if (_underscore2.default.size(setter)) {
						setAttrs(setter, _PFConst2.default.silentParams);
					}
				});
			}
		});
	});
}
/** ONLY CALL IF modify_dmg_by_size = 1.
 * 
 * @param {string} id 
 * @param {number} currCharSize 
 * @param {Map<string,string>} v 
 * @param {Map<string,string>} setter 
 * @param {object} eventInfo 
 * @returns {Map<string,string>} setter
 */
function adjustDamageDice(id, currCharSize, v, setter, prefix) {
	var currDice = 0,
	    defDice = 0,
	    weaponSizeDiff = 0,
	    currDie = 0,
	    defDie = 0,
	    defWeaponSize = 0,
	    currNotDefault = 0,
	    defSize = 0,
	    sizeDiff = 0,
	    newDice = {};
	try {
		if (!prefix) {
			prefix = 'repeating_weapon_' + SWUtils.getRepeatingIDStr(id);
		}
		//TAS.debug("#########","PFAttacks.adjustDamageDice for "+prefix,v);
		currNotDefault = parseInt(v[prefix + 'not_default_size'], 10) || 0;
		if (parseInt(v[prefix + 'size_affects'], 10)) {
			currDice = parseInt(v[prefix + 'damage-dice-num'], 10) || 0;
			currDie = parseInt(v[prefix + 'damage-die'], 10) || 0;
			//TAS.debug("PFAttacks.adjustDamageDice curr size:"+ currCharSize+" and current dmg: "+currDice+"d"+currDie);
			if (!(currDice === 0 || currDie === 0)) {
				defSize = parseInt(v['default_char_size'], 10);
				defWeaponSize = parseInt(v[prefix + 'default_size'], 10);
				defDice = parseInt(v[prefix + 'default_damage-dice-num'], 10) || 0;
				defDie = parseInt(v[prefix + 'default_damage-die'], 10) || 0;
				//TAS.debug("PFAttacks.adjustDamageDice default is:"+defDice+"d"+defDie+", for size:"+defWeaponSize+", "+"def char size:"+defSize+", and curr char size:"+ currCharSize);

				//check for errors 
				if (isNaN(defWeaponSize)) {
					defWeaponSize = defSize;
					setter[prefix + 'default_size'] = defWeaponSize;
				}
				if (isNaN(defSize)) {
					defSize = currCharSize;
				}
				if (defDice === 0 || defDie === 0) {
					defDice = currDice;
					defDie = currDie;
					setter[prefix + 'default_damage-dice-num'] = defDice;
					setter[prefix + 'default_damage-die'] = defDie;
				}
				//check for change
				if (currCharSize !== defSize) {
					if (!currNotDefault) {
						setter[prefix + 'not_default_size'] = 1;
					}
					sizeDiff = PFSize.getSizeLevelChange(currCharSize, defSize);
					//TAS.debug("PFAttacks update dice, char size change is "+sizeDiff);
				}
				if (defWeaponSize !== defSize) {
					if (!currNotDefault) {
						setter[prefix + 'not_default_size'] = 1;
					}
					weaponSizeDiff = PFSize.getSizeLevelChange(defWeaponSize, defSize);
					//TAS.debug("PFAttacks update dice, weapon size change is "+weaponSizeDiff);
				}
				sizeDiff += weaponSizeDiff;
				//TAS.debug("PFAttacks update dice, total size change is  "+sizeDiff);
				if (sizeDiff) {
					newDice = PFSize.updateDamageDice(sizeDiff, defSize, defDice, defDie);
					//TAS.debug("###########","PFAttacks.adjustDamageDice NEW DAMAGE is:"+newDice.dice+"d"+newDice.die+", for sizeDiff:"+sizeDiff);
					if (currDice !== newDice.dice || currDie !== newDice.die) {
						setter[prefix + 'damage-dice-num'] = newDice.dice;
						setter[prefix + 'damage-die'] = newDice.die;
					}
				} else {
					if (currNotDefault) {
						setter[prefix + 'not_default_size'] = 0;
					}
					if (currDice !== defDice || currDie !== defDie) {
						setter[prefix + 'damage-dice-num'] = defDice;
						setter[prefix + 'damage-die'] = defDie;
					}
				}
			} else {
				//size affects was 1, but no damage dice
				setter[prefix + 'size_affects'] = 0;
			}
		} else {
			//TAS.debug("PFAttacks.adjustDamageDice: size_affects is blank so reset regular to default")
			if (!(currDice === 0 || currDie === 0)) {
				setter[prefix + 'damage-dice-num'] = v[prefix + 'default_damage-dice-num'];
				setter[prefix + 'damage-die'] = v[prefix + 'default_damage-die'];
				if (currNotDefault) {
					setter[prefix + 'not_default_size'] = 0;
				}
			}
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFAttacks.adjustDamageDice", err);
	} finally {
		return setter;
	}
}
/** Only called when updating the size dropdown, default damage dice, or size affects checkbox on a row.
 * 
 * @param {string} id 
 * @param {function} callback 
 */
function adjustDamageDiceAsync(id, callback) {
	var idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = 'repeating_weapon_' + idStr;
	getAttrs(['modify_dmg_by_size', 'size', 'default_char_size', prefix + 'default_size', prefix + 'size_affects', prefix + 'default_damage-dice-num', prefix + 'default_damage-die', prefix + 'not_default_size', prefix + 'damage-dice-num', prefix + 'damage-die'], function (v) {
		var setter = {},
		    currCharSize = 0;
		try {
			//TAS.debug("at PFAttacks.adjustDamageDiceAsync for id "+id+", got ",v);
			if (parseInt(v['modify_dmg_by_size'], 10)) {
				currCharSize = parseInt(v.size, 10) || 0;
				adjustDamageDice(id, currCharSize, v, setter, prefix);
			}
		} finally {
			if (_underscore2.default.size(setter)) {
				setAttrs(setter);
			}
		}
	});
}

function adjustAllDamageDiceAsync(callback, eventInfo) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	//TAS.debug("at PFAttacks.adjustAllDamageDiceAsync");
	getAttrs(['modify_dmg_by_size', 'size', 'default_char_size'], function (vout) {
		var currCharSize = 0;
		if (parseInt(vout['modify_dmg_by_size'], 10)) {
			currCharSize = parseInt(vout.size, 10) || 0;
			getSectionIDs('repeating_weapon', function (ids) {
				var fields;
				if (_underscore2.default.size(ids)) {
					fields = SWUtils.cartesianAppend(['repeating_weapon_'], ids, sizeFieldsLU);
					getAttrs(fields, function (v) {
						var setter = {};
						v.default_char_size = parseInt(vout.default_char_size, 10) || 0;
						_underscore2.default.each(ids, function (id) {
							var idStr = SWUtils.getRepeatingIDStr(id),
							    prefix = 'repeating_weapon_' + idStr;
							adjustDamageDice(id, currCharSize, v, setter);
						});
						if (_underscore2.default.size(setter)) {
							setAttrs(setter, _PFConst2.default.silentParams, done);
						}
					});
				}
			});
		}
	});
}
function resetWeaponSizeAndDamage(id, currCharSize, v, setter, useSizeMod) {
	var idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = 'repeating_weapon_' + idStr;
	if (useSizeMod) {
		adjustDamageDice(id, currCharSize, v, setter, prefix);
	} else {
		syncDefaultDamageDice(id, v, setter, useSizeMod, prefix);
	}
	return setter;
}
/**
 * @param {[string]} ids 
 * @param {function} callback 
 */
function recalcOtherFields(ids, callback) {
	var done = function done() {
		if (typeof callback === "function") {
			callback();
		}
	},
	    doneWithAllRows,
	    fields;
	if (!ids || _underscore2.default.size(ids) === 0) {
		done();
		return;
	}
	doneWithAllRows = _underscore2.default.after(_underscore2.default.size(ids), done);
	fields = SWUtils.cartesianAppend(['repeating_weapon_'], ids, updateRowAttrsLU);
	fields = fields.concat(SWUtils.cartesianAppend(['repeating_weapon_'], ids, sizeFieldsLU));
	fields = fields.concat(updateCharAttrs);
	getAttrs(fields, function (v) {
		var charAttMap = {},
		    setter;
		//set global values to int so we don't have to do it over and over per row.
		charAttMap = _underscore2.default.object(_underscore2.default.map(updateCharAttrs, function (attr) {
			return [attr, parseInt(v[attr], 10) || 0];
		}));
		_underscore2.default.extend(v, charAttMap);
		v["buff_DMG-total"] = parseInt(v["buff_DMG-total"], 10) || 0;
		v["buff_DMG_Ranged-total"] = parseInt(v["buff_DMG_Ranged-total"], 10) || 0;
		v["condition-Sickened"] = parseInt(v["condition-Sickened"], 10) || 0;
		//TAS.debug("PFAttacks.recalcOtherFields has values ",v);
		setter = _underscore2.default.reduce(ids, function (m, id) {
			var xtra = {};
			try {
				if (v['repeating_weapon_' + id + '_attack-type'] !== 'dual') {
					xtra = getRecalculatedAttack(id, v);
					resetWeaponSizeAndDamage(id, v.size, v, xtra, v.modify_dmg_by_size);
					_underscore2.default.extend(m, xtra);
				}
			} catch (erri) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFAttacks.recalcOtherFields erri", erri);
			} finally {
				return m;
			}
		}, {});
		if (_underscore2.default.size(setter)) {
			setAttrs(setter, {}, done);
		} else {
			done();
		}
	});
}
function recalcEquationFields(ids, callback) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	}),
	    doneWithCalculatedFields = _underscore2.default.after(_underscore2.default.size(ids), done),
	    fields;
	fields = _underscore2.default.chain(ids).map(function (id) {
		var prefix = "repeating_weapon_" + id + "_";
		return [prefix + "damage", prefix + "attack", prefix + "damage-mod", prefix + "attack-mod"];
	}).flatten().value();
	getAttrs(fields, function (v) {
		try {
			_underscore2.default.each(ids, function (id) {
				var doneWithField = _underscore2.default.after(4, doneWithCalculatedFields),
				    prefix = "repeating_weapon_" + id + "_";
				if ((!v[prefix + "damage"] || v[prefix + "damage"] === "0" || v[prefix + "damage"] === "+0") && parseInt(v[prefix + "damage-mod"], 10) === 0) {
					doneWithField();
				} else {
					SWUtils.evaluateAndSetNumber(prefix + "damage", prefix + "damage-mod", 0, doneWithField, true);
				}
				if ((!v[prefix + "attack"] || v[prefix + "attack"] === "0" || v[prefix + "attack"] === "+0") && parseInt(v[prefix + "attack-mod"], 10) === 0) {
					doneWithField();
				} else {
					SWUtils.evaluateAndSetNumber(prefix + "attack", prefix + "attack-mod", 0, doneWithField, true);
				}
				SWUtils.setDropdownValue(prefix + "attack-type", prefix + "attack-type-mod", PFUtils.findAbilityInString, doneWithField, true);
				SWUtils.setDropdownValue(prefix + "damage-ability", prefix + "damage-ability-mod", PFUtils.findAbilityInString, doneWithField, true);
			});
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("recalcEquationFields", err);
			done();
		}
	});
}
function recalculateRepeatingWeapons(callback) {
	var done = _underscore2.default.once(function () {
		//TAS.debug("leaving PFAttacks.recalculateRepeatingWeapons");
		if (typeof callback === "function") {
			callback();
		}
	});
	getSectionIDs("repeating_weapon", function (ids) {
		recalcEquationFields(ids, function () {
			recalcOtherFields(ids, done);
		});
	});
}
/** removes the given id link from any attacks.
 * @param {function} callback to call when done
 * @param {int} linkType value from PFAttacks.linkedAttackType
 * @param {string} linkid string of source id attack links to
 */
function removeLinkedAttack(callback, linkType, linkid) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === 'function') {
			callback();
		}
	}),
	    attrprefix = '',
	    attrprefix2 = '';
	switch (linkType) {
		case linkedAttackType.ability:
			attrprefix = 'source-ability';
			break;
		case linkedAttackType.equipment:
			attrprefix = 'source-item';
			break;
		case linkedAttackType.spell:
			attrprefix = 'source-spell';
			break;
		case linkedAttackType.weapon:
			attrprefix = 'source-main';
			attrprefix2 = 'source-off';
			break;
		default:
			done();
			return;
	}
	getSectionIDs('repeating_weapon', function (ids) {
		var fields, attrs;
		if (!ids || _underscore2.default.size(ids) === 0) {
			done();
			return;
		}
		attrs = ['_' + attrprefix, '_' + attrprefix + '-name'];
		if (attrprefix2) {
			attrs.push('_' + attrprefix2);
			attrs.push('_' + attrprefix2 + '-name');
			attrs.push('_name');
		}
		fields = SWUtils.cartesianAppend(['repeating_weapon'], ids, attrs);
		getAttrs(fields, function (v) {
			var setter = {};
			ids.forEach(function (id) {
				var prefix = 'repeating_weapon_' + id + '_';
				if (v[prefix + attrprefix] === linkid) {
					setter[prefix + 'link_type'] = 0;
					setter[prefix + attrprefix] = '';
					setter[prefix + attrprefix + '-name'] = '';
					if (attrprefix2) {
						setter[prefix + attrprefix2] = '';
						setter[prefix + attrprefix2 + '-name'] = '';
						setter[prefix + 'name'] = 'UNLINKED ' + v[prefix + 'name'];
					}
				}
			});
			if (_underscore2.default.size(setter)) {
				setAttrs(setter, _PFConst2.default.silentParams, done);
			} else {
				done();
			}
		});
	});
}
/** call when bab changes, or when name changes but how to know? must keep them in linked fields.
 * @param {{'mainhand_name':string,'mainhand_id':string,'mainhand_penalty':int,	'offhand_name':string,'offhand_id':string,'offhand_penalty':int,'offhand_improved':boolean,'bab':int, 'offhand_mult':number }  } params 
 * @param {Map<string,any>} setter already built setter if applicable.
 * @param {String} id the id of the row
 * @param {Boolean} updMode if true then do not update names of attacks
 * @returns {Map<string,any>} setter
 */

function setDualWieldVals(params, setter, id, updMode) {
	var fields,
	    numAttacks = 1,
	    currAttack = 1,
	    totAttacks = 2,
	    macroText = '',
	    macroIter = '{{attackREPLACEITER=[[ 1d20cs>[[ @{repeating_weapon_REPLACEHAND_crit-target} ]] + [[ @{repeating_weapon_REPLACEHAND_attack_macro} ]] + @{iterative_attackREPLACEITER_value} ]]}} {{damageREPLACEITER=[[ @{repeating_weapon_REPLACEHAND_damage-dice-num}d@{repeating_weapon_REPLACEHAND_damage-die} + @{repeating_weapon_REPLACEHAND_damage_macro} ]]}} {{crit_confirmREPLACEITER=[[ 1d20 + [[ @{repeating_weapon_REPLACEHAND_attack_macro}  ]] + @{iterative_attackREPLACEITER_value} + @{repeating_weapon_REPLACEHAND_crit_conf_mod} ]]}} {{crit_damageREPLACEITER=[[ [[ @{repeating_weapon_REPLACEHAND_damage-dice-num} * [[ @{repeating_weapon_REPLACEHAND_crit-multiplier} - 1 ]] ]]d@{repeating_weapon_REPLACEHAND_damage-die} + ((@{repeating_weapon_REPLACEHAND_damage_macro}) * [[ @{repeating_weapon_REPLACEHAND_crit-multiplier} - 1 ]]) ]]}} {{precision_dmgREPLACEITER1=@{repeating_weapon_REPLACEHAND_precision_dmg_macro}}} {{critical_dmgREPLACEITER1=@{repeating_weapon_REPLACEHAND_critical_dmg_macro}}} {{precision_dmgREPLACEITER2=@{global_precision_dmg_macro}}} {{critical_dmgREPLACEITER2=@{global_critical_dmg_macro}}} {{attackREPLACEITERname=@{iterative_attackREPLACEITER_name}}} ',
	    macroIterOffhand = '{{attackREPLACEITER=[[ 1d20cs>[[ @{repeating_weapon_REPLACEHAND_crit-target} ]] + [[ @{repeating_weapon_REPLACEHAND_attack_macro} ]] + @{iterative_attackREPLACEITER_value} ]]}} {{damageREPLACEITER=[[ @{repeating_weapon_REPLACEHAND_damage-dice-num}d@{repeating_weapon_REPLACEHAND_damage-die} + @{repeating_weapon_REPLACEHAND_damage_macro} REPLACEMULT ]]}} {{crit_confirmREPLACEITER=[[ 1d20 + [[ @{repeating_weapon_REPLACEHAND_attack_macro} ]] + @{iterative_attackREPLACEITER_value}  + @{repeating_weapon_REPLACEHAND_crit_conf_mod} ]]}} {{crit_damageREPLACEITER=[[ [[ @{repeating_weapon_REPLACEHAND_damage-dice-num} * [[ @{repeating_weapon_REPLACEHAND_crit-multiplier} - 1 ]] ]]d@{repeating_weapon_REPLACEHAND_damage-die} + ((@{repeating_weapon_REPLACEHAND_damage_macro} REPLACEMULT ) * [[ @{repeating_weapon_REPLACEHAND_crit-multiplier} - 1 ]]) ]]}} {{precision_dmgREPLACEITER1=@{repeating_weapon_REPLACEHAND_precision_dmg_macro}}} {{critical_dmgREPLACEITER1=@{repeating_weapon_REPLACEHAND_critical_dmg_macro}}} {{precision_dmgREPLACEITER2=@{global_precision_dmg_macro}}} {{critical_dmgREPLACEITER2=@{global_critical_dmg_macro}}} {{attackREPLACEITERname=@{iterative_attackREPLACEITER_name}}} ',
	    replaceMultStr = '- [[ ceil(@{repeating_weapon_REPLACEHAND_damage-ability}/2) ]] ',
	    tempInt = 0,
	    mainPen = 0,
	    offhandCountdown = 0,
	    offPen = 0,
	    prefix = '',
	    tempStr = '',
	    tempStr2 = '';

	try {
		//TAS.debug("PFAttacks.setDualWieldVals",params);
		setter = setter || {};
		if (!id) {
			id = generateRowID();
			//TAS.debug("the new id is "+id);
		}
		offhandCountdown = params.offhand_improved;
		prefix = 'repeating_weapon_' + id + '_';
		try {
			tempStr = getTranslationByKey('dual-wield');
		} catch (er2) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFAttacks.setDualWieldVals er2:", er2);
		}
		if (!tempStr) {
			tempStr = "Dual Wield";
		}
		setter[prefix + 'dualwield'] = 1;
		setter[prefix + 'source-main'] = params.mainhand_id;
		setter[prefix + 'source-off'] = params.offhand_id;
		//for update of existing just for this version:
		setter[prefix + 'group'] = tempStr;
		if (!updMode) {
			setter[prefix + 'group'] = tempStr;
			setter[prefix + 'source-main-name'] = params.mainhand_name || '';
			setter[prefix + 'source-off-name'] = params.offhand_name || '';
			setter[prefix + 'name'] = tempStr + ' ' + (params.mainhand_name || '') + '/' + (params.offhand_name || '');
			setter[prefix + 'iterative_attack1_name'] = params.mainhand_name + ' [[@{repeating_weapon_' + params.mainhand_id + '_total-attack} + ' + params.mainhand_penalty + ']]';
		}
		setter[prefix + 'link_type'] = linkedAttackType.weapon;
		setter[prefix + 'size_affects'] = 0;
		//by filling it in we make sure template rolls
		setter[prefix + 'attack-type'] = "dual";
		setter[prefix + 'attack-type-mod'] = 0;
		setter[prefix + 'damage-ability'] = "dual";
		setter[prefix + 'damage-ability-mod'] = 0;
		currAttack = 1;
		//macroText
		//mainhand attack:
		macroText = '@{PC-whisper} &{template:pf_attack} @{toggle_attack_accessible} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=@{name}}} ' + '{{attack=[[ 1d20cs>[[ @{repeating_weapon_' + params.mainhand_id + '_crit-target} ]] + [[@{repeating_weapon_' + params.mainhand_id + '_attack_macro} ]] + @{attack-mod} ]]}} ' + '{{damage=[[@{repeating_weapon_' + params.mainhand_id + '_damage-dice-num}d@{repeating_weapon_' + params.mainhand_id + '_damage-die} + @{repeating_weapon_' + params.mainhand_id + '_damage_macro} ]]}} ' + '{{crit_confirm=[[ 1d20 + [[ @{repeating_weapon_' + params.mainhand_id + '_attack_macro} ]] + @{attack-mod} ]]}} ' + '{{crit_damage=[[ [[ @{repeating_weapon_' + params.mainhand_id + '_damage-dice-num} * (@{repeating_weapon_' + params.mainhand_id + '_crit-multiplier} - 1) ]]d@{repeating_weapon_' + params.mainhand_id + '_damage-die} + ((@{repeating_weapon_' + params.mainhand_id + '_damage_macro} ) * [[ @{repeating_weapon_' + params.mainhand_id + '_crit-multiplier} - 1 ]]) ]]}} ' + '{{precision_dmg1=@{repeating_weapon_' + params.mainhand_id + '_precision_dmg_macro}}} {{precision_dmg1_type=@{repeating_weapon_' + params.mainhand_id + '_precision_dmg_type}}} ' + '{{critical_dmg1=@{repeating_weapon_' + params.mainhand_id + '_critical_dmg_macro}}} {{critical_dmg1_type=@{repeating_weapon_' + params.mainhand_id + '_critical_dmg_type}}} ' + '{{weapon_notes=@{repeating_weapon_' + params.mainhand_id + '_notes}@{repeating_weapon_' + params.offhand_id + '_notes}}} ' + '{{vs=@{repeating_weapon_' + params.mainhand_id + '_vs}}} {{vs@{repeating_weapon_' + params.mainhand_id + '_vs}=@{repeating_weapon_' + params.mainhand_id + '_vs}}} ' + '{{precision_dmg2=@{global_precision_dmg_macro}}} {{precision_dmg2_type=@{global_precision_dmg_type}}} {{critical_dmg2=@{global_critical_dmg_macro}}} {{critical_dmg2_type=@{global_critical_dmg_type}}} ' + '{{dual_precision_dmg=@{precision_dmg_macro}}} {{dual_precision_dmg_type=@{precision_dmg_type}}} ' + '@{iterative_attacks} @{macro_options} {{attack1name=@{iterative_attack1_name}}}';
		setter[prefix + 'macro-text'] = macroText;
		setter[prefix + 'NPC-macro-text'] = macroText;

		setter[prefix + 'attack'] = params.mainhand_penalty;
		setter[prefix + 'attack-mod'] = params.mainhand_penalty;
		setter[prefix + 'total-attack'] = params.mainhand_penalty;
		//rest of attacks
		numAttacks = Math.floor(params.bab / 5) + 1;
		totAttacks = numAttacks + params.offhand_improved;
		currAttack = 2;
		while (currAttack <= totAttacks) {
			tempStr = '';
			//if odd attack or no more offhand then mainhand
			if (offhandCountdown === 0 || currAttack % 2 === 1) {
				//mainhand
				mainPen -= 5;
				tempStr = macroIter.replace(/REPLACEHAND/g, params.mainhand_id);
				tempInt = mainPen + params.mainhand_penalty;
				setter[prefix + 'iterative_attack' + currAttack + '_name'] = params.mainhand_name + ' [[ @{repeating_weapon_' + params.mainhand_id + '_total-attack} - ' + Math.abs(mainPen) + ' - ' + Math.abs(params.mainhand_penalty) + ' ]]';
			} else {
				//offhand
				tempStr = macroIterOffhand.replace(/REPLACEHAND/g, params.offhand_id);
				if (params.offhand_mult === 0.5) {
					tempStr2 = replaceMultStr.replace(/REPLACEHAND/g, params.offhand_id);
					tempStr = tempStr.replace(/REPLACEMULT/g, tempStr2);
				} else {
					tempStr = tempStr.replace(/REPLACEMULT/g, '');
				}
				tempInt = offPen + params.offhand_penalty;
				setter[prefix + 'iterative_attack' + currAttack + '_name'] = params.offhand_name + ' [[@{repeating_weapon_' + params.offhand_id + '_total-attack} - ' + Math.abs(offPen) + ' - ' + Math.abs(params.offhand_penalty) + ']]';
				offPen -= 5;
				offhandCountdown--;
			}
			tempStr = tempStr.replace(/REPLACEITER/g, currAttack);

			setter[prefix + 'iterative_attack' + currAttack + '_value'] = tempInt;
			setter[prefix + 'var_iterative_attack' + currAttack + '_macro'] = tempStr;
			setter[prefix + 'toggle_iterative_attack' + currAttack] = "@{var_iterative_attack" + currAttack + "_macro}";
			currAttack++;
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFAttacks.setDualWieldVals outererr", err);
	} finally {
		//TAS.debug("PFAttacks.setDualWieldVals returning:",setter);
		return setter;
	}
}

function updateDualWield(callback, eventInfo) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === 'function') {
			callback();
		}
	}),
	    finished = _underscore2.default.once(function () {
		setAttrs({ 'update_twoweapon_attack': 0 }, _PFConst2.default.silentParams, done);
	});
	getAttrs(['update_twoweapon_attack', 'mainhand_penalty', 'offhand_penalty', 'offhand_improved', 'bab', 'offhand_str_mult'], function (vout) {
		if (!parseInt(vout.update_twoweapon_attack, 10)) {
			done();
			return;
		}
		getSectionIDs('repeating_weapon', function (ids) {
			var fields,
			    mhpen = 0,
			    ohpen = 0,
			    ohatks = 0,
			    babt = 0,
			    mult = 0;
			if (!ids || _underscore2.default.size(ids) === 0) {
				finished();
				return;
			}
			mhpen = parseInt(vout.mainhand_penalty, 10) || 0;
			ohpen = parseInt(vout.offhand_penalty, 10) || 0;
			ohatks = parseInt(vout.offhand_improved, 10) || 0;
			babt = parseInt(vout.bab, 10) || 0;
			mult = parseFloat(vout.offhand_str_mult) || 0.5;
			fields = SWUtils.cartesianAppend(['repeating_weapon_'], ids, ['_source-main', '_source-off', '_link_type', '_source-main-name', '_source-off-name']);
			//TAS.debug("PFAttacks.migrateLinkedAttacks FIELDS are ",fields);
			getAttrs(fields, function (v) {
				var setter = {};
				if (ids && _underscore2.default.size(ids)) {
					ids.forEach(function (id) {
						var prefix = 'repeating_weapon_' + id + '_',
						    linktype = parseInt(v[prefix + 'link_type'], 10),
						    params = {};
						if (linktype === linkedAttackType.weapon) {
							params.mainhand_id = v[prefix + 'source-main'];
							params.offhand_id = v[prefix + 'source-off'];
							params.mainhand_penalty = mhpen;
							params.offhand_penalty = ohpen;
							params.offhand_improved = ohatks;
							params.bab = babt;
							params.mainhand_name = v[prefix + 'source-main-name'];
							params.offhand_name = v[prefix + 'source-off-name'];
							params.offhand_mult = mult;
							//TAS.debug("PFAttacks.createDualWield calling setDualWieldVals with ",params);
							setDualWieldVals(params, setter, id, true);
						}
					});
				}
				if (_underscore2.default.size(setter)) {
					setter['update_twoweapon_attack'] = 0;
					//TAS.debug("after updating now set with ",setter);
					setAttrs(setter, _PFConst2.default.silentParams, done);
				} else {
					finished();
				}
			});
		});
	});
}

function createDualWield(callback) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(['create_twoweapon_attack', 'mainhand_id', 'mainhand_penalty', 'offhand_id', 'offhand_penalty', 'offhand_improved', 'bab', 'offhand_str_mult'], function (v) {
		var params = {},
		    id,
		    setter = {};
		if (parseInt(v.create_twoweapon_attack, 10) === 1) {
			getSectionIDs('repeating_weapon', function (ids) {
				//TAS.debug("at PFAttacks.createDualWield values are ",v,ids);
				if (_underscore2.default.contains(ids, v.mainhand_id) && _underscore2.default.contains(ids, v.offhand_id)) {
					//TAS.debug("they are there!");
					getAttrs(['repeating_weapon_' + v.mainhand_id + '_name', 'repeating_weapon_' + v.offhand_id + '_name'], function (w) {
						try {
							params.mainhand_id = v.mainhand_id;
							params.offhand_id = v.offhand_id;
							params.mainhand_penalty = parseInt(v.mainhand_penalty, 10) || 0;
							params.offhand_penalty = parseInt(v.offhand_penalty, 10) || 0;
							params.offhand_improved = parseInt(v.offhand_improved, 10) || 0;
							params.bab = parseInt(v.bab, 10) || 0;
							params.mainhand_name = w['repeating_weapon_' + v.mainhand_id + '_name'];
							params.offhand_name = w['repeating_weapon_' + v.offhand_id + '_name'];
							params.offhand_mult = parseFloat(v.offhand_str_mult) || 0.5;
							//TAS.debug("PFAttacks.createDualWield calling setDualWieldVals with ",params);
							setter = setDualWieldVals(params, setter);
						} catch (outererr) {
							_exportsLoaderTASTheAaronSheet2.default.error("PFAttacks.createDualWield outererr", outererr);
						} finally {
							if (_underscore2.default.size(setter)) {
								setter.create_twoweapon_attack = 0;
								setter.mainhand_id = '';
								setter.offhand_id = '';
								setAttrs(setter, _PFConst2.default.silentParams, function () {
									PFAttackGrid.resetCommandMacro();
									done();
								});
							} else {
								setter.create_twoweapon_attack = 0;
								setAttrs(setter, _PFConst2.default.silentParams, done);
							}
						}
					});
				} else {
					//TAS.debug("they are not there1");
					setter.create_twoweapon_attack = 0;
					setAttrs(setter, _PFConst2.default.silentParams, done);
				}
			});
		}
	});
}
function getNewDefaults(ids, v, setter) {
	var localsetter, defaultSize;
	try {
		setter = setter || {};
		defaultSize = parseInt(v['size'], 10) || 0;
		localsetter = _underscore2.default.reduce(ids, function (m, id) {
			var prefix = 'repeating_weapon_' + id + '_';
			try {
				m[prefix + 'default_size'] = defaultSize;
				if (v[prefix + 'damage-dice-num']) {
					m[prefix + 'default_damage-dice-num'] = v[prefix + 'damage-dice-num'];
				} else {
					m[prefix + 'default_damage-dice-num'] = 0;
					m[prefix + 'damage-dice-num'] = 0;
				}
				if (v[prefix + 'damage-die']) {
					m[prefix + 'default_damage-die'] = v[prefix + 'damage-die'];
				} else {
					m[prefix + 'default_damage-die'] = 0;
					m[prefix + 'damage-die'] = 0;
				}
			} catch (errin) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFAttacks.setNewDefaultsSync errin id " + id, errin);
			} finally {
				return m;
			}
		}, {});
		_underscore2.default.extend(setter, localsetter);
	} catch (errout) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFAttacks.getNewDefaults errout ", errout);
	} finally {
		return setter;
	}
}
function setNewDefaults(callback) {
	var done = _underscore2.default.once(function () {
		//TAS.debug("leaving PFAttacks.setNewDefaults");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    finishedMigrating = _underscore2.default.once(function () {
		setAttrs({ 'migrated_attacklist_defaults111': 1 }, _PFConst2.default.silentParams, done);
	});
	//TAS.debug("At PFAttacks.setNewDefaults");
	getAttrs(['migrated_attacklist_defaults111'], function (vsize) {
		if (parseInt(vsize['migrated_attacklist_defaults111'], 10)) {
			done();
			return;
		}
		getSectionIDs('repeating_weapon', function (ids) {
			var fields;
			if (!(ids || _underscore2.default.size(ids))) {
				finishedMigrating();
				return;
			}
			fields = SWUtils.cartesianAppend(['repeating_weapon_'], ids, ['_damage-dice-num', '_damage-die']);
			fields.push('size');
			getAttrs(fields, function (v) {
				var setter = {};
				try {
					setter = getNewDefaults(ids, v, setter);
				} catch (errout) {
					_exportsLoaderTASTheAaronSheet2.default.error("PFAttacks.setNewDefaults errout ", errout);
				} finally {
					if (_underscore2.default.size(setter)) {
						setAttrs(setter, _PFConst2.default.silentParams, finishedMigrating);
					} else {
						done();
					}
				}
			});
		});
	});
}
function migrateRepeatingMacro(callback) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	}),
	    migratedIteratives = function migratedIteratives() {
		setAttrs({ 'migrated_attack_macrosv1': 1 }, _PFConst2.default.silentParams, done);
	},
	    migrated = _underscore2.default.after(2, function () {
		PFMacros.migrateRepeatingMacrosMult(migratedIteratives, 'weapon', defaultIterativeAttrName, defaultIterativeRepeatingMacro, defaultIterativeRepeatingMacroMap, defaultIterativeDeletedMacroAttrs, defaultIterativeReplaceArray);
	});
	PFMacros.migrateRepeatingMacros(migrated, 'weapon', 'macro-text', defaultRepeatingMacro, defaultRepeatingMacroMap, defaultDeletedMacroAttrs, '@{PC-Whisper}');
	PFMacros.migrateRepeatingMacros(migrated, 'weapon', 'npc-macro-text', defaultRepeatingMacro, defaultRepeatingMacroMap, defaultDeletedMacroAttrs, '@{NPC-Whisper}');
}
function migrateLinkedAttacks(callback, oldversion) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	if (oldversion <= 0 && oldversion >= 1.5) {
		done();
		return;
	}
	getSectionIDs('repeating_weapon', function (ids) {
		var fields;
		if (!ids || _underscore2.default.size(ids) === 0) {
			done();
			return;
		}
		fields = SWUtils.cartesianAppend(['repeating_weapon_'], ids, ['_source-item', '_source-spell', '_source-ability', '_source-main', '_source-off', '_source-spell-name', '_source-ability-name']);
		fields.push('migrated_linked_attacks');
		getAttrs(fields, function (v) {
			var setter = {};
			if (parseInt(v.migrated_linked_attacks, 10)) {
				done();
				return;
			}
			ids.forEach(function (id) {
				var toSet = 0;
				if (v['repeating_weapon_' + id + '_source-item']) {
					toSet = linkedAttackType.equipment;
				} else if (v['repeating_weapon_' + id + '_source-spell']) {
					toSet = linkedAttackType.spell;
				} else if (v['repeating_weapon_' + id + '_source-ability']) {
					toSet = linkedAttackType.ability;
					if (v['repeating_weapon_' + id + '_source-spell-name'] && !v['repeating_weapon_' + id + '_source-ability-name']) {
						setter['repeating_weapon_' + id + '_source-ability-name'] = v['repeating_weapon_' + id + '_source-spell-name'];
						setter['repeating_weapon_' + id + '_source-spell-name'] = '';
					}
				} else if (v['repeating_weapon_' + id + '_source-main'] || v['repeating_weapon_' + id + '_source-off']) {
					toSet = linkedAttackType.weapon;
				}
				setter['repeating_weapon_' + id + '_link_type'] = toSet;
			});
			setter.migrated_linked_attacks = 1;
			if (_underscore2.default.size(setter)) {
				setAttrs(setter, _PFConst2.default.silentParams, done);
			} else {
				done();
			}
		});
	});
}

function migrate(callback, oldversion) {
	var done = _underscore2.default.once(function () {
		//TAS.debug("leaving PFAttacks.migrate");
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["migrated_damage-multiplier", "migrated_attack_macrosv1"], function (v) {
		var migrateDamage = 0,
		    migrateMacrosv1 = 0,
		    migrateIteratives = 0;
		migrateDamage = parseInt(v["migrated_damage-multiplier"], 10) || 0;
		migrateMacrosv1 = parseInt(v["migrated_attack_macrosv1"], 10) || 0;
		migrateIteratives = parseInt(v["migrated_attacklist_defaults111"]);
		if (migrateDamage && migrateMacrosv1 && migrateIteratives) {
			done();
			return;
		}
		getSectionIDs('repeating_weapon', function (ids) {
			var callmigrateMacrostov1, callmigrateMacrostov64, callmigrateRepeatingDamage, callSetDefaults;
			try {
				if (!ids || _underscore2.default.size(ids) <= 0) {
					setAttrs({ "migrated_damage-multiplier": 1, 'migrated_attack_macrosv1': 1, 'migrated_attacklist_defaults111': 1 }, _PFConst2.default.silentParams, done);
					return;
				}
				callSetDefaults = function callSetDefaults() {
					setNewDefaults(function () {
						migrateLinkedAttacks(done);
					});
				};
				callmigrateMacrostov1 = function callmigrateMacrostov1() {
					if (!migrateMacrosv1) {
						migrateRepeatingMacro(callSetDefaults);
					} else {
						callSetDefaults();
					}
				};
				callmigrateRepeatingDamage = function callmigrateRepeatingDamage() {
					if (!migrateDamage) {
						PFMigrate.migrateRepeatingDamage(ids, callmigrateMacrostov1);
					} else {
						callmigrateMacrostov1();
					}
				};
				callmigrateRepeatingDamage();
			} catch (err) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFAttacks.migrate", err);
				done();
			} finally {}
		});
	});
}
var recalculate = exports.recalculate = _exportsLoaderTASTheAaronSheet2.default.callback(function callrecalculate(callback, silently, oldversion) {
	var done = function done() {
		_exportsLoaderTASTheAaronSheet2.default.info("leaving PFAttacks.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	};
	//TAS.debug("at PFAttacks.recalculate");
	PFAttackGrid.recalculate(function () {
		migrate(function () {
			setAdvancedMacroCheckbox();
			recalculateRepeatingWeapons();
			PFAttackGrid.resetCommandMacro();
			PFAttackOptions.recalculate();
			updateAssociatedAttacksFromParents();
			done();
		}, oldversion);
	}, silently, oldversion);
});
function registerEventHandlers() {
	_underscore2.default.each(PFAttackGrid.attackGridFields, function (attackFields, attack) {
		on("change:" + attackFields.crit, _exportsLoaderTASTheAaronSheet2.default.callback(function eventAttackCrit(eventInfo) {
			if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
				updateRepeatingWeaponsFromCrit(attack, eventInfo);
			}
		}));
	});

	on("change:update_twoweapon_attack", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateDualWield(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			updateDualWield(null, eventInfo);
		}
	}));

	on("remove:repeating_weapon", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateRepeatingWeaponAttackPlayer(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.notice("NEW SECTION");
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			removeLinkedAttack(null, linkedAttackType.weapon, SWUtils.getRowId(eventInfo.sourceAttribute));
		}
	}));

	on("change:repeating_weapon:attack-type-mod change:repeating_weapon:attack-mod", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateRepeatingWeaponAttackSheet(eventInfo) {
		if (eventInfo.sourceType === "sheetworker" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			updateRepeatingWeaponAttack(null, eventInfo);
		}
	}));
	on("change:repeating_weapon:masterwork change:repeating_weapon:proficiency", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateRepeatingWeaponAttackPlayer(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			updateRepeatingWeaponAttack(null, eventInfo);
		}
	}));
	on("change:repeating_weapon:damage-ability-mod change:repeating_weapon:damage-mod", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateRepeatingWeaponDamageSheet(eventInfo) {
		if (eventInfo.sourceType === "sheetworker" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			updateRepeatingWeaponDamage(null, eventInfo);
		}
	}));
	on("change:repeating_weapon:damage_ability_mult change:repeating_weapon:damage-ability-max", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateRepeatingWeaponDamagePlayer(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			updateRepeatingWeaponDamage(null, eventInfo);
		}
	}));
	on("change:repeating_weapon:attack-type", _exportsLoaderTASTheAaronSheet2.default.callback(function eventHandleRepeatingAttackDropdown(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		PFUtilsAsync.setRepeatingDropdownValue("weapon", null, "attack-type", "attack-type-mod");
		updateRepeatingWeaponCrit(null, eventInfo);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			setRepeatingWeaponInsertMacro(null, eventInfo);
			setRepeatingWeaponRangedFlag();
		}
	}));
	on("change:repeating_weapon:damage-ability", _exportsLoaderTASTheAaronSheet2.default.callback(function eventHandleRepeatingDamageDropdown(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		PFUtilsAsync.setRepeatingDropdownValue("weapon", null, "damage-ability", "damage-ability-mod");
	}));
	on("change:repeating_weapon:damage", _exportsLoaderTASTheAaronSheet2.default.callback(function eventRepeatingWeaponDamage(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		SWUtils.evaluateAndSetNumber("repeating_weapon_damage", "repeating_weapon_damage-mod");
	}));
	on("change:repeating_weapon:attack", _exportsLoaderTASTheAaronSheet2.default.callback(function eventRepeatingWeaponAttack(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		SWUtils.evaluateAndSetNumber("repeating_weapon_attack", "repeating_weapon_attack-mod");
	}));
	on("change:repeating_weapon:enhance", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateRepeatingWeaponAttackAndDamage(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			updateRepeatingWeaponAttack(null, eventInfo);
			updateRepeatingWeaponDamage();
		}
	}));
	on("change:repeating_weapon:crit_confirm", _exportsLoaderTASTheAaronSheet2.default.callback(function eventWeaponCritConfirmBonus(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			updateRepeatingWeaponCrit(null, eventInfo);
		}
	}));

	on("change:repeating_weapon:default_damage-dice-num change:repeating_weapon:default_size change:repeating_weapon:default_damage-die change:repeating_weapon:size_affects", _exportsLoaderTASTheAaronSheet2.default.callback(function eventWeaponDice(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			adjustDamageDiceAsync();
		}
	}));
	on("change:repeating_weapon:damage-dice-num change:repeating_weapon:damage-die", _exportsLoaderTASTheAaronSheet2.default.callback(function eventWeaponDice(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			syncDefaultDamageDiceAsync();
		}
	}));
	on("remove:repeating_weapon change:repeating_weapon:attack-type change:_reporder_repeating_weapon change:repeating_weapon:group change:repeating_weapon:name change:include_attack_totals", _exportsLoaderTASTheAaronSheet2.default.callback(function eventRepeatingWeaponChange(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			PFAttackGrid.resetCommandMacro();
		}
	}));
	on("change:create_twoweapon_attack", _exportsLoaderTASTheAaronSheet2.default.callback(function eventCreateTwoWeaponAttack(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			createDualWield();
		}
	}));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFAttacks module loaded        ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setDropdownValue = setDropdownValue;
exports.setRepeatingDropdownValue = setRepeatingDropdownValue;
exports.setRowIds = setRowIds;
exports.registerEventHandlers = registerEventHandlers;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/****************************ASYNCRHOUNOUS UTILITIES ***********************************
 ***************************************************************************************/
/* setDropdownValue
 * Looks at a dropdown selected value, finds the matching attribute value, and then
 * sets the writeFields with that number.
 *
 * @readField {string} = the dropdpown field
 * @writeFields {string or Array} = One string or an array of strings that are fields to write the value to
 * @callback {function} optional = if we need to update the field, call this function
 *       callback(newvalue,oldvalue,ischanged)
 *  If writeField is a string not an Array, then set old value as 2nd param (could be NaN)
 */
function setDropdownValue(readField, writeFields, callback, silently) {
    SWUtils.setDropdownValue(readField, writeFields, PFUtils.findAbilityInString, callback, silently);
}
/** calls setDropdownValue for a dropdown in a repeating section
 *@param {string} section the string between "repeating_" and "_<id>"
 *@param {string} id optional- the id of this row, blank if in context of the current row 
 *@param {string} from the attribute name of the dropdown , string after "repeating_section_id_"
 *@param {string} to the attribute to write to, string after "repeating_section_id_"
 *@param {function} callback - the function passed to setDropdownValue as its callback, that function calls it
 */
function setRepeatingDropdownValue(section, id, from, to, callback, silently) {
    var idStr = SWUtils.getRepeatingIDStr(id),
        prefix = "repeating_" + section + "_" + idStr;
    setDropdownValue(prefix + from, prefix + to, callback, silently);
}
/** setRowIds
 * sets the ID fields and new_flag fields for all rows in the section
 * @param {string} section  = the fieldset name after "section_"
 */
function setRowIds(section) {
    getSectionIDs("repeating_" + section, function (ids) {
        var setter = {};
        _underscore2.default.each(ids, function (id) {
            setter["repeating_" + section + "_" + id + "_row_id"] = id;
        });
        setAttrs(setter);
    });
}
function registerEventHandlers() {
    //REPEATING SECTIONS set IDs
    _underscore2.default.each(_PFConst2.default.repeatingSections, function (section) {
        var eventToWatch = "change:repeating_" + section + ":ids-show";
        on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventCheckIsNewRow(eventInfo) {
            var setter = {},
                id;
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                id = SWUtils.getRowId(eventInfo.sourceAttribute);
                setter["repeating_" + section + "_" + id + "_row_id"] = id;
                setAttrs(setter, _PFConst2.default.silentParams);
            }
        }));
    });
}

registerEventHandlers();
_PFLog.PFConsole.log('   PFUtilsAsync module loaded     ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.migrateMacro = migrateMacro;
exports.migrateRepeatingMacros = migrateRepeatingMacros;
exports.migrateRepeatingMacrosMult = migrateRepeatingMacrosMult;
exports.migrateStaticMacro = migrateStaticMacro;
exports.migrateStaticMacros = migrateStaticMacros;
exports.migrateStaticMacrosMult = migrateStaticMacrosMult;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFUtilsAsync = __webpack_require__(9);

var PFUtilsAsync = _interopRequireWildcard(_PFUtilsAsync);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** splitMacro Splits macro into {{x=y}} components
 * and @{attr} if at top level (not inside a {{x=@{attr}}})
 * @param {string} macrostr the macro-text from a repeating row
 * @returns {Array} of strings comprising macro
 */
function splitMacro(macrostr) {
    var splitted, newsplit, lastclosing;
    if (!macrostr) {
        return "";
    }
    splitted = macrostr.split(/(?=\{\{)/);
    splitted = SWUtils.trimBoth(splitted);
    newsplit = _underscore2.default.reduce(splitted, function (memo, val) {
        try {
            if (val.slice(0, 2) === '{{') {
                if (val.slice(-2) === '}}') {
                    memo.push(val);
                } else {
                    lastclosing = val.lastIndexOf('}}');
                    if (lastclosing < 0) {
                        _exportsLoaderTASTheAaronSheet2.default.error("error! no closing brackets for ", val);
                        //just fix it
                        val += '}}';
                        lastclosing = val.lastIndexOf('}}');
                        memo.push(val);
                    } else {
                        memo.push(SWUtils.trimBoth(val.slice(0, lastclosing + 2)));
                        memo = memo.concat(SWUtils.trimBoth(SWUtils.trimBoth(val.slice(lastclosing + 2)).replace('&amp;', '&').split(/(?=[\@\&]\{)/)));
                    }
                }
            } else {
                val = val.replace('&amp;', '&');
                memo = memo.concat(SWUtils.trimBoth(val.split(/(?=[\@\&]\{)/)));
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("splitmacro", err);
        } finally {
            return memo;
        }
    }, []);
    return newsplit;
}
/** arrayToMap Splits array of {{x=y}} to mapping of '{{x=': 'y}}' 
 * and splits &{template:templatename} on the :
 * unless the item has no equals sign then the value = map.
 *    e.g. @{option}  is returned as @{option}=@{option}
 *@param {Array} currArray of strings for rolltemplate {{key=value}}
 *@returns {jsobj} of each array entry split in half
 */
function arrayToMap(currArray, removeWhisper) {
    return _underscore2.default.reduce(currArray, function (memo, val) {
        var spliteq = val.split('=');
        if (val) {
            if (spliteq.length === 2) {
                memo[spliteq[0] + '='] = spliteq[1];
            } else if (spliteq.length > 2) {
                memo[spliteq[0] + '='] = _underscore2.default.rest(spliteq, 1).join('=');
            } else if (/template:/.test(val)) {
                memo['&{template:'] = val.slice(val.indexOf(':') + 1);
            } else if (!(removeWhisper && /whisper/i.test(val))) {
                memo[val] = val;
            }
        }
        return memo;
    }, {});
}
/**mergeMacroMaps merges currMap into defaultMap 
 *@param {jsobj} currMap map of the current macro text on a sheet created by arrayToMap:
                            {rollqueryleft: rollqueryright}
 *@param {jsobj} defaultMap {rollqueryleft : {
                            current:rollqueryright, 
                            old:[  oldrollqueryright1, oldrollqueryright2 ], 
                            replacements:[  { from: fromstring, to:tostring}, {from:fromstring, to:tostring}] 
                            }
                        }
 *@param {Array} sameAsKeys array of strings of keys in defaultMap where value.current is the same string as the key
 *@returns {Array} of strings for macro entries.
 */
function mergeMacroMaps(currMap, defaultMap, sameAsKeys) {
    var currKeys = [],
        newKeys = [],
        customKeys = [],
        newArray = [],
        customizedMap = {},
        userDefinedMap = {};
    try {
        currKeys = _underscore2.default.keys(currMap).sort();
        customKeys = _underscore2.default.difference(currKeys, _underscore2.default.keys(defaultMap)).sort();
        if (!sameAsKeys || _underscore2.default.size(sameAsKeys) === 0) {
            sameAsKeys = _underscore2.default.reduce(defaultMap, function (memo, val, key) {
                if (val.current === key) {
                    memo.push(key);
                }
                return memo;
            }, []).sort();
        }
        //TAS.debug("at mergeMacroMaps comparing: ",currMap,defaultMap,sameAsKeys);
        customizedMap = _underscore2.default.chain(defaultMap).pick(function (compareobj, defaultKey) {
            //intersection
            return _underscore2.default.indexOf(currKeys, defaultKey, true) >= 0;
        }).omit(function (compareobj, defaultKey) {
            //difference
            return _underscore2.default.indexOf(sameAsKeys, defaultKey, true) >= 0;
        }).omit(function (compareobj, defaultKey) {
            //user val = new
            return compareobj.current === currMap[defaultKey];
        }).omit(function (compareobj, defaultKey) {
            //user val = one of old vals
            return !compareobj.old || _underscore2.default.indexOf(compareobj.old, currMap[defaultKey]) >= 0;
        }).mapObject(function (compareobj, defaultKey) {
            //only customized values left, if any
            var newString = '';
            try {
                newString = currMap[defaultKey];
                if (newString) {
                    if (compareobj.replacements) {
                        newString = _underscore2.default.reduce(compareobj.replacements, function (memo, replacer) {
                            return memo.replace(replacer.from, replacer.to);
                        }, newString);
                    }
                    newString = defaultKey + newString;
                }
            } catch (erri) {
                _exportsLoaderTASTheAaronSheet2.default.error('mergeMacroMaps  erri on ' + defaultKey, erri);
            } finally {
                return newString;
            }
        }).value();

        //extra stuff from user.
        userDefinedMap = _underscore2.default.reduce(customKeys, function (memo, currKey) {
            if (currKey !== currMap[currKey]) {
                memo[currKey] = currKey + currMap[currKey];
            } else {
                memo[currKey] = currKey;
            }
            return memo;
        }, {});

        //TAS.info("joining ",defaultMap,customizedMap,userDefinedMap);
        //array in order of defaultMap, add in custom values, then turn to array
        newArray = _underscore2.default.chain(defaultMap).mapObject(function (compareobj, defaultKey) {
            if (_underscore2.default.indexOf(sameAsKeys, defaultKey) >= 0) {

                return defaultKey;
            }
            return defaultKey + compareobj.current;
        }).extend(customizedMap).extend(userDefinedMap).values().value();
    } catch (err3) {
        _exportsLoaderTASTheAaronSheet2.default.error("getNewArray outer error", err3);
    } finally {
        return newArray;
    }
}
/**migrateMacro makes sure one macro is up to date, synchronous.
 *@param {string} currMacro current macro from sheet
 *@param {string} defaultMacro default / new correct macro string
 *@param {{string : {current:string,  old:[  string ],  replacements:[  { from: string, to:string}]  }
                        }} defaultMap {rollqueryleft : {
                            current:rollqueryright, 
                            old:[  oldrollqueryright1, oldrollqueryright2 ], 
                            replacements:[  { from: fromstring, to:tostring}, {from:fromstring, to:tostring}] 
                            }
                        }
 *@param {[string]} deleteArray array of strings to just delete from the currMacro.
 *@param {[string]} sameAsKeys array of strings of keys in defaultMap where value.current is the same string as the key
 *@returns {string} one of 3 values:
            null if caller should NOT update macro, 
            "BLANK" if caller should update macro attribute with "" to reset it.
            any other string: the new macro (if the user customized it, then this is the new one with updates)
 */
function migrateMacro(currMacro, defaultMacro, defaultMap, deleteArray, sameAsKeys) {
    var currMacroArray,
        currMacroMap,
        newMacroArray,
        newMacroString = null;
    try {
        if (currMacro !== defaultMacro) {
            if (deleteArray && Array.isArray(deleteArray)) {
                _underscore2.default.each(deleteArray, function (strToDelete) {
                    currMacro = currMacro.replace(strToDelete, '');
                });
            }
            if (currMacro === defaultMacro) {
                newMacroString = null;
            } else {
                currMacroArray = splitMacro(currMacro);
                currMacroArray = _underscore2.default.reject(currMacroArray, function (val) {
                    return !val || val === "0" || val === "1" || val.indexOf("undefined") >= 0;
                });
                currMacroMap = arrayToMap(currMacroArray, true);
                //TAS.info("migrateMacro calling map with ",currMacroMap,defaultMap,sameAsKeys);
                newMacroArray = mergeMacroMaps(currMacroMap, defaultMap, sameAsKeys);
                //TAS.debug("migrateMacro received back ",newMacroArray);
                newMacroArray = _underscore2.default.reject(newMacroArray, function (val) {
                    return !val || val === "0" || val === "1" || val.indexOf("undefined") >= 0;
                });
                newMacroString = newMacroArray.join(' ');
                if (newMacroString === defaultMacro) {
                    newMacroString = 'BLANK';
                }
            }
        }
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFMacros.migrateMacro error on " + currMacro, err);
    } finally {
        return newMacroString;
    }
}
/** migrateRepeatingMacros updates all macros in the section 
 * @param {function} callback after calling setAttrs with the new macros
 * @param {string} section  name after "repeating_"
 * @param {string} fieldname  the attribute name containing the macro after "id_"
 * @param {string} defaultMacro the current Macro in the page
 * @param {jsobj} defaultMap map of "{{rolltemplatekey=" to right side "var}}"
        {rollqueryleft : {
            current:rollqueryright, 
            old:[  oldrollqueryright1, oldrollqueryright2 ], 
            replacements:[  { from: fromstring, to:tostring}, {from:fromstring, to:tostring}] 
            }
        }
 * @param {Array} deleteArray  array of strings of old rolltemplate entries that are not used (entire entry not just left side )
 */
function migrateRepeatingMacros(callback, section, fieldname, defaultMacro, defaultMap, deleteArray, whisper) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving migrateRepeatingMacros for " + section + ", " + fieldname);
        if (typeof callback === "function") {
            callback();
        }
    });
    whisper = whisper || '';
    if (whisper) {
        whisper += ' ';
    }
    getSectionIDs('repeating_' + section, function (ids) {
        var fields = [],
            prefix = 'repeating_' + section + '_';
        if (!ids || _underscore2.default.size(ids) === 0) {
            done();
            return;
        }
        _underscore2.default.each(ids, function (id) {
            fields.push(prefix + id + '_' + fieldname);
        });
        getAttrs(fields, function (v) {
            var setter = {},
                sameAsKeys = [];
            sameAsKeys = _underscore2.default.reduce(defaultMap, function (memo, val, key) {
                if (val.current === key) {
                    memo.push(key);
                }
                return memo;
            }, []).sort();
            setter = _underscore2.default.reduce(v, function (memo, currMacro, key) {
                var newMacro = "";
                try {
                    if (!currMacro) {
                        //setting to blank does not seem to work, it keeps coming back as undefined, so set to default.
                        memo[key] = whisper + defaultMacro;
                    } else {
                        currMacro = PFUtils.removeWhisperFromMacro(currMacro);
                        newMacro = migrateMacro(currMacro, defaultMacro, defaultMap, deleteArray, sameAsKeys);
                        if (newMacro === "BLANK") {
                            memo[key] = "";
                        } else if (newMacro) {
                            memo[key] = whisper + newMacro;
                        }
                    }
                } catch (innererr) {
                    _exportsLoaderTASTheAaronSheet2.default.error("migrateRepeatingMacros error migrating " + key, innererr);
                } finally {
                    return memo;
                }
            }, {});
            if (_underscore2.default.size(setter) > 0) {
                setAttrs(setter, {}, done);
            } else {
                done();
            }
        });
    });
}
/**Calls migrateRepeatingMacros once for each version of the parameters in replaceArray
 * each parameter below potentially has the word 'REPLACE' in it, for each element in replaceArray,
 * replace the word REPLACE with that element.
 * This is not the most efficient, but it was alot easier than rewriting migrateRepeatingMacros 
 *@param {function} callback after calling setAttrs with the new macros
 *@param {string} section  name after "repeating_"
 *@param {string} fieldname  the attribute name containing the macro after "id_"
 *@param {string} defaultMacro the current Macro in the page
 *@param {jsobj} defaultMap map of "{{rolltemplatekey=" to right side "var}}"
        {rollqueryleft : {
            current:rollqueryright, 
            old:[  oldrollqueryright1, oldrollqueryright2 ], 
            replacements:[  { from: fromstring, to:tostring}, {from:fromstring, to:tostring}] 
            }
        }
 *@param {Array} deleteArray array of strings of old rolltemplate entries that are not used (entire entry not just left side )
 *@param {Array} replaceArray array of strings to replace the word 'REPLACE' with that are found in the other params.
 */
function migrateRepeatingMacrosMult(callback, section, fieldname, defaultMacro, defaultMap, deleteArray, replaceArray, whisper) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving migrateRepeatingMacrosMult for " + section + "_" + fieldname);
        if (typeof callback === "function") {
            callback();
        }
    }),
        fieldnames = {},
        defaultMacros = {},
        defaultMaps = {},
        deleteArrays = {},
        numTimes,
        doneOnce;
    try {
        if (!(replaceArray && Array.isArray(replaceArray) && _underscore2.default.size(replaceArray) > 0)) {
            _exportsLoaderTASTheAaronSheet2.default.warn("migrateRepeatingMacrosMult no replace array for " + section + ", " + fieldname);
            done();
            return;
        }
        numTimes = _underscore2.default.size(replaceArray);
        doneOnce = _underscore2.default.after(numTimes, done);
        //create new mappings of fieldname, defaultMacro, defaultMap, deleteArray
        //one new version of each per element in replaceArray.
        fieldnames = _underscore2.default.reduce(replaceArray, function (m, val) {
            m[val] = fieldname.replace(/REPLACE/g, val);
            return m;
        }, {});
        defaultMacros = _underscore2.default.reduce(replaceArray, function (m, val) {
            m[val] = defaultMacro.replace(/REPLACE/g, val);
            return m;
        }, {});
        defaultMaps = _underscore2.default.reduce(replaceArray, function (replaceMemo, val) {
            var newMap = {};
            try {
                newMap = _underscore2.default.reduce(defaultMap, function (m, currobj, key) {
                    var newkey,
                        newobj = {};
                    try {
                        newkey = key.replace(/REPLACE/g, val);
                        newobj.current = currobj.current.replace(/REPLACE/g, val);
                        if (currobj.old) {
                            newobj.old = _underscore2.default.map(currobj.old, function (oldmacro) {
                                return oldmacro.replace(/REPLACE/g, val);
                            });
                        }
                        if (currobj.replacements) {
                            newobj.replacements = _underscore2.default.map(currobj.replacements, function (replacementobj) {
                                var newreplacement = {};
                                newreplacement.from = replacementobj.from.replace(/REPLACE/g, val);
                                newreplacement.to = replacementobj.to.replace(/REPLACE/g, val);
                                return newreplacement;
                            });
                        }
                        m[newkey] = newobj;
                    } catch (innererr) {
                        _exportsLoaderTASTheAaronSheet2.default.error("migrateRepeatingMacrosMult, error creating defaultMaps: replaceval" + val + ", key=" + key + ", matching obj:", currobj);
                    } finally {
                        return m;
                    }
                }, {});
                replaceMemo[val] = newMap;
            } catch (errineer2) {
                _exportsLoaderTASTheAaronSheet2.default.error("error building map of defaultMap : replaceval:" + val);
            } finally {
                return replaceMemo;
            }
        }, {});
        if (deleteArray) {
            deleteArrays = _underscore2.default.reduce(replaceArray, function (m, val) {
                m[val] = _underscore2.default.map(deleteArray, function (delstr) {
                    return delstr.replace(/REPLACE/g, val);
                });
                return m;
            }, {});
        }
        _underscore2.default.each(replaceArray, function (val) {
            var delArray;
            try {
                if (fieldnames[val] && defaultMacros[val] && defaultMaps[val]) {
                    delArray = deleteArrays[val] || null;
                    migrateRepeatingMacros(doneOnce, section, fieldnames[val], defaultMacros[val], defaultMaps[val], delArray, whisper);
                } else {
                    doneOnce();
                }
            } catch (err) {
                _exportsLoaderTASTheAaronSheet2.default.error("migrateRepeatingMacrosMult error calling migrateRepeatingMacros for " + val, err);
                doneOnce();
            }
        });
    } catch (outererr) {
        _exportsLoaderTASTheAaronSheet2.default.ERROR("migrateRepeatingMacrosMult error in outermost section SHOULD NOT HAPPEN ", outererr);
        done();
    }
}
/**
 * 
 * 
 * @export
 * @param {any} callback 
 * @param {any} fieldname 
 * @param {any} defaultMacro 
 * @param {any} defaultMap 
 * @param {any} deleteArray 
 * @param {any} sameAsKeys 
 * @param {any} whisper 
 */
function migrateStaticMacro(callback, fieldname, defaultMacro, defaultMap, deleteArray, sameAsKeys, whisper) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving migrateRepeatingMacros for " + fieldname);
        if (typeof callback === "function") {
            callback();
        }
    });
    whisper = whisper || '';
    if (whisper) {
        whisper += ' ';
    }
    //TAS.debug("at PFMacros.migrateStaticMacro for repeating_"+ fieldname);
    getAttrs([fieldname], function (v) {
        var setter = {},
            newMacro = '',
            currMacro = '';
        try {
            if (!sameAsKeys) {
                sameAsKeys = _underscore2.default.reduce(defaultMap, function (memo, val, key) {
                    if (val.current === key) {
                        memo.push(key);
                    }
                    return memo;
                }, []).sort();
            }
            currMacro = v[fieldname];
            if (!currMacro) {
                setter[fieldname] = whisper + defaultMacro;
            } else {
                currMacro = PFUtils.removeWhisperFromMacro(currMacro);
                newMacro = migrateMacro(currMacro, defaultMacro, defaultMap, deleteArray, sameAsKeys);
                if (newMacro) {
                    if (newMacro === 'BLANK') {
                        setter[fieldname] = "";
                    } else {
                        setter[fieldname] = whisper + newMacro;
                    }
                }
            }
        } catch (innererr) {
            _exportsLoaderTASTheAaronSheet2.default.error("migrateRepeatingMacros error migrating " + fieldname + ", " + currMacro, innererr);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                setAttrs(setter, {}, done);
            } else {
                done();
            }
        }
    });
}
/**
 * 
 * @param {any} callback 
 * @param {any} fieldnames 
 * @param {any} defaultMacros 
 * @param {any} defaultMaps 
 * @param {any} deleteArrays 
 * @param {any} sameAsKeys 
 * @param {any} whisper 
 */
function migrateStaticMacros(callback, fieldnames, defaultMacros, defaultMaps, deleteArrays, sameAsKeys, whisper) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving migrateStaticMacros ");
        if (typeof callback === "function") {
            callback();
        }
    }),
        fields = [],
        keys = [];
    whisper = whisper || '';
    if (whisper) {
        whisper += ' ';
    }
    fields = _underscore2.default.values(fieldnames);
    keys = _underscore2.default.keys(fieldnames);
    getAttrs(fields, function (v) {
        var setter = {};
        if (!sameAsKeys || !Array.isArray(sameAsKeys) || _underscore2.default.size(sameAsKeys) === 0) {
            sameAsKeys = _underscore2.default.reduce(defaultMaps[0], function (memo, val, key) {
                if (val.current === key) {
                    memo.push(key);
                }
                return memo;
            }, []).sort();
        }
        setter = _underscore2.default.reduce(keys, function (memo, key) {
            var newMacro = "",
                currMacro = "",
                delArray = null,
                field = '';
            try {
                field = fieldnames[key];
                currMacro = v[field];
                if (!currMacro) {
                    memo[field] = defaultMacros[key];
                } else {
                    if (deleteArrays && deleteArrays[key]) {
                        delArray = deleteArrays[key];
                    }
                    if (currMacro) {
                        newMacro = migrateMacro(currMacro, defaultMacros[key], defaultMaps[key], delArray, sameAsKeys);
                        if (newMacro === "BLANK") {
                            memo[field] = "";
                        } else if (newMacro) {
                            memo[field] = newMacro;
                        }
                    }
                }
            } catch (innererr) {
                _exportsLoaderTASTheAaronSheet2.default.error("migrateStaticMacros error migrating " + key, innererr);
            } finally {
                return memo;
            }
        }, {});
        //TAS.debug("migrateStaticMacros setting ", setter);
        if (_underscore2.default.size(setter) > 0) {
            setAttrs(setter, {}, done);
        } else {
            done();
        }
    });
}
/** migrateStaticMacrosMult migrate many static macros with names following a pattern (skills)
 * fieldname can have the following keys in it:
 * REPLACE  - replace this with string from replaceArray
 * REPLACELOWER - replace this with lowercase of string from replaceArray
 * REPLACEREMOVENUMBER - replace this with: strip out digit chars from string from replaceArray
 * REPLACELOWERREMOVENUMBER - replace this with: strip out digit chars from lowercase string from replaceArray
 * 
 * if any of the "REMOVENUMBER" values are used, then caller should set useNoNumber to true
 * 
 * @param {function} callback after calling setAttrs with the new macros
 * @param {string} fieldname string pattern of attr we are saving to. Should have one of 'REPLACE','REPLACELOWER','REPLACEREMOVENUMBER','REPLACELOWERREMOVENUMBER' in it, which will be replaced by values in replaceArray
 * @param {string} defaultMacro default macro with REPLACE strings
 * @param {{string : {current:string,  old:[  string ],  replacements:[  { from: string, to:string}]  }
                        }} defaultMap a map of key and values for the rolltemplate.  
                         {rollqueryleft : {current:rollqueryright, old:[  oldrollqueryright1, oldrollqueryright2 ], 
                            replacements:[  { from: fromstring, to:tostring}, {from:fromstring, to:tostring}] } }
 * @param {[string]} deleteArray Strings to delete from the macro (such as @{PC-Whisper} or other @{attrname}) that do not correspond to key-value pair in defaultMacro
 * @param {[string]} replaceArray values to insert in place of "REPLACEx" strings found in fieldname
 * @param {[string]} keysToReplaceShortcut array of keys from defaultMacro, if not supplied will be built
 * @param {[string]} valsToReplaceShortcut 
 * @param {boolean} useNoNumber When matching replaceArray, whether to try to strip numbers from replace strings as well as use the whole string
 * @param {string} whisper Either @{PC-Whisper} or @{NPC-Whisper}
 */
function migrateStaticMacrosMult(callback, fieldname, defaultMacro, defaultMap, deleteArray, replaceArray, keysToReplaceShortcut, valsToReplaceShortcut, useNoNumber, whisper) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving migrateRepeatingMacrosMult for " + fieldname);
        if (typeof callback === "function") {
            callback();
        }
    }),
        fieldnames = {},
        replacers = {},
        defaultMacros = {},
        defaultMaps = {},
        deleteArrays = {},
        numTimes,
        doneOnce,
        sameAsKeys,
        replaceStrings = function replaceStrings(str, val) {
        var fromAndTos = [];
        try {
            fromAndTos = replacers[val];
            //TAS.debug("now using replacer to replace :"+val+" in "+str,fromAndTos);
            if (fromAndTos) {
                _underscore2.default.each(fromAndTos, function (replacer) {
                    str = str.replace(replacer.from, replacer.to);
                });
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFMacros migrateStaticMacrosMult replaceStrings error replacing  " + val + " in " + str, replacers[val], err);
        } finally {
            return str;
        }
    };
    try {
        whisper = whisper || '';
        if (whisper) {
            whisper += ' ';
        }
        if (!(replaceArray && Array.isArray(replaceArray))) {
            _exportsLoaderTASTheAaronSheet2.default.warn("migrateStaticMacrosMult no replace array for  " + fieldname);
            done();
            return;
        }
        numTimes = _underscore2.default.size(replaceArray);
        doneOnce = _underscore2.default.after(numTimes, done);
        //create new mappings of fieldname, defaultMacro, defaultMap, deleteArray
        //one new version of each per element in replaceArray.
        if (useNoNumber) {
            replacers = _underscore2.default.reduce(replaceArray, function (m, val) {
                var valNoNum = val.replace(/\d+/g, '').replace(/\-+$/, '');
                m[val] = [{ 'from': /REPLACELOWERREMOVENUMBER/g, 'to': valNoNum.toLowerCase() }, { 'from': /REPLACELOWER/g, 'to': val.toLowerCase() }, { 'from': /REPLACEREMOVENUMBER/g, 'to': valNoNum }, { 'from': /REPLACE/g, 'to': val }];
                return m;
            }, {});
        } else {
            replacers = _underscore2.default.reduce(replaceArray, function (m, val) {
                m[val] = [{ 'from': /REPLACELOWER/g, 'to': val.toLowerCase() }, { 'from': /REPLACE/g, 'to': val }];
                return m;
            }, {});
        }
        fieldnames = _underscore2.default.reduce(replaceArray, function (m, val) {
            m[val] = fieldname.replace(/REPLACE/g, val);
            return m;
        }, {});
        sameAsKeys = _underscore2.default.reduce(defaultMap, function (memo, compObj, key) {
            var replacedKeys = [];
            if (compObj.current === key) {
                //see if this needs replacing.
                if (_underscore2.default.indexOf(keysToReplaceShortcut, key, true) >= 0) {
                    replacedKeys = _underscore2.default.map(replaceArray, function (replaceKey) {
                        return key.replace(/REPLACE/g, replaceKey);
                    });
                    memo = memo.concat(replacedKeys);
                } else {
                    memo.push(key);
                }
            }
            return memo;
        }, []).sort();

        defaultMacros = _underscore2.default.reduce(replaceArray, function (m, val) {
            var newMacro = replaceStrings(defaultMacro, val);
            m[val] = newMacro;
            return m;
        }, {});
        defaultMaps = _underscore2.default.reduce(replaceArray, function (replaceMemo, val) {
            var newMap = {};
            try {
                newMap = _underscore2.default.reduce(defaultMap, function (memo, currobj, key) {
                    var newkey,
                        newobj = {};
                    try {
                        if (_underscore2.default.indexOf(keysToReplaceShortcut, key, true) >= 0) {
                            newkey = key.replace(/REPLACE/g, val);
                        } else {
                            newkey = key;
                        }
                        if (_underscore2.default.indexOf(valsToReplaceShortcut, key, true) >= 0) {
                            newobj.current = replaceStrings(currobj.current, val);
                            if (currobj.old) {
                                newobj.old = _underscore2.default.map(currobj.old, function (oldmacro) {
                                    return replaceStrings(oldmacro, val);
                                });
                            }
                        } else {
                            newobj.current = currobj.current;
                            if (currobj.old) {
                                newobj.old = currobj.old;
                            }
                        }
                        if (currobj.replacements) {
                            newobj.replacements = currobj.replacements;
                        }
                        memo[newkey] = newobj;
                    } catch (innererr) {
                        _exportsLoaderTASTheAaronSheet2.default.error("migrateStaticMacrosMult error creating defaultMaps: replaceval" + val + ", key=" + key + ", matching obj:", currobj);
                    } finally {
                        return memo;
                    }
                }, {});
                replaceMemo[val] = newMap;
            } catch (errineer2) {
                _exportsLoaderTASTheAaronSheet2.default.error("migrateStaticMacrosMult error building map of defaultMap : replaceval:" + val);
            } finally {
                return replaceMemo;
            }
        }, {});

        if (deleteArray) {
            deleteArrays = _underscore2.default.reduce(replaceArray, function (m, val) {
                m[val] = _underscore2.default.map(deleteArray, function (delstr) {
                    return replaceStrings(delstr, val);
                });
                return m;
            }, {});
        }
        migrateStaticMacros(done, fieldnames, defaultMacros, defaultMaps, deleteArrays, sameAsKeys, whisper);
    } catch (outererr) {
        _exportsLoaderTASTheAaronSheet2.default.ERROR("migrateStaticMacrosMult error in outermost section SHOULD NOT HAPPEN ", outererr);
        done();
    }
}
_PFLog.PFConsole.log('   PFMacros module loaded         ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.abilitymods = exports.abilities = undefined;
exports.getAttributes = getAttributes;
exports.getAllAttributes = getAllAttributes;
exports.getAbilityScore = getAbilityScore;
exports.updateAbilityScore = updateAbilityScore;
exports.updateAbilityScores = updateAbilityScores;
exports.applyConditions = applyConditions;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFLog = __webpack_require__(0);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var abilities = exports.abilities = ["STR", "DEX", "CON", "INT", "WIS", "CHA"];
var abilitymods = exports.abilitymods = ["STR-mod", "DEX-mod", "CON-mod", "INT-mod", "WIS-mod", "CHA-mod"];
var columnMods = ["-base", "-enhance", "-inherent", "-misc", "-damage", "-penalty", "-drain", "-mod", "-cond", "-modded"],
    columnBuffMods = ["-total", "-total_penalty"],
    columnModHelpers = ["condition-Helpless"],

/** map of event types to event string for 'on' function to look for */
events = {
    abilityEventsAuto: "change:REPLACE-cond", //buffs events handled in PFBuffs
    abilityEventsPlayer: "change:REPLACE-base change:REPLACE-enhance change:REPLACE-inherent change:REPLACE-misc change:REPLACE-temp change:REPLACE-damage change:REPLACE-penalty change:REPLACE-drain"
};

function getAttributes(ability) {
    var fields = _underscore2.default.map(columnMods, function (col) {
        return ability + col;
    });
    fields.push(ability);
    fields = fields.concat(_underscore2.default.map(columnBuffMods, function (col) {
        return 'buff_' + ability + col;
    }));
    fields = fields.concat(columnModHelpers);
    return fields;
}

function getAllAttributes() {
    var fields = SWUtils.cartesianAppend(abilities, columnMods);
    fields = fields.concat(abilities);
    fields = fields.concat(SWUtils.cartesianAppend(['buff_'], abilities, columnBuffMods));
    fields = fields.concat(columnModHelpers);
    return fields;
}

/** Looks at current values and calculates new ability , ability-mod and ability-modded values
 * @param {string} ability string matching a value in abilities
 * @param {Map} values map of return values from getAttrs
 * @param {Map} setter map of values to pass to setAttrs. or null
 * @returns {Map}  same setter passed in, with added values if necessary
 */
function getAbilityScore(ability, values, setter) {
    var base = 0,
        newVal = 0,
        rawDmg = 0,
        rawPen = 0,
        dmgAndPen = 0,
        rawCond = 0,
        helpless = 0,
        penalized = 0,
        rawDmgAndPen = 0,
        currAbility = 0,
        currMod = 0,
        currPenalized = 0,
        mod = 0;
    try {
        setter = setter || {};
        base = parseInt(values[ability + "-base"], 10);
        //if NaN, make sure it's either empty or has a minus
        if (isNaN(base) && !_PFConst2.default.minusreg.test(values[ability + '-base'])) {
            return setter;
        }
        currMod = parseInt(values[ability + "-mod"], 10);
        currPenalized = parseInt(values[ability + "-modded"], 10) || 0;
        currAbility = parseInt(values[ability], 10);
        if (isNaN(base)) {
            newVal = "-";
            mod = 0;
            penalized = 0;
        } else {
            helpless = parseInt(values["condition-Helpless"], 10) || 0;
            if (ability === "DEX" && helpless) {
                newVal = 0;
                mod = -5;
                penalized = 1;
            } else {
                newVal = base + (parseInt(values[ability + "-enhance"], 10) || 0) + (parseInt(values[ability + "-inherent"], 10) || 0) + (parseInt(values[ability + "-misc"], 10) || 0) + (parseInt(values[ability + "-drain"], 10) || 0) + (parseInt(values["buff_" + ability + "-total"], 10) || 0);
                rawDmg = Math.abs(parseInt(values[ability + "-damage"], 10) || 0);
                if (rawDmg >= newVal || newVal <= 0) {
                    newVal = 0;
                    mod = -5;
                    penalized = 1;
                } else {
                    rawPen = Math.abs(parseInt(values[ability + "-penalty"], 10) || 0) + Math.abs(parseInt(values["buff_" + ability + "-total_penalty"], 10) || 0);
                    rawCond = Math.abs(parseInt(values[ability + "-cond"], 10) || 0);
                    rawDmgAndPen = rawDmg + rawPen + rawCond;
                    if (rawDmgAndPen >= newVal) {
                        newVal = currAbility;
                        mod = -5;
                        penalized = 1;
                    } else {
                        //normal
                        if (rawDmgAndPen !== 0) {
                            penalized = 1;
                        }
                        dmgAndPen = Math.floor(rawDmgAndPen / 2);
                        mod = Math.max(-5, Math.floor((newVal - 10) / 2) - dmgAndPen);
                    }
                }
            }
        }
        if (currAbility !== newVal) {
            setter[ability] = newVal;
        }
        if (currMod !== mod || isNaN(currMod)) {
            setter[ability + "-mod"] = mod;
        }
        if (penalized !== currPenalized) {
            setter[ability + "-modded"] = penalized;
        }
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("updateAbilityScore:" + ability, err);
    } finally {
        return setter;
    }
}

/** updateAbilityScore - Updates the final ability score, ability modifier, condition column based on entries in ability grid plus conditions and buffs.
 * Note: Ability value is not affected by damage and penalties, instead only modifier is affected.
 * @param {string} ability 3 letter abbreviation for one of the 6 ability scores, member of PFAbilityScores.abilities
 * @param {eventInfo} eventInfo unused eventinfo from 'on' method
 * @param {function} callback when done
 * @param {boolean} silently if silent:true or not
 */
function updateAbilityScore(ability, eventInfo, callback, silently) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    }),
        fields = getAttributes(ability);
    getAttrs(fields, function (v) {
        var params = {},
            setter = {};
        getAbilityScore(ability, v, setter);
        if (_underscore2.default.size(setter)) {
            if (silently) {
                params = _PFConst2.default.silentParams;
            }
            setAttrs(setter, params, done);
        } else {
            done();
        }
    });
}
/** calls getAbilityScore for all abilities
 * @param {function} callback when done
 * @param {boolean} silently if silent:true or not
 */
function updateAbilityScores(callback, silently) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    }),
        fields = getAllAttributes();
    getAttrs(fields, function (v) {
        var params = {},
            setter = {};
        setter = _underscore2.default.reduce(abilities, function (m, a) {
            getAbilityScore(a, v, m);
            return m;
        }, {});
        if (_underscore2.default.size(setter)) {
            if (silently) {
                params = _PFConst2.default.silentParams;
            }
            setAttrs(setter, params, done);
        } else {
            done();
        }
    });
}

/** Sets ability penalties, not "ability check" penalties 
 * Sets DEX-cond and STR-cond for fatigued, entangled, and grappled  
 *@param {function} callback to call when done.
 *@param {boolean} silently if true update with PFConst.silentParams
 */
function applyConditions(callback, silently) {
    var done = function done() {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAbilityScores.applyConditions");
        if (typeof callback === "function") {
            callback();
        }
    };
    getAttrs(["STR-cond", "DEX-cond", "condition-Fatigued", "condition-Entangled", "condition-Grappled", "condition-Helpless"], function (v) {
        var setter = {},
            params = {},
            helpless = parseInt(v["condition-Helpless"], 10) || 0,
            strMod = parseInt(v["condition-Fatigued"], 10) || 0,
            dexMod = 0,
            dexAbMod = 0,
            strAbMod = 0;
        try {
            dexMod = strMod + (parseInt(v["condition-Entangled"], 10) || 0) + (parseInt(v["condition-Grappled"], 10) || 0);
            dexAbMod = dexMod * -2;
            strAbMod = strMod * -2;
            if (!helpless) {
                if (dexAbMod !== (parseInt(v["DEX-cond"], 10) || 0)) {
                    setter["DEX-cond"] = dexAbMod;
                }
                if (strAbMod !== (parseInt(v["STR-cond"], 10) || 0)) {
                    setter["STR-cond"] = strAbMod;
                }
            } else {
                setter["DEX"] = 0;
                setter["DEX-mod"] = -5;
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFAbilityScores.applyConditions", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                _exportsLoaderTASTheAaronSheet2.default.notice("#######################", "PFAbilities apply conditions setting", setter);
                setAttrs(setter, params, done);
            } else {
                done();
            }
        }
    });
}
/** migrate (currently empty just calls callback
 * @param {function} callback when done
 * @param {Number} oldversion
 */
function migrate(callback, oldversion) {
    if (typeof callback === "function") {
        callback();
    }
}
/** recalculates all attributes written to by this module.
 *@param {function()} callback to call when done.
 *@param {boolean} silently if true update with PFConst.silentParams
 *@param {float} oldversion the current @{PFVersion} in the attributes
 */
function recalculate(callback, silently, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAbilityScores.recalculate");
        if (typeof callback === "function") {
            callback();
        }
    }),
        updateScoresOnce = _underscore2.default.once(function () {
        updateAbilityScores(done, silently);
    });
    applyConditions(updateScoresOnce, silently);
}

/** Calls 'on' function for everything related to this module */
function registerEventHandlers() {
    //register event handlers **********************************************
    _underscore2.default.each(abilities, function (ability) {
        on(events.abilityEventsAuto.replace(/REPLACE/g, ability), _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateAbility(eventInfo) {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            if (eventInfo.sourceType === "sheetworker") {
                updateAbilityScore(ability, eventInfo);
            }
        }));
        on(events.abilityEventsPlayer.replace(/REPLACE/g, ability), _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateAbilityPlayerUpdated(eventInfo) {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                updateAbilityScore(ability, eventInfo);
            }
        }));
    });
    on("change:condition-Helpless", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateAbilityHelpless(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            updateAbilityScore("DEX", eventInfo);
        }
    }));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFAbilityScores module loaded  ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getOptionText = getOptionText;
exports.resetOption = resetOption;
exports.resetSomeOptions = resetSomeOptions;
exports.resetOptions = resetOptions;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var optionTemplates = {
    melee_notes: "{{melee_notes=REPLACE}}",
    ranged_notes: "{{ranged_notes=REPLACE}}",
    CMB_notes: "{{CMB_notes=REPLACE}}",
    attack_notes: "{{attack_notes=REPLACE}}",
    header_image: "{{header_image=REPLACE}}"
},
    optionDefaults = {
    notes: {
        melee: "@{melee-attack-notes}",
        ranged: "@{ranged-attack-notes}",
        CMB: "@{CMB-notes}",
        attack: "@{attack-notes}"
    },
    image: {
        melee: "@{header_image-pf_attack-melee}",
        ranged: "@{header_image-pf_attack-ranged}",
        CMB: "@{header_image-pf_attack-cmb}"
    }
},

//not used since melee options field actually look at the text..
//optionAttrs = ["melee-attack-notes", "ranged-attack-notes", "CMB-notes", "attack-notes", "header_image-pf_attack-melee", "header_image-pf_attack-ranged", "header_image-pf_attack-cmb"],
optionToggles = ["toggle_attack_melee_notes", "toggle_attack_ranged_notes", "toggle_attack_CMB_notes", "toggle_attack_attack_notes", "toggle_attack_header_image"],

//attackOptionRegex = PFUtils.getOptionsCompiledRegexMap(optionTemplates),
repeatingOptionAttrs = ["attack-type", "damage-ability", "damage-dice-num", "damage-die", "damage", "attack"],
    repeatingOptionHelperAttrs = [""],
    // ["damage-mod", "attack-mod"],
repeatingOptionGetAttrs = repeatingOptionAttrs.concat(repeatingOptionHelperAttrs),
    repeatingOptionGetAttrsLU = _underscore2.default.map(repeatingOptionGetAttrs, function (field) {
    return '_' + field;
}),
    events = {
    attackOptionEventsPlayer: repeatingOptionAttrs,
    attackOptionEventsAuto: repeatingOptionHelperAttrs
};

/********* REPEATING WEAPON FIELDSET *********/
/** getOptionText - resets entire macro options text for a repeating_weapon row
 *@param {string} prefix repeating_weapon_id_
 *@param {map} toggleValues map of ".showxxxx" where xxxx is what to display, already calculated for us
 *@param {map} rowValues output from getAttrs
 */
function getOptionText(prefix, toggleValues, rowValues) {
    var attackType = PFUtils.findAbilityInString(rowValues[prefix + "attack-type"]),
        damageAbility = PFUtils.findAbilityInString(rowValues[prefix + "damage-ability"]),
        optionText = "";
    if (!(attackType || rowValues[prefix + "attack"])) {
        optionText += "{{no_attack_roll=1}}";
    } else if (attackType) {
        attackType = attackType.replace('attk-', '').replace('2', '') || "";
        if (toggleValues['show' + attackType.toLowerCase()]) {
            optionText += optionTemplates[attackType + "_notes"].replace("REPLACE", optionDefaults.notes[attackType]) || "";
        }
    }
    if (toggleValues.showheader_image) {
        optionText += optionTemplates.header_image.replace("REPLACE", optionDefaults.image[attackType || 'melee']) || "";
    }
    if (!(damageAbility || rowValues[prefix + "damage"] || parseInt(rowValues[prefix + "damage-dice-num"], 10) && parseInt(rowValues[prefix + "damage-die"], 10))) {
        optionText += "{{no_damage=1}}";
    }
    if (toggleValues.showattack) {
        optionText += optionTemplates.attack_notes.replace("REPLACE", optionDefaults.notes.attack) || "";
    }
    return optionText;
}
/* resets one row of repeating_weapons
 * note this is almost exactly like resetOption suggesting there is a way to refactor these*/
function resetOption(id, eventInfo, callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAttackOptions.resetOption, rowid: " + id);
        if (typeof callback === "function") {
            callback();
        }
    }),
        prefix = "repeating_weapon_" + SWUtils.getRepeatingIDStr(id),
        rowfields = _underscore2.default.map(repeatingOptionGetAttrs, function (attr) {
        return prefix + attr;
    }),
        allFields = optionToggles;
    allFields = allFields.concat(rowfields);
    //TAS.log("resetOption, fields to get",allFields);
    getAttrs(allFields, function (v) {
        var toggleValues = _underscore2.default.reduce(optionToggles, function (memo, attr) {
            memo['show' + attr.toLowerCase().slice(14).replace('_notes', '')] = parseInt(v[attr], 10) || 0;
            return memo;
        }, {}),
            optionText = "",
            setter = {};
        optionText = getOptionText(prefix, toggleValues, v) || "";
        if (typeof optionText !== "undefined" && optionText !== null) {
            setter[prefix + "macro_options"] = optionText;
        }
        if (_underscore2.default.size(setter) > 0) {
            setAttrs(setter, _PFConst2.default.silentParams, done);
        } else {
            done();
        }
    });
}
function resetSomeOptions(ids, eventInfo, callback) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === 'function') {
            callback();
        }
    });
    if (!(ids && _underscore2.default.size(ids))) {
        done();
        return;
    }
    getAttrs(optionToggles, function (vout) {
        var fields,
            toggleValues = _underscore2.default.reduce(optionToggles, function (memo, attr) {
            memo['show' + attr.toLowerCase().slice(14).replace('_notes', '')] = parseInt(vout[attr], 10) || 0;
            return memo;
        }, {});
        fields = SWUtils.cartesianAppend(["repeating_weapon_"], ids, repeatingOptionGetAttrsLU);
        getAttrs(fields, function (v) {
            var setter = _underscore2.default.reduce(ids, function (memo, id) {
                var prefix = 'repeating_weapon_' + id + '_',
                    tempstr = '';
                try {
                    tempstr = getOptionText(prefix, toggleValues, v);
                    //tempstr= getOptionTextNew(prefix,toggleValues,v)||'';
                    if (tempstr !== v[prefix + 'macro_options']) {
                        memo[prefix + 'macro_options'] = tempstr;
                    }
                } finally {
                    return memo;
                }
            }, {});
            if (_underscore2.default.size(setter)) {
                setAttrs(setter, _PFConst2.default.silentParams, done);
            } else {
                done();
            }
        });
    });
}
/*resetOptions - updates repeating_weapon_ attack _options for all attacks.*/
function resetOptions(callback, eventInfo) {
    getSectionIDs("repeating_weapon", function (ids) {
        resetSomeOptions(ids, eventInfo, callback);
    });
}
function migrate(callback) {
    if (typeof callback === "function") {
        callback();
    }
}
function recalculate(callback) {
    resetOptions(callback);
}
function registerEventHandlers() {
    _underscore2.default.each(optionToggles, function (toggleField) {
        on("change:" + toggleField, _exportsLoaderTASTheAaronSheet2.default.callback(function toggleAttackNoteOption(eventInfo) {
            if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                resetOptions(null, eventInfo);
            }
        }));
    });
    //attack options for one row
    _underscore2.default.each(events.attackOptionEventsAuto, function (fieldToWatch) {
        var eventToWatch = "change:repeating_weapon:" + fieldToWatch;
        on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateAttackTypeOptionSheet(eventInfo) {
            if (eventInfo.sourceType === "sheetworker") {
                _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                resetOption(null, eventInfo);
            }
        }));
    });
    _underscore2.default.each(events.attackOptionEventsPlayer, function (fieldToWatch) {
        var eventToWatch = "change:repeating_weapon:" + fieldToWatch;
        on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateAttackTypeOptionPlayer(eventInfo) {
            if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                resetOption(null, eventInfo);
            }
        }));
    });
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFAttackOptions module loaded  ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.events = exports.defenseArmorFields = exports.defenseFieldTotals = exports.defenseArmorShieldColumns = exports.defenseArmorShieldRows = exports.defenseArmorShieldRowsOld = exports.defenseLowerToMixed = exports.defenseDropdowns = undefined;
exports.updateDefenses = updateDefenses;
exports.setDefenseDropdownMod = setDefenseDropdownMod;
exports.updateArmor = updateArmor;
exports.applyConditions = applyConditions;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFLog = __webpack_require__(0);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFUtilsAsync = __webpack_require__(9);

var PFUtilsAsync = _interopRequireWildcard(_PFUtilsAsync);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defenseDropdowns = exports.defenseDropdowns = {
    "AC-ability": "AC-ability-mod",
    "FF-ability": "FF-DEX",
    "CMD-ability1": "CMD-STR",
    "CMD-ability2": "CMD-DEX",
    "CMD-ability": "FF-CMD-DEX"
},
    defenseLowerToMixed = exports.defenseLowerToMixed = {
    "ac-ability": "AC-ability",
    "ff-ability": "FF-ability",
    "cmd-ability1": "CMD-ability1",
    "cmd-ability2": "CMD-ability2",
    "cmd-ability": "CMD-ability"
},

//reverse order to do worn first:
defenseArmorShieldRowsOld = exports.defenseArmorShieldRowsOld = ["armor3", "armor2", "armor", "shield3", "shield2", "shield"],
    defenseArmorShieldRows = exports.defenseArmorShieldRows = ["armor3", "shield3"],
    defenseArmorShieldColumns = exports.defenseArmorShieldColumns = ["equipped", "acbonus", "enhance", "max-dex", "acp", "spell-fail", "proficiency", "type"],
    defenseFieldTotals = exports.defenseFieldTotals = ["acp", "max-dex", "AC-armor", "AC-shield", "spell-fail", "acp-attack-mod", "max-dex-source", "current-load"],
    defenseArmorFields = exports.defenseArmorFields = SWUtils.cartesianAppend(defenseArmorShieldRows, ['-'], defenseArmorShieldColumns).concat(defenseFieldTotals),
    events = exports.events = {
    defenseEventsAuto: "change:bab change:ac-penalty change:cmd-penalty change:size change:ac-shield change:ac-armor change:ac-ability-mod change:ff-dex change:cmd-dex change:ff-cmd-dex change:cmd-str change:max-dex",
    defenseEventsPlayer: "change:ff-dex change:ac-penalty change:cmd-penalty change:size change:ac-dodge change:ac-natural change:ac-deflect change:ac-misc change:cmd-misc",
    defenseEventsEither: "change:size change:AC-ability change:FF-ability change:CMD-ability1 change:CMD-ability2 change:CMD-ability"
};

/** updateDefenses updates the top grid of AC, Touch AC, Flat Footed AC, CMD, Flat Footed CMD
 * http://paizo.com/pathfinderRPG/prd/coreRulebook/combat.html#combat-maneuver-defense
 * Any penalties to a creature's AC also apply to its CMD
 *@param {function} callback optional call when done
 *@param {boolean} silently optional if true call setAttrs with PFConst.silentParams
 *@param {eventInfo} eventInfo unused eventInfo from on method
 */
function updateDefenses(callback, silently, eventInfo) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFDefense.updateDefenses");
        if (typeof callback === "function") {
            callback();
        }
    });
    getAttrs(["AC-ability-mod", "FF-DEX", "AC-penalty", "CMD-penalty", "size", "max-dex", "AC-dodge", "AC-natural", "AC-deflect", "AC-misc", "buff_AC-total", "buff_Touch-total", "buff_CMD-total", "CMD-DEX", "FF-CMD-DEX", "CMD-STR", "bab", "CMD-misc", "AC", "Touch", "Flat-Footed", "CMD", "FF-CMD", "AC-ability", "FF-ability", "CMD-ability", "CMD-ability1", "CMD-ability2", "AC-armor", "AC-shield", "condition-Blinded", "condition-Pinned", "condition-Stunned", "condition-Cowering", "condition-Drained", "condition-Flat-Footed", "AC-ability-display", "FF-DEX-display", "CMD-DEX-display", "FF-CMD-DEX-display", "maxdex-toggle", "nodex-toggle", "uncanny_dodge", "unlock_def_ability", "hd_not_bab", "level", "buff_armor-total", "buff_shield-total", "buff_flat-footed-total", "buff_natural-total", "current-load", "max-dex-source"], function (v) {
        var size = parseInt(v["size"], 10) || 0,
            dodge = parseInt(v["AC-dodge"], 10) || 0,
            deflect = parseInt(v["AC-deflect"], 10) || 0,
            miscAC = parseInt(v["AC-misc"], 10) || 0,
            condPenalty = parseInt(v["AC-penalty"], 10) || 0,
            buffs = parseInt(v["buff_AC-total"], 10) || 0,
            buffsTouch = parseInt(v["buff_Touch-total"], 10) || 0,
            buffsCMD = parseInt(v["buff_CMD-total"], 10) || 0,
            armor = parseInt(v["AC-armor"], 10) || 0,
            shield = parseInt(v["AC-shield"], 10) || 0,
            natural = parseInt(v["AC-natural"], 10) || 0,
            bab = parseInt(v["bab"], 10) || 0,
            miscCMD = parseInt(v["CMD-misc"], 10) || 0,
            maxDex = parseInt(v["max-dex"], 10),
            cmdPenalty = parseInt(v["CMD-penalty"], 10) || 0,
            blinded = parseInt(v["condition-Blinded"], 10) || 0 ? 1 : 0,
            pinned = parseInt(v["condition-Pinned"], 10) || 0 ? 1 : 0,
            stunned = parseInt(v["condition-Stunned"], 10) || 0 ? 1 : 0,
            ffed = parseInt(v["condition-Flat-Footed"], 10) || 0 ? 1 : 0,
            cowering = parseInt(v["condition-Cowering"], 10) || 0 ? 1 : 0,
            maxDexSource = parseInt(v["max-dex-source"], 10) || 0,
            currload = parseInt(v["current-load"], 10) || 0,
            dexModShowLimit = 0,
            currDexModLimit = parseInt(v["maxdex-toggle"], 10) || 0,
            noDexShowLimit = 0,
            currNoDexLimit = parseInt(v["nodex-toggle"], 10) || 0,
            unlockDefAbility = parseInt(v.unlock_def_ability, 10) || 0,
            lockDefAbility = unlockDefAbility ? 0 : 1,
            tempint = 0,
            ac = 10,
            touch = 10,
            ff = 10,
            cmd = 10,
            cmdFF = 10,
            currAC = parseInt(v["AC"], 10),
            currTouch = parseInt(v["Touch"], 10),
            currFF = parseInt(v["Flat-Footed"], 10),
            currCMD = parseInt(v["CMD"], 10),
            currCMDFF = parseInt(v["FF-CMD"], 10),
            currUncanny = parseInt(v["uncanny_dodge"], 10) || 0,
            currCMDUncanny = lockDefAbility ? currUncanny : parseInt(v["uncanny_cmd_dodge"], 10) || 0,
            acAbilityName = PFUtils.findAbilityInString(v["AC-ability"]),
            uncannyAbilityName = currUncanny ? acAbilityName : PFUtils.findAbilityInString(v["FF-ability"]),
            uncannyCMDabilityName = lockDefAbility ? uncannyAbilityName : PFUtils.findAbilityInString(v["CMD-ability"]),
            cmdAbilityDDvalName = lockDefAbility ? acAbilityName : PFUtils.findAbilityInString(v["CMD-ability2"]),
            ability = parseInt(v["AC-ability-mod"], 10) || 0,
            ffAbility = currUncanny && lockDefAbility ? ability : parseInt(v["FF-DEX"], 10) || 0,
            cmdAbility1 = parseInt(v["CMD-STR"], 10) || 0,
            cmdAbility2 = lockDefAbility ? ability : parseInt(v["CMD-DEX"], 10) || 0,
            cmdFFAbility2 = lockDefAbility ? ffAbility : parseInt(v["FF-CMD-DEX"], 10) || 0,
            loseDex = 0,
            immobilized = 0,
            armorbuff = parseInt(v['buff_armor-total'], 10) || 0,
            shieldbuff = parseInt(v['buff_shield-total'], 10) || 0,
            naturalbuff = parseInt(v['buff_natural-total'], 10) || 0,
            flatfootedbuff = parseInt(v['buff_flat-footed-total'], 10) || 0,
            buffac = 0,
            bufftouch = 0,
            buffff = 0,
            buffffcmd = 0,
            setAny = 0,
            setter = {},
            params = {};
        try {
            //TAS.debug("PFDefense.updateDefenses:",v);
            buffac = buffs + armorbuff + shieldbuff + naturalbuff;
            bufftouch = buffsTouch;
            buffff = buffs + armorbuff + shieldbuff + naturalbuff + flatfootedbuff;
            buffffcmd = buffsCMD + flatfootedbuff;
            //   buffcmd = buffs
            setter.buffsumac = buffac;
            setter.buffsumtouch = bufftouch;
            setter.buffsumff = buffff;
            setter.buffsumffcmd = buffffcmd;
            //TAS.debug(v);
            maxDex = isNaN(maxDex) ? 99 : maxDex; //cannot do "||0" since 0 is falsy but a valid number
            if (acAbilityName === "DEX-mod" && maxDex < 99 && maxDex >= 0) {
                tempint = Math.min(ability, maxDex);
                if (tempint !== ability) {
                    ability = tempint;
                    dexModShowLimit = 1;
                }
            }
            if (uncannyAbilityName === "DEX-mod" && maxDex < 99 && maxDex >= 0) {
                tempint = Math.min(ffAbility, maxDex);
                if (tempint !== ffAbility) {
                    ffAbility = tempint;
                    dexModShowLimit = 1;
                }
            }
            if (cmdAbilityDDvalName === "DEX-mod" && maxDex < 99 && maxDex >= 0) {
                tempint = Math.min(cmdAbility2, maxDex);
                if (tempint !== cmdAbility2) {
                    cmdAbility2 = tempint;
                    dexModShowLimit = 1;
                }
            }
            if (uncannyCMDabilityName === "DEX-mod" && maxDex < 99 && maxDex >= 0) {
                tempint = Math.min(cmdFFAbility2, maxDex);
                if (tempint !== cmdFFAbility2) {
                    cmdFFAbility2 = tempint;
                    dexModShowLimit = 1;
                }
            }

            //if ability is below zero, FF dex adj must be set to negative too
            //assume ffability dropdown should be None or the same as dex ability
            //because if not then it doesn't make sense
            if (ability < 0 && ffAbility > ability) {
                ffAbility = ability;
            }
            if (cmdAbility2 < 0 && cmdFFAbility2 > cmdAbility2) {
                cmdFFAbility2 = cmdAbility2;
            }
            if (unlockDefAbility) {
                if (uncannyAbilityName && currUncanny === 0) {
                    //TAS.debug("switching to uncanny");
                    setter["uncanny_dodge"] = "1";
                    setAny = 1;
                    currUncanny = 1;
                } else if (!uncannyAbilityName && currUncanny === 1) {
                    //TAS.debug("switching from uncanny");
                    setter["uncanny_dodge"] = "0";
                    setAny = 1;
                    currUncanny = 0;
                }
                if (uncannyCMDabilityName && currCMDUncanny === 0) {
                    //TAS.debug("switching to cmd uncanny");
                    setter["uncanny_cmd_dodge"] = "1";
                    setAny = 1;
                    currCMDUncanny = 1;
                } else if (!uncannyCMDabilityName && currCMDUncanny === 1) {
                    //TAS.debug("switching from cmd uncanny");
                    setter["uncanny_cmd_dodge"] = "0";
                    setAny = 1;
                    currCMDUncanny = 0;
                }
            }
            //lose Dex: you lose your bonus (and dodge) - not the same as flat footed
            //Must be applied even if your bonus is not dex :
            //http://paizo.com/paizo/faq/v5748nruor1fm#v5748eaic9qdi
            //flat footed : lose dex unless uncanny
            //blinded: lose dex unless uncanny
            //pinned, cowering, stunned : always lose dex
            if (pinned || cowering || stunned || currload === 4 && (maxDexSource === 0 || maxDexSource === 2)) {
                immobilized = 1;
            } else if (blinded || ffed || currload === 3 && (maxDexSource === 0 || maxDexSource === 2)) {
                loseDex = 1;
            }

            if (immobilized) {
                if (currUncanny) {
                    ffAbility = Math.min(0, ffAbility);
                }
                if (currCMDUncanny) {
                    cmdFFAbility2 = Math.min(0, cmdFFAbility2);
                }
                //dexModShowLimit=1;
                ability = Math.min(0, ability);
                cmdAbility2 = Math.min(0, cmdAbility2);
                dodge = 0;
                noDexShowLimit = 1;
            } else if (loseDex) {
                //TAS.debug("we are blinded or flat footed uncanny:"+currUncanny+", cmd uncan:"+currCMDUncanny);
                if (!currUncanny || !currCMDUncanny) {
                    //dexModShowLimit=1;
                    dodge = 0;
                    noDexShowLimit = 1;
                }
                //set to same as flat footed (probably 0) or less than if ability already under 10.
                ability = Math.min(ability, ffAbility);
                cmdAbility2 = Math.min(cmdAbility2, cmdFFAbility2);
            }
            if (parseInt(v.hd_not_bab, 10)) {
                bab = parseInt(v.level, 10) || 0;
            }
            ac = 10 + armor + shield + natural + size + dodge + ability + deflect + miscAC + condPenalty + buffs + armorbuff + shieldbuff + naturalbuff;
            touch = 10 + size + dodge + ability + deflect + miscAC + condPenalty + buffsTouch;
            ff = 10 + armor + shield + natural + size + ffAbility + deflect + miscAC + condPenalty + buffs + (currUncanny ? dodge : 0) + armorbuff + shieldbuff + naturalbuff + flatfootedbuff;
            cmd = 10 + bab + cmdAbility1 + cmdAbility2 + -1 * size + dodge + deflect + miscCMD + cmdPenalty + buffsCMD;
            cmdFF = 10 + bab + cmdAbility1 + cmdFFAbility2 + -1 * size + deflect + miscCMD + cmdPenalty + buffsCMD + (currCMDUncanny ? dodge : 0) + flatfootedbuff;
            if (ac !== currAC || isNaN(currAC)) {
                setter["AC"] = ac;
                setAny += 1;
            }
            if (touch !== currTouch || isNaN(currTouch)) {
                setter["Touch"] = touch;
                setAny += 1;
            }
            if (ff !== currFF || isNaN(currFF)) {
                setter["Flat-Footed"] = ff;
                setAny += 1;
            }
            //TAS.debug("PFDefense.updateDefenses currcmd is :"+ currCMD +", new cmd is:"+ cmd);
            if (cmd !== currCMD || isNaN(currCMD)) {
                setter["CMD"] = cmd;
                setAny += 1;
            }
            if (cmdFF !== currCMDFF || isNaN(currCMDFF)) {
                setter["FF-CMD"] = cmdFF;
                setAny += 1;
            }
            if (ability !== parseInt(v["AC-ability-display"], 10)) {
                setter["AC-ability-display"] = ability;
            }
            if (ffAbility !== parseInt(v["FF-DEX-display"], 10)) {
                setter["FF-DEX-display"] = ffAbility;
            }
            if (cmdAbility2 !== parseInt(v["CMD-DEX-display"], 10)) {
                setter["CMD-DEX-display"] = cmdAbility2;
            }
            if (cmdFFAbility2 !== parseInt(v["FF-CMD-DEX-display"], 10)) {
                setter["FF-CMD-DEX-display"] = cmdFFAbility2;
            }
            if (dexModShowLimit !== currDexModLimit) {
                setter["maxdex-toggle"] = dexModShowLimit;
            }
            if (noDexShowLimit !== currNoDexLimit) {
                setter["nodex-toggle"] = noDexShowLimit;
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFDefense.updateDefenses:", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                setAttrs(setter, params, done);
            } else {
                done();
            }
        }
    });
}
/** setDefenseDropdownMod
 * All dropdowns in the defense grid: AC, flat footed AC, touch, CMD, flat footed CMD.
 * calls handledropdown then calls updateDefenses.
 *
 * NOTE: due to the way eventInfo.sourceAttribute is populated if the change comes from the autocalc code, the value is
 * lower case, so you must check either BOTH the regular and all lowercase, or just change it to lower case before comparing to be sure
 *
 *@param {string} dropdownField fieldname of dropdown to set 
 *@param {function} callback callback
 *@param {boolean} silently if true set silently make sure to call updateDefenses after!
 *@param {object} the eventInfo object USED, this is checked for uncanny_dodge flag 
 *@param {boolean} doNotCallUpdateDefenseAfter if not set call updateDefenses after updating dropdown mod.
 */
function setDefenseDropdownMod(dropdownField, callback, silently, eventInfo, doNotCallUpdateDefenseAfter) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFDefense.setDefenseDropdownMod for " + dropdownField);
        if (typeof callback === "function") {
            callback();
        }
    }),
        updateAndDone = _underscore2.default.once(function () {
        if (!doNotCallUpdateDefenseAfter) {
            updateDefenses(done, silently);
        } else {
            done();
        }
    }),
        dropdownLower = "",
        dropdownMixed = "";
    //TAS.debug"PFDefense.setDefenseDropdownMod called with "+dropdownField +", lower:"+ dropdownLower);
    try {
        if (dropdownField) {
            dropdownLower = dropdownField.toLowerCase();
            dropdownMixed = defenseLowerToMixed[dropdownLower];
            if (dropdownMixed) {
                getAttrs(['unlock_def_ability', 'uncanny_dodge'], function (v) {
                    if (parseInt(v['unlock_def_ability'], 10) || dropdownLower === 'ac-ability' || dropdownLower === 'cmd-ability1') {
                        PFUtilsAsync.setDropdownValue(dropdownMixed, defenseDropdowns[dropdownMixed], function (newv, oldv) {
                            if (newv !== oldv || newv < 0 || oldv < 0 || dropdownLower === "ff-ability" || dropdownLower === "cmd-ability") {
                                updateAndDone();
                            } else {
                                done();
                            }
                        }, silently);
                    } else {
                        done();
                    }
                });
            } else {
                _exportsLoaderTASTheAaronSheet2.default.warn("PFDefense.updateDefenses, called with invalid dropdown: " + dropdownField);
                done();
            }
        } else if (eventInfo && eventInfo.sourceAttribute === 'uncanny_dodge') {
            getAttrs(['unlock_def_ability', 'uncanny_dodge', 'AC-ability', defenseDropdowns['AC-ability']], function (v) {
                var unlockAbilityDD = 0,
                    currACmod = 0,
                    setter = {};
                try {
                    unlockAbilityDD = parseInt(v.unlock_def_ability, 10) || 0;
                    if (unlockAbilityDD) {
                        //TAS.debug("at PFDefense.setDefenseDropdownMod",v);
                        currACmod = parseInt(v['AC-ability'], 10) || 0;
                        //we came here because uncanny dodge was checked
                        if (!parseInt(v.uncanny_dodge, 10)) {
                            //turn uncanny off
                            setter["FF-ability"] = "0";
                            setter[defenseDropdowns["FF-ability"]] = 0;
                            setter["CMD-ability"] = "0";
                            setter[defenseDropdowns["CMD-ability"]] = 0;
                        } else {
                            //turned uncanny on
                            //TAS.debug("set FF_ability to " +v['AC-ability'] );
                            setter["FF-ability"] = v['AC-ability'];
                            setter[defenseDropdowns["FF-ability"]] = currACmod;
                            setter["CMD-ability"] = v['AC-ability'];
                            setter[defenseDropdowns["CMD-ability"]] = currACmod;
                        }
                        setAttrs(setter, _PFConst2.default.silentParams, updateAndDone);
                    } else {
                        updateAndDone();
                    }
                } catch (err2) {
                    _exportsLoaderTASTheAaronSheet2.default.error("PFDefense.setDefenseDropdownMod inner error for : " + dropdownField, err2);
                    done();
                }
            });
        }
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFDefense.setDefenseDropdownMod error for: " + dropdownField, err);
        done();
    }
}
/** updates total AC and penalty and max dex
 * if not proficient sets attack penalty
 * for backward compatibility, proficiency is string and 0 is proficient, anything else non proficient
 *@param {function} callback optional call when done
 *@param {boolean} silently optional if true call setAttrs with PFConst.silentParams
 *@param {eventInfo} eventInfo unused eventInfo from on method
 */
function updateArmor(callback, silently, eventInfo) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    },
        params = {};
    getAttrs(defenseArmorFields, function (v) {
        var acp = 0,
            minAcp = 0,
            acA = 0,
            acS = 0,
            sp = 0,
            atk = 0,
            subAC = 0,
            subD = 0,
            subAcp = 0,
            nonProf = 0,
            subsp = 0,
            maxDex = 99,
            subE = 0,
            currACP = 0,
            currMaxDex = 99,
            currACArmor = 0,
            currACShield = 0,
            currSpellFail = 0,
            currAtkMod = 0,
            encumbranceDD = parseInt(v["max-dex-source"], 10) || 0,
            currentLoad = parseInt(v["current-load"], 10) || 0,
            setter = {};
        try {
            //TAS.debug("at updateArmor ",v);
            defenseArmorShieldRows.forEach(function (row) {
                if (parseInt(v[row + "-equipped"], 10) === 1) {
                    subAC = parseInt(v[row + "-acbonus"], 10) || 0;
                    subE = parseInt(v[row + "-enhance"], 10) || 0;
                    subsp = parseInt(v[row + "-spell-fail"], 10) || 0;
                    sp += subsp;
                    if (row.indexOf("armor") >= 0) {
                        acA += subAC + subE;
                    } else {
                        acS += subAC + subE;
                    }
                    subAcp = parseInt(v[row + "-acp"], 10) || 0;
                    if (encumbranceDD < 2) {
                        subD = parseInt(v[row + "-max-dex"], 10);
                        if (v[row + "-max-dex"] === "-" || isNaN(subD)) {
                            subD = 99;
                        }
                        maxDex = Math.min(subD, maxDex);
                        acp += subAcp;
                    }
                    nonProf = parseInt(v[row + "-proficiency"], 10) || 0;
                    if (nonProf) {
                        atk += subAcp;
                    }
                    if (/tower/i.test(v[row + "-type"])) {
                        atk -= 2;
                    }
                    //TAS.debug("row=" + row + ", subAC=" + subAC + ", subD=" + subD + ", subAcp=" + subAcp + ", nonProf=" + nonProf + ", subsp=" + subsp + ", acA=" + acA + ", maxDex=" + maxDex + ", acp=" + acp + ", sp=" + sp + ", atk=" + atk);
                }
            });
            minAcp = acp;
            // #0: Armor, Shield & Load
            // #1: Armor & Shield only
            // #2: Load only
            // #3: None
            if (encumbranceDD === 0 || encumbranceDD === 2) {
                if (currentLoad === 1) {
                    // under medium encumbrance load
                    maxDex = Math.min(maxDex, 3);
                    minAcp = Math.min(minAcp, -3);
                } else if (currentLoad === 2) {
                    // under heavy encumbrance load
                    maxDex = Math.min(maxDex, 1);
                    minAcp = Math.min(minAcp, -6);
                } else if (currentLoad > 2) {
                    maxDex = 0;
                    minAcp = Math.min(minAcp, -6);
                }
            }

            currACP = parseInt(v.acp, 10) || 0;
            currMaxDex = parseInt(v["max-dex"], 10); //cannot do "||0" since 0 is valid but falsy
            currMaxDex = isNaN(currMaxDex) ? 99 : currMaxDex;
            currACArmor = parseInt(v["AC-armor"], 10) || 0;
            currACShield = parseInt(v["AC-shield"], 10) || 0;
            currSpellFail = parseInt(v["spell-fail"], 10) || 0;
            currAtkMod = parseInt(v["acp-attack-mod"], 10) || 0;
            if (currACP !== minAcp) {
                setter["acp"] = minAcp;
            }
            if (currMaxDex !== maxDex) {
                setter["max-dex"] = maxDex;
            }
            if (currACArmor !== acA) {
                setter["AC-armor"] = acA;
            }
            if (currACShield !== acS) {
                setter["AC-shield"] = acS;
            }
            if (currSpellFail !== sp) {
                setter["spell-fail"] = sp;
            }
            if (currAtkMod !== atk) {
                setter["acp-attack-mod"] = atk;
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFDefense.updateArmor", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                setAttrs(setter, params, done);
            } else {
                done();
            }
        }
    });
}
/** applyConditions Updates the AC-penalty and CMD-penalty field based on conditions
 *only difference is CMD penalty affected by energy drain for some reason
 *@param {function} callback optional call when done
 *@param {boolean} silently optional if true call setAttrs with PFConst.silentParams
 *@param {eventInfo} eventInfo unused eventInfo from on method
 */
function applyConditions(callback, silently, eventInfo) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFDefense.applyConditions");
        if (typeof callback === "function") {
            callback();
        }
    });
    getAttrs(["AC-penalty", "CMD-penalty", "condition-Blinded", "condition-Cowering", "condition-Stunned", "condition-Pinned", "condition-Wounds", "condition-Drained", "has_endurance_feat", "wounds_gritty_mode"], function (v) {
        var subTotPenalty = 0,
            drained = 0,
            woundLevel = 0,
            AC = 0,
            CMD = 0,
            newCMD = 0,
            woundPenalty = 0,
            hasEndurance = 0,
            grittyMode = 0,
            setter = {},
            params = {};
        try {
            drained = parseInt(v["condition-Drained"], 10) || 0;
            woundLevel = parseInt(v["condition-Wounds"], 10) || 0;
            AC = parseInt(v["AC-penalty"], 10) || 0;
            CMD = parseInt(v["CMD-penalty"], 10) || 0;
            hasEndurance = parseInt(v.has_endurance_feat, 10) || 0;
            grittyMode = parseInt(v.wounds_gritty_mode, 10) || 0;
            woundPenalty = PFUtils.getWoundPenalty(woundLevel, hasEndurance, grittyMode);
            subTotPenalty = -1 * ((parseInt(v["condition-Blinded"], 10) || 0) + (parseInt(v["condition-Pinned"], 10) || 0) + (parseInt(v["condition-Cowering"], 10) || 0) + (parseInt(v["condition-Stunned"], 10) || 0));
            subTotPenalty += woundPenalty;
            newCMD = drained + subTotPenalty;
            if (AC !== subTotPenalty) {
                setter["AC-penalty"] = subTotPenalty;
            }
            if (CMD !== newCMD) {
                setter["CMD-penalty"] = newCMD;
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFDefense.applyConditions:", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                setAttrs(setter, params, done);
            } else {
                done();
            }
        }
    });
}

/** migrate from old versions
 * @param {function} callback guaranteed call when done
 * @param {number} oldversion 
 */
function migrate(callback, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFDefense.migrate");
        if (typeof callback === "function") {
            callback();
        }
    });
    if (oldversion > 0 && oldversion < 0.50) {
        PFMigrate.migrateMaxDexAndACP();
    }
    if (oldversion > 0 && oldversion < 1.20) {
        getAttrs(['CMD-ability2', 'unlock_def_ability', 'AC-ability'], function (v) {
            var ac = '',
                cmd = '',
                configflag = 0,
                setter = {};
            try {
                ac = PFUtils.findAbilityInString(v['AC-ability']);
                cmd = PFUtils.findAbilityInString(v['CMD-ability2']);
                configflag = parseInt(v.unlock_def_ability, 10) || 0;
                if (ac && cmd && ac !== cmd && !configflag) {
                    setter.unlock_def_ability = 1;
                } else if (configflag) {
                    setter.unlock_def_ability = 0;
                }
            } catch (err) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFDefense.migrate", err);
            } finally {
                if (_underscore2.default.size(setter) > 0) {
                    setAttrs(setter, _PFConst2.default.silentParams, done);
                } else {
                    done();
                }
            }
        });
    } else {
        done();
    }
}

/** recalculate defense grid
 * @param {function} callback guaranteed call when done
 * @param {boolean} silently optional if true call setAttrs with PFConst.silentParams
 * @param {number} oldversion 
 */
function recalculate(callback, silently, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFDefense.recalculate");
        if (typeof callback === "function") {
            callback();
        }
    }),
        numDropdowns = _underscore2.default.size(defenseDropdowns),
        doneOneDefenseDropdown = _underscore2.default.after(numDropdowns, function () {
        updateDefenses(done, true);
    });

    migrate(function () {
        applyConditions(function () {
            updateArmor(function () {
                _underscore2.default.each(defenseDropdowns, function (value, key) {
                    setDefenseDropdownMod(key, doneOneDefenseDropdown, true, null, true);
                });
            }, silently);
        }, silently);
    }, silently);
}

function registerEventHandlers() {
    _underscore2.default.each(defenseDropdowns, function (write, read) {
        on("change:" + read, _exportsLoaderTASTheAaronSheet2.default.callback(function eventsetDefenseDropdownMod(eventInfo) {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            setDefenseDropdownMod(read, null, null, eventInfo);
        }));
    });
    on("change:uncanny_dodge", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUncannyDodgeUpdate(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            setDefenseDropdownMod(null, null, null, eventInfo);
        }
    }));
    on("change:hd_not_bab", _exportsLoaderTASTheAaronSheet2.default.callback(function eventCMDSwitchHDandBAB(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            updateDefenses(null, null, eventInfo);
        }
    }));
    on(events.defenseEventsAuto, _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateDefensesAuto(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "sheetworker") {
            updateDefenses(null, null, eventInfo);
        }
    }));
    on(events.defenseEventsPlayer, _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateDefensesPlayer(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            updateDefenses(null, null, eventInfo);
        }
    }));
    on(events.defenseEventsEither, _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateDefensesEither(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        updateDefenses(null, null, eventInfo);
    }));
    on("change:max-dex-source change:current-load", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateArmor(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        updateArmor(null, null, eventInfo);
    }));
    _underscore2.default.each(defenseArmorShieldRows, function (row) {
        _underscore2.default.each(defenseArmorShieldColumns, function (column) {
            var eventToWatch = "change:" + row + "-" + column;
            on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateDefenseArmorShield(eventInfo) {
                _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                updateArmor(null, null, eventInfo);
            }));
        });
    });
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFDefense module loaded        ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getRepeatingCommandMacro = getRepeatingCommandMacro;
exports.resetOneCommandMacro = resetOneCommandMacro;
exports.resetOneCommandMacroNoNPC = resetOneCommandMacroNoNPC;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFLog = __webpack_require__(0);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var menuMap = {
    'class-ability': { 'name': 'original-class-features-list', 'section': 'class-ability', 'useshowinmenu': 1 },
    'feat': { 'npcMacroName': 'NPC-feat', 'npcName': ' ^{npc} ', 'name': 'original-feats-list', 'section': 'feat', 'npcLinkField': 'npc-roll', 'useshowinmenu': 1 },
    'racial-trait': { 'npcMacroName': 'NPC-racial-trait', 'npcName': ' ^{npc} ', 'name': 'original-racial-traits-list', 'section': 'racial-trait', 'npcLinkField': 'npc-roll', 'useshowinmenu': 1 },
    'trait': { 'name': 'original-traits-list', 'section': 'trait', 'useshowinmenu': 1 },
    'mythic-ability': { 'name': 'mythic-abilities', 'section': 'mythic-ability', 'useshowinmenu': 1 },
    'mythic-feat': { 'name': 'mythic-feats', 'section': 'mythic-feat', 'useshowinmenu': 1 },
    'npc-spell-like-abilities': { 'name': 'original-spell-like-abilities-list', 'section': 'npc-spell-like-abilities', 'useshowinmenu': 1 },
    'ability': { 'npcMacroName': 'NPC-ability', 'npcName': ' ^{npc} ', 'name': 'abilities', 'section': 'ability', 'groupBy': 'rule_category', 'translateGroup': 1, 'npcLinkField': 'npc-roll', 'useshowinmenu': 1 },
    'ex': { 'npcMacroName': 'NPC-ex', 'npcName': ' ^{npc} ', 'name': 'extraordinary-abilities-menu', 'section': 'ability', 'filterField': 'ability_type', 'filterValue': 'Ex', 'groupBy': 'frequency', 'translateGroup': 1, 'altUsesField': 'rounds_between', 'npcLinkField': 'npc-roll', 'useshowinmenu': 1 },
    'sp': { 'npcMacroName': 'NPC-sp', 'npcName': ' ^{npc} ', 'name': 'spell-like-abilities-menu', 'section': 'ability', 'filterField': 'ability_type', 'filterValue': 'Sp', 'groupBy': 'frequency', 'translateGroup': 1, 'altUsesField': 'rounds_between', 'npcLinkField': 'npc-roll', 'useshowinmenu': 1 },
    'su': { 'npcMacroName': 'NPC-su', 'npcName': ' ^{npc} ', 'name': 'supernatural-abilities-menu', 'section': 'ability', 'filterField': 'ability_type', 'filterValue': 'Su', 'groupBy': 'frequency', 'translateGroup': 1, 'altUsesField': 'rounds_between', 'npcLinkField': 'npc-roll', 'useshowinmenu': 1 },
    'item': { 'npcMacroName': 'NPC-item', 'npcName': ' ^{npc} ', 'name': 'items', 'section': 'item', 'usesField': '', 'bonusField': '', 'groupBy': 'equip-type', 'translateGroup': 1, 'npcLinkField': 'npc-roll', 'useshowinmenu': 1 },
    'attacks': { 'macroSuffix': '-macro', 'npcMacroSuffix': '-macro-npc', 'npcName': ' ^{npc} ', 'section': 'weapon', 'name': 'attacks', 'usesField': '', 'bonusField': '', 'groupBy': 'attack-type', 'altGroupBy': 'group', 'translateGroup': 1, 'npcLinkField': 'attack-npc-roll', 'linkField': 'attack-roll' }
};

/** creates a command macro button for a repeating section
 * it also extends to add old lists using "extendbysections"
 * @param {jsmap} baseAttribs object of schema:
 *  name:string ex:'abilities',
 *  template:string ex:'pf_generic',
 *  header:string ex:'header_image-pf_generic',
 *  section:string the name after 'repeating_' e.g. weapon,item, spells, etc
 *  bonusField:string bonus attr to add at the end of the name attr of each row, put into parenthesis, such as Burning Hands (Sp),
 *  usesField:string used or attr name with |max if instead to print uses/max,
 *  nameField:string name of header of menu written to {{#name}}
 *  linkField:string the attr of the roll button 'roll'
 *  npclinkField:string if necessary, different link field to use if the char is an NPC
 *  filterField:string optional attr to pass to _.filter or _.pick , if 1 then display, if 0 then don't , ex:'showinmenu'
 *  filterValue:string if filter should be custom (not 1/0) then fill in value ex: 'Sp', cannot be '0' (zero)
 *  groupByField:string optional name of attr to group by
 *  translateGroup: if ^{} should be placed around groupby field value
 *  translateBonus: if ^{} should be placed around bonus field value
 *  groupMap:{key:string,key:string} if instead of grouping by the groupField itself, pass the value to a map and group by the result.
 * @param {function(string)} callback Pass string for command macro as first param, or ""
 */
function getRepeatingCommandMacro(baseAttribs, callback, header) {
    var done = function done(macro) {
        if (typeof callback === "function") {
            callback(macro);
        }
    },
        defaultTemplate = "pf_block",
        defaultHeader = "header_image-pf_block",
        defaultName = "ability-menus",
        nameField = "name",
        bonusField = "",
        usesField = "",
        altUsesField = "",
        groupByField = "",
        altGroupByField = "",
        linkField = "roll",
        filterField = "",
        filterValue = "",
        baseMacro = "&{template:REPLACETEMPLATE} @{toggle_attack_accessible} @{toggle_rounded_flag}{{color=@{rolltemplate_color}}} {{header_image=@{REPLACEHEADER}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle=REPLACESUBTITLE}} {{name=REPLACENPC^{REPLACENAME}}}",
        baseCommand = " [ REPLACEBUTTON ](~@{character_id}|REPLACELINK)",
        noRows = " {{description=^{none-available} }}";
    if (!baseAttribs || !baseAttribs.section || !baseAttribs.linkField) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFMenus.getRepeatingCommandMacro cannot process", baseAttribs);
        done("");
        return;
    }
    try {
        header = header || "";
        baseMacro = baseMacro.replace('REPLACETEMPLATE', baseAttribs.template || defaultTemplate);
        baseMacro = baseMacro.replace('REPLACEHEADER', baseAttribs.header || defaultHeader);
        baseMacro = baseMacro.replace('REPLACENAME', baseAttribs.name || defaultName);
        baseMacro = baseMacro.replace('REPLACESUBTITLE', '');
        baseMacro = baseMacro.replace(/REPLACENPC/g, baseAttribs.npcName || '');
        baseMacro += header;
        nameField = baseAttribs.nameField || nameField;
        bonusField = baseAttribs.bonusField || bonusField;
        usesField = baseAttribs.usesField || usesField;
        linkField = baseAttribs.linkField || linkField;
        groupByField = baseAttribs.groupBy || groupByField;
        filterField = baseAttribs.filterField || filterField;
        altUsesField = baseAttribs.altUsesField || altUsesField;
        altGroupByField = baseAttribs.altGroupBy || '';
        // TAS.debug("PFMenus.getRepeatingCommandMacro attribs, menu so far:",baseAttribs,baseMacro);
    } catch (outerErr) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFMenus.getRepeatingCommandMacro outererror for " + baseAttribs.section, outerErr);
        done("");
        return;
    }
    getSectionIDs("repeating_" + baseAttribs.section, function (ids) {
        var fields = [],
            prefix = "repeating_" + baseAttribs.section + "_";
        try {
            if (!ids || _underscore2.default.size(ids) <= 0) {
                done(baseMacro + noRows);
                return;
            }
            _underscore2.default.each(ids, function (id) {
                var linePrefix = prefix + id + "_";
                fields.push(linePrefix + nameField);
                if (baseAttribs.useshowinmenu) {
                    fields.push(linePrefix + 'showinmenu');
                }
                if (altGroupByField) {
                    fields.push(linePrefix + altGroupByField);
                }
                if (bonusField) {
                    fields.push(linePrefix + bonusField);
                }
                if (usesField) {
                    fields.push(linePrefix + usesField);
                    fields.push(linePrefix + usesField + "_max");
                }
                if (filterField) {
                    fields.push(linePrefix + filterField);
                }
                if (groupByField) {
                    fields.push(linePrefix + groupByField);
                }
                if (altUsesField) {
                    fields.push(linePrefix + altUsesField);
                }
            });
        } catch (outerError2) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFMenus.getRepeatingCommandMacro outererror 2 assembling all attrs in rows for " + baseAttribs.section, outerError2);
            done("");
            return;
        }
        fields.push('_reporder_repeating_' + baseAttribs.section);
        getAttrs(fields, function (v) {
            var restOfMacro = "",
                totalMacro = "",
                orderedList,
                repList,
                customSorted = 0,
                rowCounter = 20;
            try {
                //TAS.debug('PFMenus.getRepeatingCommandMacro returned with',v);
                if (v['_reporder_repeating_' + baseAttribs.section]) {
                    repList = v['_reporder_repeating_' + baseAttribs.section].split(",");
                    repList = _underscore2.default.map(repList, function (ID) {
                        return ID.toLowerCase();
                    });
                    orderedList = _underscore2.default.intersection(_underscore2.default.union(repList, ids), ids);
                    customSorted = 1;
                } else {
                    orderedList = ids;
                }
                restOfMacro = _underscore2.default.chain(orderedList).map(function (id) {
                    var linePrefix = prefix + id + '_',
                        buttonName = '',
                        bonus = '',
                        uses = '',
                        max = '',
                        usesStr = '',
                        tempshow = 0,
                        retObj = {
                        'id': id,
                        'name': v[linePrefix + 'name'] || id,
                        'showinmenu': 1
                    };
                    try {
                        if (usesField) {
                            uses = v[linePrefix + usesField] || '';
                            max = v[linePrefix + usesField + "_max"] || '';
                        }
                        if (altGroupByField && v[linePrefix + altGroupByField]) {
                            retObj.group = v[linePrefix + altGroupByField];
                            retObj.doNotTranslate = true;
                        } else if (groupByField && v[linePrefix + groupByField]) {
                            if (baseAttribs.groupMap) {
                                if (baseAttribs.groupMap[v[linePrefix + groupByField]]) {
                                    retObj.group = baseAttribs.groupMap[v[linePrefix + groupByField]];
                                } else {
                                    retObj.group = 'AAAAAA';
                                }
                            } else if (groupByField === 'frequency') {
                                switch (v[linePrefix + groupByField]) {
                                    case 'perday':
                                        retObj.group = '';
                                        if (max) {
                                            retObj.group = max + ' ';
                                        }
                                        retObj.group += (baseAttribs.translateGroup ? '^{' : '') + v[linePrefix + groupByField] + (baseAttribs.translateGroup ? '}' : '');
                                        retObj.doNotTranslate = 1;
                                        break;
                                    case 'not-applicable':
                                        retObj.group = 'AAAAAA';
                                        uses = 0;
                                        max = 0;
                                        break;
                                    case 'constant':
                                    case 'atwill':
                                        retObj.group = v[linePrefix + groupByField];
                                        uses = 0;
                                        max = 0;
                                        break;
                                    case 'hexfreq':
                                    case 'other':
                                        retObj.group = v[linePrefix + groupByField];
                                        break;
                                    case 'everyrounds':
                                        retObj.group = v[linePrefix + groupByField];
                                        if (v[linePrefix + altUsesField]) {
                                            uses = v[linePrefix + altUsesField];
                                            max = 0;
                                        }
                                        break;
                                    default:
                                        retObj.group = v[linePrefix + groupByField];
                                        break;
                                }
                            } else {
                                retObj.group = v[linePrefix + groupByField];
                            }
                        } else {
                            retObj.group = 'AAAAAA';
                        }
                        if (retObj.group !== 'AAAAAA' && baseAttribs.translateGroup && !retObj.doNotTranslate) {
                            retObj.group = '^{' + retObj.group + '}';
                        }
                        if (usesField) {
                            if (uses && max) {
                                usesStr = ' (' + uses + '/' + max + ')';
                            } else if (uses) {
                                usesStr = ' (' + uses + ')';
                            }
                        }
                        if (filterField) {
                            if (baseAttribs.filterValue) {
                                if (String(v[linePrefix + filterField]) === String(baseAttribs.filterValue)) {
                                    retObj.showinmenu = 1;
                                } else {
                                    retObj.showinmenu = 0;
                                }
                            } else {
                                retObj.showinmenu = parseInt(v[linePrefix + filterField], 10) || 0;
                            }
                        } else {
                            retObj.showinmenu = 1;
                        }
                        if (retObj.filterField !== 'showinmenu' && baseAttribs.useshowinmenu) {
                            tempshow = parseInt(v[linePrefix + 'showinmenu'], 10) || 0;
                            retObj.showinmenu = retObj.showinmenu && tempshow;
                        }
                        if (bonusField && v[linePrefix + bonusField] && v[linePrefix + bonusField] !== 'not-applicable') {
                            bonus = ' (' + (baseAttribs.translateBonus ? '^{' : '') + v[linePrefix + bonusField] + (baseAttribs.translateBonus ? '}' : '') + ')';
                        }
                        buttonName = retObj.name + bonus + usesStr;
                        retObj.chatLink = '[' + SWUtils.escapeForRollTemplate(SWUtils.escapeForChatLinkButton(buttonName)) + '](~@{character_id}|' + linePrefix + linkField + ')';
                    } catch (builderr) {
                        _exportsLoaderTASTheAaronSheet2.default.error("PFMenus.getRepeatingCommandMacro builderr object for id " + id, builderr);
                    } finally {
                        return retObj;
                    }
                }).filter(function (o) {
                    return o.showinmenu;
                }).sortBy('group');
                if (groupByField === 'frequency') {
                    restOfMacro = restOfMacro.reverse();
                }
                restOfMacro = restOfMacro.groupBy('group').reduce(function (m, rowList, groupName) {
                    var restOflink = '';
                    try {
                        if (groupName !== 'AAAAAA' && _underscore2.default.size(rowList) > 0) {
                            m += ' {{row' + String(rowCounter) + '=' + SWUtils.escapeForRollTemplate(groupName) + '}}';
                            rowCounter++;
                        }
                        restOflink = _underscore2.default.reduce(rowList, function (mi, o) {
                            mi += ' ' + o.chatLink;
                            return mi;
                        }, ' {{row' + String(rowCounter) + '=');
                        m += restOflink + '}}';
                        rowCounter++;
                    } catch (strerror) {
                        _exportsLoaderTASTheAaronSheet2.default.error("PFMenus.getRepeatingCommandMacro strerror creating string for group " + groupName, strerror);
                    } finally {
                        return m;
                    }
                }, "").value();
            } catch (innererror2) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFMenus.getRepeatingCommandMacro innererror2 for " + baseAttribs.section, innererror2);
            } finally {
                if (restOfMacro) {
                    totalMacro = baseMacro + restOfMacro;
                } else {
                    totalMacro = baseMacro + noRows;
                }
                done(totalMacro);
            }
        });
    });
}
/**resetOneCommandMacro sets command button macro with all rows from one ability list.
 * calls PFMenus.getRepeatingCommandMacro
 * sets the returned string to macro with attribute name: section+"_buttons_macro"
 *@param {string} section name after "repeating_"
 *@param {boolean} isNPC  true if npc false or not needed otherwise.
 *@param {function} callback  when done
 */
function resetOneCommandMacro(menuName, isNPC, callback, header, groupMap) {
    var done = _underscore2.default.once(function () {
        //TAS.debug("leaving PFMenus.resetOneCommandMacro: " + menuName);
        if (typeof callback === "function") {
            callback();
        }
    }),
        params = {},
        macroName = menuName;
    try {
        //this is here because putting it above cloning was not working, 
        //so this makes sure new instance gets created each time
        params = {
            'usesField': 'used',
            'linkField': 'roll',
            'nameField': 'name',
            'bonusField': 'ability_type',
            'translateBonus': 1,
            'macroSuffix': '_buttons_macro'
        };
        if (menuMap[menuName]) {
            params = _underscore2.default.extend(params, menuMap[menuName]);
            if (isNPC) {
                if (menuMap[menuName].npcLinkField) {
                    params.linkField = menuMap[menuName].npcLinkField;
                }
                if (menuMap[menuName].npcMacroName) {
                    macroName = menuMap[menuName].npcMacroName;
                }
                if (menuMap[menuName].npcMacroSuffix) {
                    params.macroSuffix = menuMap[menuName].npcMacroSuffix;
                }
            } else {
                if (params.npcName) {
                    params.npcName = '';
                }
            }
        } else {
            _exportsLoaderTASTheAaronSheet2.default.error("PFMenus.resetOneCommandMacro Could not find parameters for menu " + menuName);
            done();
            return;
        }
        if (groupMap && params.groupBy) {
            params.groupMap = groupMap;
        }
        //TAS.debug("PFMenus.resetOneCommandMacro getting rollmenu for "+menuName,params);
        getRepeatingCommandMacro(params, function (newMacro) {
            var setter = {};
            //TAS.debug("PFMenus.resetOneCommandMacro returned with "+menuName+", writing to "+macroName + params.macroSuffix,newMacro);
            setter[macroName + params.macroSuffix] = newMacro || "";
            setAttrs(setter, _PFConst2.default.silentParams, done);
        }, header);
    } catch (errouter) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFMenus.resetOnceCommandMacro, errouter :", errouter);
    }
}
/** same as resetOneCommandMacro if you do not know the npc status 
 *@param {string} section name after "repeating_"
 *@param {function} callback  when done
 */
function resetOneCommandMacroNoNPC(section, callback, header) {
    getAttrs(['is_npc'], function (v) {
        resetOneCommandMacro(section, parseInt(v.is_npc, 10) || 0, callback, header);
    });
}

_PFLog.PFConsole.log('   PFMenus module loaded          ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.reverseSizeNameMap = exports.sizeNameMap = exports.skillSizeMap = exports.reverseSizeMap = exports.sizeModToEasySizeMap = undefined;
exports.getSizeFromText = getSizeFromText;
exports.getSizeLevelChange = getSizeLevelChange;
exports.updateDamageDice = updateDamageDice;
exports.updateSize = updateSize;
exports.updateSizeAsync = updateSizeAsync;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

var _PFEncumbrance = __webpack_require__(20);

var PFEncumbrance = _interopRequireWildcard(_PFEncumbrance);

var _PFAttacks = __webpack_require__(8);

var PFAttacks = _interopRequireWildcard(_PFAttacks);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sizeModToEasySizeMap = exports.sizeModToEasySizeMap = {
	'0': 4,
	'1': 3,
	'2': 2,
	'-8': 8,
	'4': 1,
	'-4': 7,
	'-2': 6,
	'-1': 5,
	'8': 0
},
    reverseSizeMap = exports.reverseSizeMap = {
	'0': 8,
	'1': 4,
	'2': 2,
	'3': 1,
	'4': 0,
	'5': -1,
	'6': -2,
	'7': -4,
	'8': -8
},
    skillSizeMap = exports.skillSizeMap = {
	'0': 0,
	'1': 2,
	'2': 4,
	'8': 8,
	'4': 6,
	'-8': -8,
	'-4': -6,
	'-2': -4,
	'-1': -2
},
    sizeNameMap = exports.sizeNameMap = {
	'colossal': -8,
	'gargantuan': -4,
	'huge': -2,
	'large': -1,
	'medium': 0,
	'small': 1,
	'tiny': 2,
	'diminutive': 4,
	'fine': 8
},
    reverseSizeNameMap = exports.reverseSizeNameMap = {
	'0': 'medium',
	'1': 'small',
	'2': 'tiny',
	'-8': 'colossal',
	'4': 'diminutive',
	'-4': 'gargantuan',
	'-2': 'huge',
	'-1': 'large',
	'8': 'fine'
};

/** getSizeFromText - returns size mod based on size display name
 * @param {string} sizeDisplay size in english (medium, large, gargantuan, tiny, etc)
 * @returns {jsobj} map of {"size":size mod for AC,"skillSize": size mod for fly}
 */
function getSizeFromText(sizeDisplay) {
	var sizeMap = {
		"size": 0,
		"skillSize": 0
	};
	try {
		if (sizeDisplay) {
			sizeDisplay = SWUtils.trimBoth(sizeDisplay);
			sizeDisplay = sizeDisplay.toLowerCase();
			sizeMap.size = sizeNameMap[sizeDisplay];
			sizeMap.skillSize = skillSizeMap[String(sizeMap.size)];
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("get size from text:" + sizeDisplay, err);
		sizeMap.size = 0;
		sizeMap.skillSize = 0;
	} finally {
		return sizeMap;
	}
}
/**returns number of levels size went up or down
 * ex: Med to Lg is +1, Med to Sm is -1, Md to Tiny is -2, etc
 * @param {int} currSize new size mod , usually value of @{size}
 * @param {int} defaultSize default size mod, for sheet it is value of @{default_char_size}
 * 		  for weapon it is @{repeating_weapon_$X_default_size}
 * @returns {int} difference in sizes (not difference in size mods)
 */
function getSizeLevelChange(currSize, defaultSize) {
	var newSize, oldSize, levelChange;
	newSize = sizeModToEasySizeMap[String(currSize)];
	oldSize = sizeModToEasySizeMap[String(defaultSize)];
	levelChange = newSize - oldSize;
	return levelChange;
}
/**updateDamageDice returns new dice for weapon/attack damage change due to size
 *@param {Number} sizediff difference in LEVELS of size (Medium to Large is 1, Medium to Small is -1)
 *@param {Number} defaultSize size modifier, necessary since different rules for small
 *@param {Number} currDice num dice from 1 to n
 *@param {Number} currDie num sides of die : valid only from 1 to 12
 *@returns {jsobj} {dice:n,die:n}
 */
function updateDamageDice(sizediff, defaultSize, currDice, currDie) {
	var diceSizes = { 1: ["1d1"], 2: ["1d2"], 3: ["1d3"],
		4: ["1d4"],
		5: ["1d6"],
		6: ["1d8", "2d4"],
		7: ["1d10"],
		8: ["2d6", "3d4", "1d12"],
		9: ["2d8", "4d4"], 10: ["3d6", "5d4"], 11: ["3d8", "6d4", "2d10"],
		12: ["4d6", "7d4", "2d12"], 13: ["4d8", "8d4", "9d4", "5d6", "3d10"],
		14: ["6d6", "5d8", "10d4", "11d4", "9d4", "3d12"],
		15: ["6d8", "7d6", "12d4", "13d4", "4d10"],
		16: ["8d6", "7d8", "14d4", "15d4", "4d12"],
		17: ["8d8", "16d4", "9d6", "10d6", "11d6", "5d10", "17d4", "18d4", "19d4", "5d12"],
		18: ["12d6", "20d4", "9d8", "7d10", "6d12", "21d4", "22d4", "23d4"],
		19: ["12d8", "24d4", "13d6", "14d6", "15d6", "8d10"],
		20: ["16d6", "13d8", "10d10", "8d12"]
	},
	    currSize = 0,
	    dicestring = "",
	    newDice = 0,
	    newDie = 0,
	    matches,
	    rowdiff = 0,
	    currow = 0,
	    newrow = 0,
	    newrowstring = "",
	    reversedDiceSizes = _underscore2.default.reduce(diceSizes, function (memo, pairs, idx) {
		_underscore2.default.each(pairs, function (pair) {
			memo[pair] = idx;
		});
		return memo;
	}, {});
	try {
		_exportsLoaderTASTheAaronSheet2.default.debug("PFSize.updateDamageDice defSize:" + defaultSize + ", diff:" + sizediff + ", dice:" + currDice + "d" + currDie);
		currDice = parseInt(currDice, 10);
		currDie = parseInt(currDie, 10);
		if (!(isNaN(currDice) || isNaN(currDie))) {
			dicestring = currDice + "d" + currDie;
			currSize = sizeModToEasySizeMap[String(defaultSize)];
			_exportsLoaderTASTheAaronSheet2.default.debug("currSize now : " + currSize);
			if (currDice <= 0 || currDie > 12) {
				return null;
			}
			if (currDie === 4 && currDice > 24) {
				currDice = 24;
			} else if (currDie === 6 && currDice > 16) {
				currDice = 16;
			} else if (currDie === 8 && currDice > 13) {
				currDice = 13;
			} else if (currDie === 10 && currDice > 10) {
				currDice = 10;
			} else if (currDie === 12 && currDice > 8) {
				currDice = 8;
			}
			currow = parseInt(reversedDiceSizes[dicestring], 10) || 0;
			if (!currow) {
				return null;
			}
			while (sizediff !== 0) {
				if (sizediff > 0) {
					if (currDie <= 6 && currDice === 1 || currSize <= 3) {
						rowdiff = 1;
					} else {
						rowdiff = 2;
					}
				} else if (sizediff < 0) {
					if (currDie <= 8 && currDice === 1 || currSize <= 4) {
						rowdiff = -1;
					} else {
						rowdiff = -2;
					}
				}
				newrow = currow + rowdiff;
				newrow = Math.min(Math.max(newrow, 1), 20);
				dicestring = diceSizes[newrow][0];
				_exportsLoaderTASTheAaronSheet2.default.debug("PFSize " + currDice + "d" + currDie + " is currrow:" + currow + " going from size:" + currSize + " of diff:" + sizediff + ", move " + rowdiff + " levels to " + newrow + " dice is " + dicestring);
				matches = dicestring.match(/(\d+)d(\d+)/);
				currDice = parseInt(matches[1], 10);
				currDie = parseInt(matches[2], 10);
				currow = newrow;
				if (sizediff > 0) {
					currSize++;
					sizediff--;
					if (currow === 20) {
						break;
					}
				} else {
					currSize--;
					sizediff++;
					if (currow === 1) {
						break;
					}
				}
				_exportsLoaderTASTheAaronSheet2.default.debug("updateDamageDice: currow is now" + currow + ", diff still:" + sizediff);
			}
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("updateDamageDice: ", err);
	} finally {
		return { "dice": currDice, "die": currDie };
	}
}

function updateSize(v, eventInfo, setter) {
	var size = 0,
	    buffSize = 0,
	    defaultSize = 0,
	    deflevel = 0,
	    newlevel = 0,
	    buffLevels = 0,
	    skillSize = 0,
	    tempstr = '',
	    sizeDisplay = '';
	try {
		setter = setter || {};
		defaultSize = parseInt(v.default_char_size, 10) || 0;
		size = parseInt(v['size'], 10) || 0;
		buffLevels = parseInt(v['buff_size-total'], 10) || 0;
		if (buffLevels !== 0) {
			deflevel = sizeModToEasySizeMap[String(defaultSize)];
			newlevel = deflevel + buffLevels;
			buffSize = reverseSizeMap[String(newlevel)];
			if (buffSize !== size) {
				setter['size'] = buffSize;
				size = buffSize;
			}
		} else if (eventInfo && eventInfo.sourceAttribute.toLowerCase() === 'buff_size-total') {
			if (size !== defaultSize) {
				setter['size'] = defaultSize;
				size = defaultSize;
			}
		}
		try {
			tempstr = reverseSizeNameMap[String(size)];
			if (tempstr) {
				sizeDisplay = getTranslationByKey(sizeDisplay);
			}
		} catch (err3) {
			sizeDisplay = tempstr;
		}
		if (sizeDisplay && (sizeDisplay !== v.size_display || !v.size_display)) {
			setter.size_display = sizeDisplay;
		}
		skillSize = skillSizeMap[String(size)];
		setter.size_skill = skillSize;
		setter["CMD-size"] = size * -1;
		setter.size_skill_double = 2 * skillSize;
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFSize.updateSize", err);
	} finally {
		_exportsLoaderTASTheAaronSheet2.default.debug("PFSize.updateSize returning with  ", setter);
		return setter;
	}
}

function updateSizeAsync(callback, silently, eventInfo) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["size", "size_skill", "size_skill_double", "default_char_size", "CMD-size", "buff_size-total", "size_display"], function (v) {
		var params = {},
		    setter = {};
		try {
			updateSize(v, eventInfo, setter);
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFSize.updateSizeAsync", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				_exportsLoaderTASTheAaronSheet2.default.debug("PFSize.updateSizeAsync, setting:", setter);
				if (silently) {
					params = _PFConst2.default.silentParams;
				}
				setAttrs(setter, params, done);
			} else {
				done();
			}
		}
	});
}
function setNewSize(eventInfo) {
	updateSizeAsync(function () {
		PFEncumbrance.updateLoadsAndLift();
		PFAttacks.adjustAllDamageDiceAsync(null, eventInfo);
	}, false, eventInfo);
}
function applyNewSizeToSheet(eventInfo) {
	_exportsLoaderTASTheAaronSheet2.default.debug("PFSize.applyNewSizeToSheet");
	PFEncumbrance.updateLoadsAndLift();
	PFAttacks.adjustAllDamageDiceAsync(null, eventInfo);
}
function migrate(callback) {
	if (typeof callback === "function") {
		callback();
	}
}
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("Leaving PFSize.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	});
	_exportsLoaderTASTheAaronSheet2.default.debug("At PFSize.recalculate");
	updateSizeAsync(done, silently, null);
}
function registerEventHandlers() {
	//size
	on("change:size change:default_char_size", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateSize(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			setNewSize(eventInfo);
		} else {
			applyNewSizeToSheet(eventInfo);
		}
	}));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFSize module loaded           ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.events = exports.valsNeedingReplacing = exports.keysNeedingReplacing = exports.defaultSkillAttrName = exports.defaultSkillDeletedMacroAttrs = exports.defaultMiscSkillMacroMap = exports.defaultMiscSkillMacro = exports.defaultFillInSkillMacroMap = exports.defaultFillInSkillMacro = exports.defaultSkillMacroMap = exports.defaultSkillMacro = exports.coreSkillAbilityDefaults = exports.allTheSkills = exports.allFillInSkillInstances = exports.miscFillInSkillsInstances = exports.nonMiscFillInSkillsInstances = exports.allNonFillInSkills = exports.consolidatedSkills = exports.allCoreSkills = exports.backgroundSkills = exports.knowledgeSkills = exports.skillsWithSpaces = exports.knowledgeSubSkillsTranslateKeys = exports.sizeSkills = exports.npcSkillHeaderMacro = exports.skillHeaderMacro = exports.baseGenMacro = exports.checkRTArray = exports.adventureSkills = exports.backgroundCoreSkills = exports.subskillArrays = exports.knowledgeSkillAppends = exports.skillsWithSubSkills = exports.coreSkillsWithSubSkills = exports.knowledgeSubSkills = exports.backgroundOnlySkills = exports.skillsWithFillInNames = exports.backgroundOnlySkillsWithFillinNames = exports.coreSkillsWithFillInNames = exports.miscSkillAppendNums = exports.skillAppendNums = exports.regularAdventurePlusKnow = exports.regularBackgroundSkillsPlusKnow = exports.regularAdventureSkills = exports.regularBackgroundSkills = exports.regularCoreSkills = undefined;
exports.verifyHasSkill = verifyHasSkill;
exports.updateSkill = updateSkill;
exports.recalculateSkills = recalculateSkills;
exports.recalculateAbilityBasedSkills = recalculateAbilityBasedSkills;
exports.resetCommandMacro = resetCommandMacro;
exports.applyConditions = applyConditions;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFLog = __webpack_require__(0);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFMacros = __webpack_require__(10);

var PFMacros = _interopRequireWildcard(_PFMacros);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

var _PFUtilsAsync = __webpack_require__(9);

var PFUtilsAsync = _interopRequireWildcard(_PFUtilsAsync);

var _PFAbilityScores = __webpack_require__(11);

var PFAbilityScores = _interopRequireWildcard(_PFAbilityScores);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var regularCoreSkills = exports.regularCoreSkills = ["Appraise", "Acrobatics", "Bluff", "Climb", "Diplomacy", "Disable-Device", "Disguise", "Escape-Artist", "Fly", "Handle-Animal", "Heal", "Intimidate", "Linguistics", "Perception", "Ride", "Sense-Motive", "Sleight-of-Hand", "Spellcraft", "Stealth", "Survival", "Swim", "Use-Magic-Device"],
    regularBackgroundSkills = exports.regularBackgroundSkills = ["Appraise", "Handle-Animal", "Linguistics", "Sleight-of-Hand"],
    regularAdventureSkills = exports.regularAdventureSkills = ["Acrobatics", "Bluff", "Climb", "Diplomacy", "Disable-Device", "Disguise", "Escape-Artist", "Fly", "Heal", "Intimidate", "Perception", "Ride", "Sense-Motive", "Spellcraft", "Stealth", "Survival", "Swim", "Use-Magic-Device"],
    regularBackgroundSkillsPlusKnow = exports.regularBackgroundSkillsPlusKnow = regularBackgroundSkills.concat(["Knowledge-Engineering", "Knowledge-Geography", "Knowledge-History", "Knowledge-Nobility"]).sort(),
    regularAdventurePlusKnow = exports.regularAdventurePlusKnow = regularAdventureSkills.concat(["Knowledge-Arcana", "Knowledge-Dungeoneering", "Knowledge-Local", "Knowledge-Nature", "Knowledge-Planes", "Knowledge-Religion"]).sort(),

//number that is appended to 10 versions of skills with subskills.
skillAppendNums = exports.skillAppendNums = ["", "2", "3", "4", "5", "6", "7", "8", "9", "10"],

//same but for misc-skill
miscSkillAppendNums = exports.miscSkillAppendNums = ["-0", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"],
    coreSkillsWithFillInNames = exports.coreSkillsWithFillInNames = ["Craft", "Misc-Skill", "Perform", "Profession"],
    backgroundOnlySkillsWithFillinNames = exports.backgroundOnlySkillsWithFillinNames = ["Artistry", "Lore"],
    skillsWithFillInNames = exports.skillsWithFillInNames = coreSkillsWithFillInNames.concat(backgroundOnlySkillsWithFillinNames).sort(),
    backgroundOnlySkills = exports.backgroundOnlySkills = SWUtils.cartesianAppend(backgroundOnlySkillsWithFillinNames, skillAppendNums),
    knowledgeSubSkills = exports.knowledgeSubSkills = ["Arcana", "Dungeoneering", "Engineering", "Geography", "History", "Local", "Nature", "Nobility", "Planes", "Religion"],
    coreSkillsWithSubSkills = exports.coreSkillsWithSubSkills = coreSkillsWithFillInNames.concat(["Knowledge"]).sort(),
    skillsWithSubSkills = exports.skillsWithSubSkills = skillsWithFillInNames.concat(["Knowledge"]).sort(),
    knowledgeSkillAppends = exports.knowledgeSkillAppends = _underscore2.default.map(knowledgeSubSkills, function (subskill) {
	return "-" + subskill;
}),

//for each skill array of the possible skills {"Craft":["Craft","Craft2"...],"Perform":["Perform","Perform2"...] }
subskillArrays = exports.subskillArrays = _underscore2.default.reduce(skillsWithSubSkills, function (memo, skill) {
	var appenders = skill === "Misc-Skill" ? miscSkillAppendNums : skill === "Knowledge" ? knowledgeSkillAppends : skillAppendNums;
	memo[skill] = SWUtils.cartesianAppend([skill], skillAppendNums);
	return memo;
}, {}),
    backgroundCoreSkills = exports.backgroundCoreSkills = regularBackgroundSkillsPlusKnow.concat(subskillArrays["Craft"]).concat(subskillArrays["Perform"]).concat(subskillArrays["Profession"]).concat(["Misc-Skill-5", "Misc-Skill-6", "Misc-Skill-7", "Misc-Skill-8", "Misc-Skill-9"]).sort(),
    adventureSkills = exports.adventureSkills = regularAdventurePlusKnow.concat(["Misc-Skill-0", "Misc-Skill-1", "Misc-Skill-2", "Misc-Skill-3", "Misc-Skill-4"]).sort(),
    checkRTArray = exports.checkRTArray = ["-ReqTrain", "-ranks"],
    baseGenMacro = exports.baseGenMacro = "&{template:pf_generic} @{toggle_accessible_flag} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_generic-skill}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} ",
    skillHeaderMacro = exports.skillHeaderMacro = "{{name=^{REPLACELOWER} ^{skills} }} ",
    npcSkillHeaderMacro = exports.npcSkillHeaderMacro = "{{name=^{npc} ^{REPLACELOWER} ^{skills} }} ",

//  1 is the normal size modifier in size_skill, 2 is size_skill_double
sizeSkills = exports.sizeSkills = {
	"Fly": 1,
	"Stealth": 2,
	"CS-Stealth": 2
},

//these are for building the macros
knowledgeSubSkillsTranslateKeys = exports.knowledgeSubSkillsTranslateKeys = _underscore2.default.map(knowledgeSubSkills, function (key) {
	return key.toLowerCase();
}),
    skillsWithSpaces = exports.skillsWithSpaces = ["disable device", "escape artist", "sense motive", "handle animal", "use magic device", "sleight of hand"],
    knowledgeSkills = exports.knowledgeSkills = _underscore2.default.map(knowledgeSubSkills, function (subskill) {
	return "Knowledge-" + subskill;
}),
    backgroundSkills = exports.backgroundSkills = backgroundCoreSkills.concat(backgroundOnlySkills).sort(),
    allCoreSkills = exports.allCoreSkills = adventureSkills.concat(backgroundCoreSkills).sort(),
    consolidatedSkills = exports.consolidatedSkills = ["CS-Acrobatics", "CS-Athletics", "CS-Finesse", "CS-Influence", "CS-Nature", "CS-Perception", "CS-Performance", "CS-Religion", "CS-Society", "CS-Spellcraft", "CS-Stealth", "CS-Survival"],
    allNonFillInSkills = exports.allNonFillInSkills = regularCoreSkills.concat(knowledgeSkills).concat(consolidatedSkills).sort(),
    nonMiscFillInSkillsInstances = exports.nonMiscFillInSkillsInstances = SWUtils.cartesianAppend(["Craft", "Perform", "Profession", "Artistry", "Lore"], skillAppendNums),
    miscFillInSkillsInstances = exports.miscFillInSkillsInstances = SWUtils.cartesianAppend(["Misc-Skill"], miscSkillAppendNums),
    allFillInSkillInstances = exports.allFillInSkillInstances = nonMiscFillInSkillsInstances.concat(miscFillInSkillsInstances).sort(),
    allTheSkills = exports.allTheSkills = allNonFillInSkills.concat(allFillInSkillInstances).sort(),
    coreSkillAbilityDefaults = exports.coreSkillAbilityDefaults = {
	"Acrobatics": "dex",
	"Appraise": "int",
	"Bluff": "cha",
	"Climb": "str",
	"Craft": "int",
	"Diplomacy": "cha",
	"Disable-Device": "dex",
	"Disguise": "cha",
	"Escape-Artist": "dex",
	"Fly": "dex",
	"Handle-Animal": "cha",
	"Heal": "wis",
	"Intimidate": "cha",
	"Knowledge-Arcana": "int",
	"Knowledge-Dungeoneering": "int",
	"Knowledge-Engineering": "int",
	"Knowledge-Geography": "int",
	"Knowledge-History": "int",
	"Knowledge-Local": "int",
	"Knowledge-Nature": "int",
	"Knowledge-Nobility": "int",
	"Knowledge": "int",
	"Knowledge-Planes": "int",
	"Knowledge-Religion": "int",
	"Linguistics": "int",
	"Perception": "wis",
	"Perform": "cha",
	"Profession": "wis",
	"Ride": "dex",
	"Sense-Motive": "wis",
	"Sleight-of-Hand": "dex",
	"Spellcraft": "int",
	"Stealth": "dex",
	"Survival": "wis",
	"Swim": "str",
	"Use-Magic-Device": "cha"
},
    defaultSkillMacro = exports.defaultSkillMacro = '&{template:pf_generic} @{toggle_accessible_flag} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_generic-skill}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=^{REPLACELOWER}}} {{check=[[ @{skill-query} + [[ @{REPLACE} ]] ]]}} @{REPLACE-ut} @{skill_options} @{REPLACE-cond-notes} {{generic_note=@{REPLACE-note}}}',
    defaultSkillMacroMap = exports.defaultSkillMacroMap = {
	'&{template:': { 'current': 'pf_generic}' },
	'@{toggle_accessible_flag}': { 'current': '@{toggle_accessible_flag}' },
	'@{toggle_rounded_flag}': { 'current': '@{toggle_rounded_flag}' },
	'{{color=': { 'current': '@{rolltemplate_color}}}' },
	'{{header_image=': { 'current': '@{header_image-pf_generic-skill}}}', 'old': ['@{header_image-pf_generic}}}'] },
	'{{character_name=': { 'current': '@{character_name}}}' },
	'{{character_id=': { 'current': '@{character_id}}}' },
	'{{subtitle}}': { 'current': '{{subtitle}}' },
	'{{name=': { 'current': '^{REPLACELOWER}}}', 'old': ['REPLACE}}', '@{REPLACE-name}}}', '^{REPLACE}}}'] },
	'{{Check=': { 'current': '[[ @{skill-query} + [[ @{REPLACE} ]] ]]}}', 'old': ['[[ 1d20 + [[ @{REPLACE} ]] ]]}}'], 'replacements': [{ 'from': '1d20', 'to': '@{skill-query}' }] },
	'@{REPLACE-ut}': { 'current': '@{REPLACE-ut}' },
	'@{skill_options}': { 'current': '@{skill_options}' },
	'@{REPLACE-cond-notes}': { 'current': '@{REPLACE-cond-notes}' },
	'{{generic_note=': { 'current': '@{REPLACE-note}}}' }
},
    defaultFillInSkillMacro = exports.defaultFillInSkillMacro = '&{template:pf_generic} @{toggle_accessible_flag} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_generic-skill}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=^{REPLACELOWERREMOVENUMBER} @{REPLACE-name}}} {{check=[[ @{skill-query} + [[ @{REPLACE} ]] ]]}} @{REPLACE-ut} @{skill_options} @{REPLACE-cond-notes} {{generic_note=@{REPLACE-note}}}',
    defaultFillInSkillMacroMap = exports.defaultFillInSkillMacroMap = _underscore2.default.extend(_underscore2.default.clone(defaultSkillMacroMap), {
	'{{name=': { 'current': '^{REPLACELOWERREMOVENUMBER} (@{REPLACE-name})}}', 'old': ['REPLACEREMOVENUMBER (@{REPLACE-name})}}', 'REPLACE}}', '@{REPLACE-name}}}'], 'replacements': [{ 'from': 'REPLACEREMOVENUMBER', 'to': '^{REPLACELOWERREMOVENUMBER}' }] }
}),
    defaultMiscSkillMacro = exports.defaultMiscSkillMacro = '&{template:pf_generic} @{toggle_accessible_flag} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_generic-skill}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=@{REPLACE}}} {{check=[[ @{skill-query} + [[ @{REPLACE} ]] ]]}} @{REPLACE-ut} @{skill_options} @{REPLACE-cond-notes} {{generic_note=@{REPLACE-note}}}',
    defaultMiscSkillMacroMap = exports.defaultMiscSkillMacroMap = _underscore2.default.extend(_underscore2.default.clone(defaultSkillMacroMap), {
	'{{name=': { 'current': '@{REPLACE}}}', 'old': ['Misc-Skill (@{REPLACE-name})}}'] }
}),
    defaultSkillDeletedMacroAttrs = exports.defaultSkillDeletedMacroAttrs = ['{{check=[[ @{skill-query} + [[ @{REPLACE} ]] ]]}}'],
    defaultSkillAttrName = exports.defaultSkillAttrName = 'REPLACE-macro',
    keysNeedingReplacing = exports.keysNeedingReplacing = ['@{REPLACE-cond-notes}', '@{REPLACE-ut}'],
    valsNeedingReplacing = exports.valsNeedingReplacing = ['@{REPLACE-cond-notes}', '@{REPLACE-ut}', '{{check=', '{{generic_note=', '{{name='],
    events = exports.events = {
	skillGlobalEventAuto: "change:checks-cond change:phys-skills-cond change:acp change:buff_check_skills-total",
	//skillGlobalEventAuto: "change:phys-skills-cond change:acp",
	skillEventsAuto: "change:REPLACE-ability-mod change:REPLACE-misc-mod",
	skillEventsPlayer: "change:REPLACE-cs change:REPLACE-ranks change:REPLACE-racial change:REPLACE-trait change:REPLACE-feat change:REPLACE-item change:REPLACE-ReqTrain"
};

function migrateMacros(callback) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSkills.migrateMacros");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    doneOne = _underscore2.default.after(3, function () {
		setAttrs({ 'migrated_skill_macrosv1': 1 }, _PFConst2.default.silentParams, done);
	});
	try {
		_exportsLoaderTASTheAaronSheet2.default.debug("at PFSkills.migrateMacros");
		getAttrs(['migrated_skill_macrosv1'], function (v) {
			if (!parseInt(v.migrated_skill_macrosv1, 10)) {
				//TAS.debug"migrateMacros, calling migrateStaticMacrosMult on regular skills ");
				PFMacros.migrateStaticMacrosMult(doneOne, defaultSkillAttrName, defaultSkillMacro, defaultSkillMacroMap, null, allNonFillInSkills, keysNeedingReplacing, valsNeedingReplacing, false);
				PFMacros.migrateStaticMacrosMult(doneOne, defaultSkillAttrName, defaultFillInSkillMacro, defaultFillInSkillMacroMap, null, nonMiscFillInSkillsInstances, keysNeedingReplacing, valsNeedingReplacing, true);
				PFMacros.migrateStaticMacrosMult(doneOne, defaultSkillAttrName, defaultMiscSkillMacro, defaultMiscSkillMacroMap, null, miscFillInSkillsInstances, keysNeedingReplacing, valsNeedingReplacing, true);
			} else {
				done();
			}
		});
	} catch (err) {
		done();
	}
}

/**appendToSubSkills - util to append the string to all 10 names of one type of skill (perform, craft, knowledge, etc)
 * adds the numbers from 0-9 or 1-10 or knowledge, then appends the string , to generate all 10 versions.
 * @param {string} skilllist The name of the skill in, member of skillsWithSubSkills
 * @param {string} appendToEnd The string to append.
 * @returns {Array[string]} array of skill names
 */
function appendToSubSkills(skilllist, appendToEnd) {
	return _underscore2.default.reduce(skilllist, function (memo, skill) {
		var appendnums = skill === "Misc-Skill" ? miscSkillAppendNums : skill === "Knowledge" ? knowledgeSkillAppends : skillAppendNums,
		    appendArray = SWUtils.cartesianAppend([skill], appendnums, appendToEnd);
		return memo.concat(appendArray);
	}, []);
}
/* updateMaxSkills Calculates and sets maximum skill ranks. Minimum 1 per level.
 *  divides by 2 if using consolidated skills
 * @param {event} eventInfo - from event 
 * @callback {function} - callback when done
 */
function updateMaxSkills(eventInfo, callback) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	}),
	    fields = ["total-skill", "total-fcskill", "INT-mod", "level", "Max-Skill-Ranks-mod", "Max-Skill-Ranks", "unchained_skills-show", "BG-Skill-Use", "npc-skill", "npc-hd-num", "class-0-skill", "class-1-skill", "class-2-skill", "class-3-skill", "class-4-skill", "class-5-skill", "class-0-level", "class-1-level", "class-2-level", "class-3-level", "class-4-level", "class-5-level"];
	getAttrs(fields, function (v) {
		var intMod = parseInt(v["INT-mod"], 10) || 0,
		    classSkills = parseInt(v["total-skill"], 10) || 0,
		    level = parseInt(v.level, 10) || 0,
		    fcSkills = parseInt(v["total-fcskill"], 10) || 0,
		    extra = parseInt(v["Max-Skill-Ranks-mod"], 10) || 0,
		    currSkills = parseInt(v["Max-Skill-Ranks"], 10) || 0,
		    totIntMod = 0,
		    minSkills = 0,
		    i = 0,
		    thislvl = 0,
		    classPlusInt = 0,
		    thisSkill = 0,
		    totAllSkills = 0,
		    setter = {};
		try {
			for (i = 0; i < 6; i++) {
				thislvl = parseInt(v['class-' + i + '-level'], 10) || 0;
				if (thislvl > 0) {
					thisSkill = (parseInt(v['class-' + i + '-skill'], 10) || 0) * thislvl + intMod * thislvl;
					if (thisSkill < thislvl) {
						thisSkill = thislvl;
					}
					classPlusInt += thisSkill;
				}
			}
			thislvl = parseInt(v['npc-hd-num'], 10) || 0;
			thisSkill = parseInt(v['npc-skill'], 10) || 0;
			if (thislvl && thisSkill) {
				thisSkill = thislvl * thisSkill + intMod * thislvl;
				if (thisSkill < thislvl) {
					thisSkill = thislvl;
				}
				classPlusInt += thisSkill;
			}
			if (v["unchained_skills-show"] == "1" && (!v["BG-Skill-Use"] || v["BG-Skill-Use"] == "0")) {
				classPlusInt = Math.floor(classPlusInt / 2);
			}
			totAllSkills = classPlusInt + extra;
			if (totAllSkills < level) {
				totAllSkills = level;
			}
			totAllSkills += fcSkills;
			if (currSkills !== totAllSkills) {
				setter["Max-Skill-Ranks"] = totAllSkills;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFSkills.updateMaxSkills", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				setAttrs(setter, {
					silent: true
				}, done);
			} else {
				done();
			}
		}
	});
}
/** verifyHasSkill - Checks to see if skill is in list of valid skills for this character (consolidated, background, core).
 * @param {string} skill = the skill name
 * @param {function} callback = a function that takes a a boolean as a first parameter.
 *   called with true if skill is part of valid list, or false if not.
 */
function verifyHasSkill(skill, callback) {
	var first3 = '',
	    first4 = '',
	    core = false,
	    bg = false,
	    cs = false,
	    isSub = false,
	    fields = ["BG-Skill-Use", "unchained_skills-show"];
	try {
		if (skill && typeof callback === "function") {
			first4 = skill.slice(0, 4).toLowerCase();
			first3 = first4.slice(0, 3);
			if (first3 === 'cs-') {
				cs = true;
			} else if (first4 === 'arti' || first4 === 'lore') {
				bg = true;
			} else {
				core = true;
			}
			if (_underscore2.default.contains(allFillInSkillInstances, skill)) {
				isSub = true;
				fields = fields.concat([skill + "-name", skill + "-ranks"]);
			}
			getAttrs(fields, function (v) {
				var retval = false,
				    usesBG = parseInt(v["BG-Skill-Use"], 10) || 0,
				    usesUnchained = parseInt(v["unchained_skills-show"], 10) || 0;
				if (!isSub || v[skill + "-name"] || (parseInt(v[skill + "-ranks"], 10) || 0) > 0) {
					if (core) {
						if (!usesUnchained || usesBG) {
							retval = true;
						}
					} else if (bg) {
						if (usesUnchained && usesBG) {
							retval = true;
						}
					} else {
						if (usesUnchained && !usesBG) {
							retval = true;
						}
					}
				}
				callback(retval);
			});
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFSkills.verifyHasSkill", err);
		callback(false);
	}
}
/** updates one  skill row
 * @param {string} skill to update, must have same capitalization as on HTML
 * @param {function} callback = callback after done with params newvalue, oldvalue.
 * @param {boolean} silently = whether to update silently or not. ignored, always silent.
 */
function updateSkill(skill, callback, silently) {
	var done = function done(newVal, oldVal) {
		if (typeof callback === "function") {
			callback(newVal, oldVal);
		}
	},
	    csNm = skill + "-cs",
	    ranksNm = skill + "-ranks",
	    classNm = skill + "-class",
	    abNm = skill + "-ability",
	    modNm = skill + "-ability-mod",
	    racialNm = skill + "-racial",
	    traitNm = skill + "-trait",
	    featNm = skill + "-feat",
	    itemNm = skill + "-item",
	    miscNm = skill + "-misc-mod",
	    utNm = skill + "-ut",
	    rtNm = skill + "-ReqTrain";
	getAttrs([skill, csNm, ranksNm, classNm, abNm, modNm, racialNm, traitNm, featNm, itemNm, miscNm, rtNm, utNm, "enforce_requires_training", "size_skill", "size_skill_double", "acp", "checks-cond", "Phys-skills-cond", "Perception-cond", "buff_check_skills-total", "buff_STR_skills-total", "buff_DEX_skills-total", "buff_CON_skills-total", "buff_INT_skills-total", "buff_WIS_skills-total", "buff_CHA_skills-total"], function (v) {
		var skillSize = 0,
		    adj,
		    skillTot = 0,
		    setter = {},
		    params = {},
		    mods = "",
		    setAny = 0,
		    cond = 0,
		    cs = parseInt(v[csNm], 10) || 0,
		    currSkill = parseInt(v[skill], 10),
		    //no default
		ranks = parseInt(v[ranksNm], 10) || 0,
		    rt = parseInt(v[rtNm], 10) || 0,
		    allCond = parseInt(v["checks-cond"], 10) || 0,
		    buffs = parseInt(v["buff_check_skills-total"], 10) || 0,
		    abilityModName = '',
		    abilityName = '',
		    physCond = 0,
		    perCond = 0,
		    watchrt = parseInt(v["enforce_requires_training"], 10) || 0;
		try {
			abilityModName = PFUtils.findAbilityInString(v[abNm]);
			if (rt && ranks === 0) {
				if (v[utNm] !== "{{untrained=1}}") {
					setter[utNm] = "{{untrained=1}}";
				}
			} else if (v[utNm] !== "{{untrained=}}") {
				setter[utNm] = "{{untrained=}}"; //cannot set to "" because then it chooses the default which is "{{untrained=1}}"
			}
			if (ranks && cs) {
				skillTot += 3;
				mods = "3/";
			} else {
				mods = "0/";
			}
			if (abilityModName === "DEX-mod" || abilityModName === "STR-mod") {
				adj = parseInt(v["acp"], 10) || 0;
				skillTot += adj;
				mods += adj + "/";
				physCond = parseInt(v["Phys-skills-cond"], 10) || 0;
			} else {
				mods += "0/";
			}
			if (abilityModName) {
				abilityName = abilityModName.slice(0, 3);
				buffs += parseInt(v['buff_' + abilityName + '_skills-total'], 10) || 0;
			}

			skillSize = sizeSkills[skill];
			if (skillSize) {
				if (skillSize === 1) {
					adj = parseInt(v["size_skill"], 10) || 0;
					skillTot += adj;
					mods += adj + "/";
				} else if (skillSize === 2) {
					adj = parseInt(v["size_skill_double"], 10) || 0;
					skillTot += adj;
					mods += adj + "/";
				}
			} else {
				mods += "0/";
			}

			if (skill === "Perception" || skill === "CS-Perception") {
				perCond = parseInt(v["Perception-cond"], 10) || 0;
			}
			cond = allCond + physCond + perCond + buffs;
			mods += cond;
			skillTot += ranks + cond + (parseInt(v[modNm], 10) || 0) + (parseInt(v[racialNm], 10) || 0) + (parseInt(v[traitNm], 10) || 0) + (parseInt(v[featNm], 10) || 0) + (parseInt(v[itemNm], 10) || 0) + (parseInt(v[miscNm], 10) || 0);
			if (currSkill !== skillTot) {
				setter[skill] = skillTot;
			}
			if (v[classNm] !== mods) {
				setter[classNm] = mods;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error(err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				setAttrs(setter, {
					silently: true
				}, function () {
					done(skillTot, currSkill);
				});
			} else {
				done(currSkill, currSkill);
			}
		}
	});
}
/**recalculateSkillDropdowns recalculates ability dropdowns for all skills in list silently
 * @param {Array} skills list of skills
 * @param {function} callback callback when done
 * @param {function} errorCallback callback if error encountered creating field list to get.
 */
function recalculateSkillDropdowns(skills, callback, errorCallback) {
	var doneDrop = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("Leaving PFSkills.recalculateSkillDropdowns");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    fields = ["STR-mod", "DEX-mod", "CON-mod", "INT-mod", "WIS-mod", "CHA-mod"];
	try {
		fields = _underscore2.default.reduce(skills, function (memo, skill) {
			memo.push(skill + "-ability");
			memo.push(skill + "-ability-mod");
			return memo;
		}, fields);
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFSkills.recalculateSkillDropdowns could not create field list", err);
		if (typeof errorCallback === "function") {
			errorCallback();
		}
		return;
	}
	//first do all dropdowns at once
	getAttrs(fields, function (v) {
		var setter = {},
		    abilityMods;
		try {
			//TAS.debug("PFSkills.recalculateSkillDropdowns got attrs",v);
			//create short list of 6 modifiers. 
			abilityMods = _underscore2.default.reduce(PFAbilityScores.abilitymods, function (memo, mod) {
				memo[mod] = parseInt(v[mod], 10) || 0;
				return memo;
			}, {});
			//TAS.debug("at PFSkills.recalculateSkillDropdowns abilities are ",abilityMods);
			setter = _underscore2.default.reduce(skills, function (memo, skill) {
				var ability = '',
				    newval = 0,
				    currVal = 0;
				try {
					ability = PFUtils.findAbilityInString(v[skill + "-ability"]);
					if (ability) {
						newval = abilityMods[ability];
						currVal = parseInt(v[skill + "-ability-mod"], 10);
						//TAS.debug("examining skill:"+skill+", ability:"+ability+", currVal:"+currVal+", newval:"+newval);
						if (isNaN(currVal) || newval !== currVal) {
							//TAS.info("setting "+skill + "-ability-mod to "+newval);
							memo[skill + "-ability-mod"] = newval;
						}
					}
				} catch (err) {
					_exportsLoaderTASTheAaronSheet2.default.error("PFSkills.recalculateSkillDropdowns INSIDE REDUCE " + skill, err);
				} finally {
					return memo;
				}
			}, {});
		} catch (err2) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFSkills.recalculateSkillDropdowns inner", err2);
		} finally {
			try {
				//TAS.debug("PFSkills.recalculateSkillDropdowns about to set ");
				//TAS.debug("PFSkills.recalculateSkillDropdowns setting",setter);
				if (_underscore2.default.size(setter) > 0) {
					setAttrs(setter, _PFConst2.default.silentParams, function () {
						//TAS.debug("PFSkills.recalculateSkillDropdowns resturned from setAttrs!");
						doneDrop();
					});
				} else {
					doneDrop();
				}
			} catch (err3) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFSkills.recalculateSkillDropdowns err3", err3);
				doneDrop();
			}
		}
	});
}
/** recalculateSkillArray recalculates skills first dropdown, then misc mod, then skill total.
 * calls updateSkill for each. Does all dropdowns at once since they are easy to merge into one.
 * @param {Array} skills array of skills to update.
 * @param {function} callback when done
 * @param {boolean} silently whether to call setAttrs of skill total with silent or not.
 */
function recalculateSkillArray(skills, callback, silently) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	}),
	    skillCount = _underscore2.default.size(skills),
	    skillsHandled = 0,
	    doneMisc = function doneMisc(skill) {
		//TAS.debug("PFSkills.recalculateSkillArray done with misc skills call updateSkill on "+skill);
		//final: update each skill
		updateSkill(skill, done, silently);
	},
	    doneDrop = function doneDrop() {
		//second do misc one by one (since it is asynchronous)
		_underscore2.default.each(skills, function (skill) {
			SWUtils.evaluateAndSetNumber(skill + "-misc", skill + "-misc-mod", 0, function () {
				doneMisc(skill);
			}, true);
		});
	};
	//TAS.debug("at PFSkills.recalculateSkillArray for ",skills);
	recalculateSkillDropdowns(skills, doneDrop, done);
}

function recalculateSkills(callback, silently) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["unchained_skills-show", "BG-Skill-Use"], function (v) {
		try {
			if (v["unchained_skills-show"] == "1") {
				if (v["BG-Skill-Use"] == "1") {
					_exportsLoaderTASTheAaronSheet2.default.debug("PFSkills.recalculate: has background skills");
					recalculateSkillArray(backgroundOnlySkills, null, silently);
					//return after long one
					recalculateSkillArray(allCoreSkills, done, silently);
				} else {
					_exportsLoaderTASTheAaronSheet2.default.debug("PFSkills.recalculate: has consolidatedSkills skills");
					recalculateSkillArray(consolidatedSkills, done, silently);
				}
			} else {
				_exportsLoaderTASTheAaronSheet2.default.debug("PFSkills.recalculate: has core skills skills");
				recalculateSkillArray(allCoreSkills, done, silently);
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFSKills.recalculate", err);
			done();
		}
	});
}
function recalculateAbilityBasedSkills(abilityBuff, callback, silently) {
	recalculateSkills();
}
/** updates the macros for only the 7 subskill rolltemplates 
 * @param {boolean} background -if background skills turned on
 * @param {boolean} rt - if Enforce Requires Training checked 
 * @param {event} eventInfo ?
 * @param {jsobject_map} currMacros map of parent skill button name to command macro. (knowledge, Perform, etc)
 * @param {boolean} isNPC - if sheet is NPC
 * @param {boolean} showBonus - if skill total should be displayed on button.
 */
function updateSubSkillMacroBook(background, rt, eventInfo, currMacros, isNPC, showBonus) {
	var headerString = isNPC ? npcSkillHeaderMacro : skillHeaderMacro,
	    skillPrefix = isNPC ? "NPC-" : "",
	    assembleSubSkillButtonArray = function assembleSubSkillButtonArray(skill, shouldEnforce, v) {
		var appendnums = skill === "Misc-Skill" ? miscSkillAppendNums : skill === "Knowledge" ? knowledgeSkillAppends : skillAppendNums,
		    subskills = SWUtils.cartesianAppend([skill], appendnums),
		    firstPass = [];
		if (skill === "Knowledge") {
			firstPass = subskills;
			return firstPass; //knowledge rollable even if untrained
		}
		firstPass = _underscore2.default.filter(subskills, function (subskill) {
			if (v[subskill + "-name"]) {
				return true;
			}
			return false;
		});
		if (!shouldEnforce) {
			return firstPass;
		}
		return _underscore2.default.filter(firstPass, function (skill) {
			if ((parseInt(v[skill + "-ReqTrain"], 10) || 0) === 0 || (parseInt(v[skill + "-ranks"], 10) || 0) > 0) {
				return true;
			}
			return false;
		});
	},
	    getKnowledgeButtonMacro = function getKnowledgeButtonMacro(showBonus) {
		var bonusStr = showBonus ? "+ @{REPLACE}" : "",
		    knowledgebutton = "[^{REPLACENAME}" + bonusStr + "](~@{character_id}|" + skillPrefix + "REPLACE-check) ";
		return headerString.replace('REPLACELOWER', 'knowledge') + "{{ " + _underscore2.default.reduce(knowledgeSubSkillsTranslateKeys, function (memo, subskill, idx) {
			memo += knowledgebutton.replace(/REPLACENAME/g, subskill).replace(/REPLACE/g, knowledgeSkills[idx]);
			return memo;
		}, "") + " }}";
	},
	    getSubSkillButtonMacro = function getSubSkillButtonMacro(skill, skillArray, showBonus, v) {
		var skillTransKey = skill.toLowerCase(),
		    bonusStr = showBonus ? "+ @{REPLACE}" : "",
		    baseMacro = headerString.replace('REPLACELOWER', skillTransKey),
		    singleRowButton = "[REPLACENAME" + bonusStr + "](~@{character_id}|" + skillPrefix + "REPLACE-check) ",
		    tempstr = "";
		if (skill === "Knowledge") {
			return getKnowledgeButtonMacro();
		}
		tempstr = _underscore2.default.reduce(skillArray, function (memo, subskill, idx) {
			var buttonName = v[subskill + "-name"];
			if (buttonName) {
				buttonName = SWUtils.escapeForChatLinkButton(buttonName);
				buttonName = SWUtils.escapeForRollTemplate(buttonName);
			} else {
				buttonName = "@{" + subskill + "-name}";
			}
			memo += singleRowButton.replace(/REPLACENAME/g, buttonName).replace(/REPLACE/g, subskill);
			return memo;
		}, "");
		if (!tempstr) {
			tempstr = "description = ^{no-skills-available}";
		}
		return baseMacro + "{{ " + tempstr + " }}";
	},
	    subskillParents = background ? skillsWithFillInNames : coreSkillsWithFillInNames,
	    allsubskillFields = appendToSubSkills(subskillParents, ["-name"]);
	if (rt) {
		allsubskillFields = allsubskillFields.concat(appendToSubSkills(subskillParents, checkRTArray));
		allsubskillFields = allsubskillFields.sort();
		//allsubskillFields.concat(appendToSubSkills(subskillParents, checkRTArray)).sort();
	}
	//TAS.debug("updateSubSkillMacroBook: allsubskillFields are:", allsubskillFields);
	getAttrs(allsubskillFields, function (v) {
		var setter = {},
		    tempKMac = "";
		//TAS.debug("updateSubSkillMacroBook: event and data are:", eventInfo, v);
		_underscore2.default.each(subskillParents, function (skill) {
			var canshowarray = assembleSubSkillButtonArray(skill, rt, v),
			    tempMacro = getSubSkillButtonMacro(skill, canshowarray, showBonus, v);
			tempMacro = baseGenMacro + tempMacro;
			if (currMacros[skillPrefix + skill.toLowerCase() + "_skills-macro"] !== tempMacro) {
				setter[skillPrefix + skill.toLowerCase() + "_skills-macro"] = tempMacro;
			}
		});
		if (currMacros[skillPrefix + "knowledge_skills-macro"]) {
			tempKMac = baseGenMacro + getKnowledgeButtonMacro(showBonus);
			if (currMacros[skillPrefix + "knowledge_skills-macro"] !== tempKMac) {
				setter[skillPrefix + "knowledge_skills-macro"] = tempKMac;
			}
		}
		if (_underscore2.default.size(setter) > 0) {
			setAttrs(setter, _PFConst2.default.silentParams);
		}
	});
}
function assembleSkillButtonArray(skills, shouldEnforce, sv) {
	if (!shouldEnforce) {
		return skills;
	}
	return _underscore2.default.filter(skills, function (skill) {
		if (/^Knowled|^Linguis|^Sleight/i.test(skill.slice(0, 7)) || (parseInt(sv[skill + "-ReqTrain"], 10) || 0) !== 1 || (parseInt(sv[skill + "-ranks"], 10) || 0) > 0) {
			return true;
		}
		return false;
	});
}
function getSkillButtonMacro(name, skillArray, showBonus, isNPC) {
	var skillTransKey = name.toLowerCase(),
	    skillPrefix = isNPC ? "NPC-" : "",
	    bonusStr = showBonus ? " + @{REPLACE}" : "",
	    baseMacro = "{{name= ^{" + skillTransKey + "} }} ",
	    npcBaseMacro = "{{name= ^{npc} ^{" + skillTransKey + "} }} ",
	    rowbutton = "[^{REPLACELOWER}" + bonusStr + "](~@{character_id}|" + skillPrefix + "REPLACE-check) ",
	    subskillbutton = "[^{REPLACELOWER}](~@{character_id}|" + skillPrefix + "REPLACELOWERMAC_skills_buttons_macro) ",
	    baseToSend = isNPC ? npcBaseMacro : baseMacro,
	    tempstr = "";
	try {
		tempstr = _underscore2.default.reduce(skillArray, function (memo, skill, idx) {
			var thistranskey = skill.toLowerCase(),
			    thisbutton = _underscore2.default.contains(skillsWithSubSkills, skill) ? subskillbutton : rowbutton;
			thisbutton = thisbutton.replace(/REPLACELOWERMAC/g, thistranskey);
			thisbutton = thisbutton.replace(/REPLACELOWER/g, thistranskey);
			thisbutton = thisbutton.replace(/REPLACE/g, skill);
			memo += thisbutton + " ";
			return memo;
		}, "");
		if (!tempstr) {
			tempstr = "^{no-skills-available} ";
		}
	} finally {
		return baseToSend + "{{ " + tempstr + "}}";
	}
}
function resetOneCommandMacro(callback, eventInfo, isNPC, showBonus, unchained, background, consolidated, rt) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	}),
	    skillPrefix = isNPC ? "NPC-" : "";
	getAttrs([skillPrefix + "skills-macro", skillPrefix + "background_skills-macro", skillPrefix + "adventure_skills-macro", skillPrefix + "artistry_skills-macro", skillPrefix + "lore_skills-macro", skillPrefix + "craft_skills-macro", skillPrefix + "knowledge_skills-macro", skillPrefix + "perform_skills-macro", skillPrefix + "profession_skills-macro", skillPrefix + "misc-skill_skills-macro"], function (v) {
		var i = 0,
		    setter = {},
		    tempSkillArray = [],
		    tempMacro = "",
		    allskillstitle = "skills",
		    coreArray;
		if (!consolidated) {
			updateSubSkillMacroBook(background, rt, eventInfo, v, isNPC, showBonus);
			getAttrs(SWUtils.cartesianAppend(regularCoreSkills, checkRTArray), function (v) {
				var canshowarray = [],
				    tempRTMacro = "",
				    temparray = [];
				try {
					if (background) {
						canshowarray = assembleSkillButtonArray(regularBackgroundSkills, rt, v) || [];
						temparray = temparray.concat(canshowarray);
						canshowarray = canshowarray.concat(skillsWithSubSkills).sort();
						tempRTMacro = baseGenMacro + getSkillButtonMacro("background-skills", canshowarray, showBonus, isNPC);
						if (v[skillPrefix + "background_skills-macro"] !== tempRTMacro) {
							setter[skillPrefix + "background_skills-macro"] = tempRTMacro;
						}
						canshowarray = assembleSkillButtonArray(regularAdventureSkills, rt, v) || [];
						temparray = temparray.concat(canshowarray);
						canshowarray = canshowarray.concat(["Knowledge", "Misc-Skill"]).sort();
						tempRTMacro = baseGenMacro + getSkillButtonMacro("adventure-skills", canshowarray, showBonus, isNPC);
						if (v[skillPrefix + "adventure_skills-macro"] !== tempRTMacro) {
							setter[skillPrefix + "adventure_skills-macro"] = tempRTMacro;
						}
						temparray = temparray.concat(skillsWithSubSkills).sort();
					} else {
						canshowarray = assembleSkillButtonArray(regularCoreSkills, rt, v) || [];
						temparray = temparray.concat(canshowarray).concat(coreSkillsWithSubSkills).sort();
					}
					tempRTMacro = baseGenMacro + getSkillButtonMacro("skills", temparray, showBonus, isNPC);
					if (v[skillPrefix + "skills-macro"] !== tempRTMacro) {
						setter[skillPrefix + "skills-macro"] = tempRTMacro;
					}
				} catch (errRT) {
					_exportsLoaderTASTheAaronSheet2.default.error("PFSkills.resetOneCommandMacro errRT", errRT);
				} finally {
					if (_underscore2.default.size(setter) > 0) {
						setAttrs(setter, _PFConst2.default.silentParams, done);
					} else {
						done();
					}
				}
			});
		} else {
			//consolidated
			getAttrs(SWUtils.cartesianAppend(consolidatedSkills, ["-ReqTrain", "-ranks"]), function (sv) {
				var canshowarray,
				    setter = {},
				    tempMacro;
				canshowarray = assembleSkillButtonArray(consolidatedSkills, rt, sv);
				tempMacro = getSkillButtonMacro("skills", canshowarray, showBonus);
				setter[skillPrefix + "consolidated_skills-macro"] = baseGenMacro + tempMacro;
				setAttrs(setter, _PFConst2.default.silentParams, done);
			});
		}
	});
}
function resetCommandMacro(eventInfo, callback) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["BG-Skill-Use", "unchained_skills-show", "enforce_requires_training", "is_npc", "include_skill_totals"], function (vout) {
		var isNPC = parseInt(vout["is_npc"], 10) || 0,
		    skillPrefix = isNPC ? "NPC-" : "",
		    showBonus = parseInt(vout.include_skill_totals, 10) || 0,
		    unchained = parseInt(vout["unchained_skills-show"], 10) || 0,
		    background = unchained && (parseInt(vout["BG-Skill-Use"], 10) || 0),
		    consolidated = unchained && !background,
		    rt = parseInt(vout["enforce_requires_training"], 10) || 0;
		resetOneCommandMacro(done, eventInfo, isNPC, showBonus, unchained, background, consolidated, rt);
		if (isNPC) {
			resetOneCommandMacro(done, eventInfo, false, showBonus, unchained, background, consolidated, rt);
		}
	});
}
function applyConditions(callback, silently, eventInfo) {
	var done = function done() {
		if (typeof callback === "function") {
			callback();
		}
	},
	    updateSkillArray = function updateSkillArray(skills) {
		_underscore2.default.each(skills, function (skill) {
			updateSkill(skill);
		});
	};
	//TAS.debug("at apply conditions");
	getAttrs(["unchained_skills-show", "BG-Skill-Use"], function (v) {
		try {
			if (v["unchained_skills-show"] == "1") {
				if (v["BG-Skill-Use"] == "1") {
					//TAS.debug("PFSkills.recalculate: has background skills");
					updateSkillArray(backgroundOnlySkills);
					//return after long one
					updateSkillArray(allCoreSkills);
				} else {
					//TAS.debug("PFSkills.recalculate: has consolidatedSkills skills");
					updateSkillArray(consolidatedSkills);
				}
			} else {
				//TAS.debug("PFSkills.recalculate: has core skills skills");
				updateSkillArray(allCoreSkills);
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFSKills.applyConditions", err);
			done();
		}
	});
}
/** migrate skills
 * @param {function} callback callback when done
 * @param {number} oldversion old version , -1 if hit recalc
 */
function migrate(callback, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSkills.migrate");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    doneOne = _underscore2.default.after(4, done),

	/** migrateOldClassSkillValue - converts class skill checkboxes from old autocalc string to number "" or 3.
  * @param {function} callback when done
  * @param {number} oldversion currversionnumber
  */
	migrateOldClassSkillValue = function migrateOldClassSkillValue(callback, oldversion) {
		var done = _underscore2.default.once(function () {
			if (typeof callback === "function") {
				callback();
			}
		}),
		    migrateClassSkill = function migrateClassSkill(skill) {
			var csNm = skill + "-cs";
			getAttrs([csNm], function (v) {
				var setter = {};
				if (isNaN(parseInt(v[csNm], 10))) {
					if (!(!v[csNm] || v[csNm] == "0")) {
						//TAS.debug({"function":"migrateClassSkill","raw":v[csNm],"cs":cs});
						setter[csNm] = 3;
						setAttrs(setter, _PFConst2.default.silentParams);
					}
				}
			});
		},
		    migrateClassSkillArray = function migrateClassSkillArray(skills) {
			skills.forEach(function (skill) {
				migrateClassSkill(skill);
			});
		},
		    determineArray = function determineArray() {
			migrateClassSkillArray(allTheSkills);
			//not bothering to code correctly to wait since this is almost a year old.
			setAttrs({ classSkillsMigrated: 1 }, _PFConst2.default.silentParams, done);
		};
		getAttrs(["classSkillsMigrated"], function (vm) {
			if (!(parseInt(vm.classSkillsMigrated, 10) || 0)) {
				determineArray();
			}
			done();
		});
	},

	/** setAdvancedMacroCheckbox - part of migrate .66 to 1.00 sets checkbox to unhide advanced
  * skillmacro (investigator) if character sheet already using it.)
  * @param {function} callback  whendone
  */
	setAdvancedMacroCheckbox = function setAdvancedMacroCheckbox(callback) {
		var done = _underscore2.default.once(function () {
			if (typeof callback === "function") {
				callback();
			}
		});
		getAttrs(["adv_macro_show", "skill-invest-query"], function (v) {
			var showAdv = parseInt(v.adv_macro_show, 10) || 0;
			if (v["skill-invest-query"] && !showAdv) {
				setAttrs({ adv_macro_show: 1 }, _PFConst2.default.silentParams, done);
			}
		});
	},
	    migrateTake10Dropdown = function migrateTake10Dropdown(callback, oldversion) {
		var done = function done() {
			if (typeof callback === "function") {
				callback();
			}
		};
		getAttrs(['migrated_take10_dropdown', 'skill-query', 'investigator_dice', 'skill-invest-query'], function (v) {
			var setter = {};
			//TAS.notice("########################","PFSkills.migrate",v,"################3");
			//TAS.debug("V 13 just to make sure the damn thing is working");
			if ((parseInt(v.migrated_take10_dropdown, 10) || 0) === 0) {
				if (v['skill-query'] === '?{Roll or Take 10/20?|1d20,1d20+@{skill-invest-query&#125;|10,10+@{skill-invest-query&#125;|20,20+@{skill-invest-query&#125;}') {
					setter['skill-query'] = '?{Roll or Take 10/20?|1d20,1d20|10,10|20,20}+@{skill-invest-query}';
				} else if (v['skill-query'] === '@{skill-invest-query}') {
					setter['skill-query'] = '@{skill-invest-query}+@{custom_dice}';
				} else if (!v['skill-query'] || v['skill-query'] == "0") {
					setter['skill-query'] = '1d20+@{skill-invest-query}';
				} else if (v['skill-query'] !== '@{skill-invest-query}+@{custom_dice}' && v['skill-query'] !== '?{Roll or Take 10/20?|1d20,1d20|10,10|20,20}+@{skill-invest-query}' && v['skill-query'] !== '1d20+@{skill-invest-query}') {
					setter['skill-query'] = '1d20+@{skill-invest-query}';
				}
				if (v.investigator_dice === "0" || !v.investigator_dice) {
					setter.investigator_dice = "[[ 1d6 ]] [custom bonus]";
				}
				if (!v['skill-invest-query']) {
					setter['skill-invest-query'] = "0";
				} else if (v['skill-invest-query'] !== '@{investigator_dice}' && v['skill-invest-query'] !== "0") {
					setter['skill-invest-query'] = "0";
				}
				setter.migrated_take10_dropdown = 1;
				//TAS.debug("#####################","PFBuffs.migrate setting",setter);
				setAttrs(setter, _PFConst2.default.silentParams, done);
			} else {
				done();
			}
		});
	};
	//TAS.debug("at PFSkills.migrate");
	migrateTake10Dropdown(doneOne);
	migrateOldClassSkillValue(doneOne);
	migrateMacros(doneOne);
	PFMigrate.migrateMaxSkills(doneOne);
}
/* recalculate - updates ALL skills  - calls PFUtilsAsync.setDropdownValue for ability then updateSkill */
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.info("leaving PFSkills.recalculate");
		resetCommandMacro();
		if (typeof callback === "function") {
			callback();
		}
	});
	_exportsLoaderTASTheAaronSheet2.default.debug("PFSkills.recalculate");
	migrate(function () {
		//TAS.debug"PFSkills.recalculate back from PFSkills.migrate");
		updateMaxSkills();
		recalculateSkills(done, silently);
	}, oldversion);
}
function registerEventHandlers() {
	//SKILLS************************************************************************
	on("change:total-skill change:total-fcskill change:int-mod change:level change:max-skill-ranks-mod change:unchained_skills-show change:BG-Skill-Use", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateMaxSkills(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "sheetworker") {
			updateMaxSkills(eventInfo);
		}
	}));
	on(events.skillGlobalEventAuto, _exportsLoaderTASTheAaronSheet2.default.callback(function eventGlobalConditionAffectingSkill(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event for " + eventInfo.sourceType);
		if (eventInfo.sourceType === "sheetworker") {
			applyConditions(null, null, eventInfo);
		}
	}));
	//each skill has a dropdown handler and a skill update handler
	//concat them all up, only happens once so no big deal
	_underscore2.default.each(allTheSkills, function (skill) {
		on(events.skillEventsAuto.replace(/REPLACE/g, skill), _exportsLoaderTASTheAaronSheet2.default.callback(function eventSkillsAuto(eventInfo) {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event for " + skill + ", " + eventInfo.sourceType);
			if (eventInfo.sourceType === "sheetworker") {
				verifyHasSkill(skill, function (hasSkill) {
					if (hasSkill) {
						updateSkill(skill, eventInfo);
					}
				});
			}
		}));
		on(events.skillEventsPlayer.replace(/REPLACE/g, skill), _exportsLoaderTASTheAaronSheet2.default.callback(function eventSkillsPlayer(eventInfo) {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event for " + skill + ", " + eventInfo.sourceType);
			if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
				verifyHasSkill(skill, function (hasSkill) {
					if (hasSkill) {
						updateSkill(skill, eventInfo);
					}
				});
			}
		}));
		on("change:" + skill + "-ability", _exportsLoaderTASTheAaronSheet2.default.callback(function eventSkillDropdownAbility(eventInfo) {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			verifyHasSkill(skill, function (hasSkill) {
				if (hasSkill) {
					PFUtilsAsync.setDropdownValue(skill + "-ability", skill + "-ability-mod");
				}
			});
		}));
		on("change:" + skill + "-misc", _exportsLoaderTASTheAaronSheet2.default.callback(function eventSkillMacroAbility(eventInfo) {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			verifyHasSkill(skill, function (hasSkill) {
				if (hasSkill) {
					SWUtils.evaluateAndSetNumber(skill + "-misc", skill + "-misc-mod");
				}
			});
		}));
		//these always displayed if rt or not
		if (skill.slice(0, 9) !== "Knowledge" && skill !== "Linguistics" && skill !== "Sleight-of-Hand") {
			on("change:" + skill + "-ReqTrain change:" + skill + "-ranks", _exportsLoaderTASTheAaronSheet2.default.callback(function eventSkillRequiresTrainingRanks(eventInfo) {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event for " + skill + ", " + eventInfo.sourceType);
				if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
					verifyHasSkill(skill, function (hasSkill) {
						getAttrs(["enforce_requires_training"], function (v) {
							if (v.enforce_requires_training == "1") {
								resetCommandMacro(eventInfo);
							}
						});
					});
				}
			}));
		}
		//end of skill loop
	});
	//skills affected by size
	_underscore2.default.each(sizeSkills, function (mult, skill) {
		if (mult === 1) {
			on("change:size_skill", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateSizeSkill(eventInfo) {
				if (eventInfo.sourceType === "sheetworker") {
					_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
					updateSkill(skill, eventInfo);
				}
			}));
		} else if (mult === 2) {
			on("change:size_skill_double", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateSizeSkillDouble(eventInfo) {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
				if (eventInfo.sourceType === "sheetworker") {
					updateSkill(skill, eventInfo);
				}
			}));
		}
	});
	on("change:enforce_requires_training", _exportsLoaderTASTheAaronSheet2.default.callback(function eventRequiresTraining(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			resetCommandMacro(eventInfo);
		}
	}));
	_underscore2.default.each(SWUtils.cartesianAppend(allFillInSkillInstances, ["-name"]), function (skill) {
		on("change:" + skill, _exportsLoaderTASTheAaronSheet2.default.callback(function eventSkillsWithFillInNames(eventInfo) {
			if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
				var rt = skill.slice(0, -4) + "ReqTrain",
				    r = skill.slice(0, -4) + "ranks";
				//if we changed name on a skill that isn't choosable don't bother.
				getAttrs(["enforce_requires_training", rt, r, "unchained_skills-show", "BG-Skill-Use", "artistry_skills-macro", "lore_skills-macro", "craft_skills-macro", "knowledge_skills-macro", "perform_skills-macro", "profession_skills-macro", "misc-skill_skills-macro", "is_npc", "include_skill_totals", "NPC-craft_skills-macro", "NPC-knowledge_skills-macro", "NPC-perform_skills-macro", "NPC-profession_skills-macro", "NPC-misc-skill_skills-macro"], function (v) {
					var isrt = parseInt(v.enforce_requires_training, 10),
					    bg = 0,
					    isNPC = parseInt(v.is_npc, 10) || 0,
					    showBonus = parseInt(v.include_skill_totals, 10) || 0;
					if (!(isrt && parseInt(v[rt], 10) && isNaN(parseInt(v[r], 10)))) {
						bg = isNPC ? 0 : (parseInt(v["unchained_skills-show"], 10) || 0) && (parseInt(v["BG-Skill-Use"], 10) || 0);
						//TAS.debug"calling updatesubskillmacro: bg:" + bg + ",isrt:" + isrt);
						updateSubSkillMacroBook(bg, isrt, eventInfo, v, isNPC, showBonus);
					}
				});
			}
		}));
	});
	//reset based on config changes
	on("change:unchained_skills-show change:BG-Skill-Use change:include_skill_totals", _exportsLoaderTASTheAaronSheet2.default.callback(function eventResetUnchainedSkills(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			recalculate(eventInfo, function () {
				resetCommandMacro(eventInfo);
			});
		}
	}));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFSkills module loaded         ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.classesUsingOtherSpellLists = exports.spellLevels = undefined;
exports.resetCommandMacro = resetCommandMacro;
exports.resetSpellsTotals = resetSpellsTotals;
exports.createAttackEntryFromRow = createAttackEntryFromRow;
exports.updateAssociatedAttack = updateAssociatedAttack;
exports.updateSpellsCasterLevelRelated = updateSpellsCasterLevelRelated;
exports.updateSpellsCasterAbilityRelated = updateSpellsCasterAbilityRelated;
exports.updateSpells = updateSpells;
exports.importFromCompendium = importFromCompendium;
exports.migrateRepeatingMacros = migrateRepeatingMacros;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFLog = __webpack_require__(0);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

var _PFMacros = __webpack_require__(10);

var PFMacros = _interopRequireWildcard(_PFMacros);

var _PFSpellOptions = __webpack_require__(39);

var PFSpellOptions = _interopRequireWildcard(_PFSpellOptions);

var _PFAttackOptions = __webpack_require__(12);

var PFAttackOptions = _interopRequireWildcard(_PFAttackOptions);

var _PFAttackGrid = __webpack_require__(7);

var PFAttackGrid = _interopRequireWildcard(_PFAttackGrid);

var _PFAttacks = __webpack_require__(8);

var PFAttacks = _interopRequireWildcard(_PFAttacks);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var
//spell levels for repeating spell sections
spellLevels = exports.spellLevels = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],

//for parsing: classes without their own spell lists plus bloodrager as sorcerer, whose list is not in compendium - hunter handled special
classesUsingOtherSpellLists = exports.classesUsingOtherSpellLists = {
    "arcanist": "wizard",
    "investigator": "alchemist",
    "warpriest": "cleric",
    "skald": "bard",
    "bloodrager": "sorcerer"
};
var defaultRepeatingMacro = '&{template:pf_spell} @{toggle_spell_accessible} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_spell}}} {{name=@{name}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{deafened_note=@{SpellFailureNote}}} @{spell_options}',
    defaultRepeatingMacroMap = {
    '&{template:': { 'current': 'pf_spell}', old: ['pf_generic}', 'pf_block}'] },
    '@{toggle_spell_accessible}': { 'current': '@{toggle_spell_accessible}' },
    '@{toggle_rounded_flag}': { 'current': '@{toggle_rounded_flag}' },
    '{{color=': { 'current': '@{rolltemplate_color}}}' },
    '{{header_image=': { 'current': '@{header_image-pf_spell}}}' },
    '{{name=': { 'current': '@{name}}}' },
    '{{character_name=': { 'current': '@{character_name}}}' },
    '{{character_id=': { 'current': '@{character_id}}}' },
    '{{subtitle}}': { 'current': '{{subtitle}}' },
    '{{deafened_note=': { 'current': '@{SpellFailureNote}}}' },
    '@{spell_options}': { 'current': '@{spell_options}' } },
    defaultDeletedMacroAttrs = ['@{toggle_accessible_flag}'];

function resetCommandMacro(eventInfo, callback) {
    //TAS.debug("at PFSpells.resetCommandMacro");
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    }),
        repeatingSpellAttrs = ["spell_level", "spellclass_number", "name", "school", "slot", "metamagic", "used", "isDomain", "isMythic"],
        class0BaseMacro = "&{template:pf_block} @{toggle_spell_accessible} @{toggle_rounded_flag}{{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_block}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=@{spellclass-0-name} ^{spells}}} {{row01=**^{checks}**}} {{row02=[^{caster-level-check}](~@{character_id}|Spell-Class-0-CL-Check) [^{concentration-check}](~@{character_id}|Concentration-Check-0) [^{spell-failure}](~@{character_id}|Spell-Fail-Check)}}",
        class1BaseMacro = "&{template:pf_block} @{toggle_spell_accessible} @{toggle_rounded_flag}{{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_block}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=@{spellclass-1-name} ^{spells}}} {{row01=**^{checks}**}} {{row02=[^{caster-level-check}](~@{character_id}|Spell-Class-1-CL-Check) [^{concentration-check}](~@{character_id}|Concentration-Check-1) [^{spell-failure}](~@{character_id}|Spell-Fail-Check)}}",
        class2BaseMacro = "&{template:pf_block} @{toggle_spell_accessible} @{toggle_rounded_flag}{{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_block}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=@{spellclass-2-name} ^{spells}}} {{row01=**^{checks}**}} {{row02=[^{caster-level-check}](~@{character_id}|Spell-Class-2-CL-Check) [^{concentration-check}](~@{character_id}|Concentration-Check-2) [^{spell-failure}](~@{character_id}|Spell-Fail-Check)}}",
        npcClass0BaseMacro = "&{template:pf_block} @{toggle_spell_accessible} @{toggle_rounded_flag}{{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_block}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=^{npc} @{spellclass-0-name} ^{spells}}} {{row01=**^{checks}**}} {{row02=[^{caster-level-check}](~@{character_id}|Spell-Class-0-CL-Check) [^{concentration-check}](~@{character_id}|Concentration-Check-0) [^{spell-failure}](~@{character_id}|Spell-Fail-Check)}}",
        npcClass1BaseMacro = "&{template:pf_block} @{toggle_spell_accessible} @{toggle_rounded_flag}{{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_block}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=^{npc} @{spellclass-1-name} ^{spells}}} {{row01=**^{checks}**}} {{row02=[^{caster-level-check}](~@{character_id}|Spell-Class-1-CL-Check) [^{concentration-check}](~@{character_id}|Concentration-Check-1) [^{spell-failure}](~@{character_id}|Spell-Fail-Check)}}",
        npcClass2BaseMacro = "&{template:pf_block} @{toggle_spell_accessible} @{toggle_rounded_flag}{{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_block}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=^{npc} @{spellclass-2-name} ^{spells}}} {{row01=**^{checks}**}} {{row02=[^{caster-level-check}](~@{character_id}|Spell-Class-2-CL-Check) [^{concentration-check}](~@{character_id}|Concentration-Check-2) [^{spell-failure}](~@{character_id}|Spell-Fail-Check)}}",
        pcBaseMacro = [class0BaseMacro, class1BaseMacro, class2BaseMacro],
        npcBaseMacro = [npcClass0BaseMacro, npcClass1BaseMacro, npcClass2BaseMacro],
        resetToDefault = function resetToDefault(configV) {
        var attrs = [],
            i = 0;
        for (i = 0; i < 3; i++) {
            if (configV["spellclass-" + i + "-book"].slice(13) !== pcBaseMacro[i].slice(13)) {
                attrs["spellclass-" + i + "-book"] = pcBaseMacro[i];
            }
            if (configV["spellclass-" + i + "-book-npc"].slice(13) !== npcBaseMacro[i].slice(13)) {
                attrs["spellclass-" + i + "-book-npc"] = npcBaseMacro[i];
            }
        }
        if (_underscore2.default.size(attrs) > 0) {
            setAttrs(attrs, {
                silent: true
            }, done);
        } else {
            done();
        }
    };
    getAttrs(["spellclass-0-casting_type", "spellclass-1-casting_type", "spellclass-2-casting_type", "spellclass-0-hide_unprepared", "spellclass-1-hide_unprepared", "spellclass-2-hide_unprepared", "spellclass-0-book", "spellclass-1-book", "spellclass-2-book", "spellclass-0-book-npc", "spellclass-1-book-npc", "spellclass-2-book-npc", "spellclass-0-show_domain_spells", "spellclass-1-show_domain_spells", "spellclass-2-show_domain_spells", "spellmenu_groupby_school", "spellmenu_show_uses", "mythic-adventures-show"], function (configV) {
        var isPrepared = [],
            showDomain = [],
            hideUnprepared = [],
            groupBySchool = 0,
            showUses = 0,
            usesMythic = 0;
        try {
            isPrepared = [parseInt(configV["spellclass-0-casting_type"], 10) === 2, parseInt(configV["spellclass-1-casting_type"], 10) === 2, parseInt(configV["spellclass-2-casting_type"], 10) === 2];
            showDomain = [parseInt(configV["spellclass-0-show_domain_spells"], 10) || 0, parseInt(configV["spellclass-1-show_domain_spells"], 10) || 0, parseInt(configV["spellclass-2-show_domain_spells"], 10) || 0];
            hideUnprepared = [parseInt(configV["spellclass-0-hide_unprepared"], 10) || 0, parseInt(configV["spellclass-1-hide_unprepared"], 10) || 0, parseInt(configV["spellclass-2-hide_unprepared"], 10) || 0];
            groupBySchool = parseInt(configV["spellmenu_groupby_school"], 10) || 0;
            showUses = parseInt(configV["spellmenu_show_uses"], 10) || 0;
            usesMythic = parseInt(configV["mythic-adventures-show"], 10) || 0;
        } catch (outererr) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.resetCommandMacro, error assembling global vars", outererr);
            done();
            return;
        }
        getSectionIDs("repeating_spells", function (idarray) {
            var attrs = {};
            //TAS.debug(idarray);
            if (!idarray || idarray.length === 0) {
                resetToDefault(configV);
                return;
            }
            getAttrs(["_reporder_repeating_spells"], function (repValues) {
                //TAS.debug("PFSpells.resetCommandMacro order repValues:",repValues);
                var spellAttrs;
                try {
                    spellAttrs = _underscore2.default.chain(idarray).map(function (id) {
                        var prefix = 'repeating_spells_' + SWUtils.getRepeatingIDStr(id),
                            retVal = [];
                        _underscore2.default.each(repeatingSpellAttrs, function (attr) {
                            retVal.push(prefix + attr);
                        });
                        return retVal;
                    }).flatten().value();
                } catch (errouter2) {
                    _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.resetCommandMacro errouter", errouter2);
                    done();
                    return;
                }
                getAttrs(spellAttrs, function (values) {
                    //TAS.debug(values);
                    var orderedList,
                        repList,
                        filteredIds,
                        spellsByClass,
                        npcSpellsArray,
                        customSorted = 0,
                        spellsPC,
                        spellsNPC,
                        i,
                        groups = [],
                        spellSchoolReg = /[^\(\[]*/,
                        attrs = {},
                        rollTemplateCounter = 0,
                        tempstr;
                    try {
                        if (!_underscore2.default.isUndefined(repValues._reporder_repeating_spells) && repValues._reporder_repeating_spells !== "") {
                            repList = repValues._reporder_repeating_spells.split(",");
                            repList = _underscore2.default.map(repList, function (ID) {
                                return ID.toLowerCase();
                            });
                            orderedList = _underscore2.default.intersection(_underscore2.default.union(repList, idarray), idarray);
                            customSorted = 1;
                        } else {
                            orderedList = idarray;
                        }
                        spellsByClass = _underscore2.default.chain(orderedList).map(function (id) {
                            var prefix = '',
                                metaMagic = 0,
                                spellSlot = 0,
                                matches,
                                schoolForGroup = '',
                                levelstr = '',
                                rawlevel = 0,
                                spellClass = '',
                                classStr = '',
                                isDomain = 0,
                                isMythic = 0,
                                uses = 0,
                                name = '';
                            try {
                                prefix = "repeating_spells_" + SWUtils.getRepeatingIDStr(id);
                                metaMagic = parseInt(values[prefix + "metamagic"], 10) || 0;
                                spellSlot = metaMagic ? values[prefix + "slot"] || values[prefix + "spell_level"] : values[prefix + "spell_level"];
                                schoolForGroup = values[prefix + "school"] || "";
                                matches = spellSchoolReg.exec(values[prefix + "school"] || "");
                                if (matches && matches[0]) {
                                    schoolForGroup = SWUtils.trimBoth(matches[0]);
                                    schoolForGroup = schoolForGroup[0].toUpperCase() + schoolForGroup.slice(1).toLowerCase();
                                }
                                levelstr = "^{level} " + String(spellSlot);
                                rawlevel = parseInt(values[prefix + "spell_level"], 10) || 0;
                                spellClass = parseInt(values[prefix + "spellclass_number"], 10) || 0;
                                classStr = "class" + (values[prefix + "spellclass_number"] || "0");
                                isDomain = parseInt(values[prefix + "isDomain"], 10) || 0;
                                isMythic = usesMythic * parseInt(values[prefix + "isMythic"], 10) || 0;
                                uses = parseInt(values[prefix + "used"], 10) || 0;
                                name = values[prefix + "name"] || "";
                            } catch (errmap) {
                                _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.resetCommandMacro errmap on id " + id, errmap);
                            } finally {
                                return { 'id': id,
                                    'level': spellSlot,
                                    'levelstr': levelstr,
                                    'rawlevel': rawlevel,
                                    'school': schoolForGroup,
                                    'spellClass': spellClass,
                                    'spellClassstr': classStr,
                                    'isDomain': isDomain,
                                    'isMythic': isMythic,
                                    'uses': uses,
                                    'name': name
                                };
                            }
                        }).omit(function (spellObj) {
                            return hideUnprepared[spellObj.spellClass] && isPrepared[spellObj.spellClass] && spellObj.uses === 0 && !(showDomain[spellObj.spellClass] && spellObj.isDomain);
                        }).map(function (spellObj) {
                            var spellName = spellObj.name,
                                usesStr = "",
                                dstr = "",
                                mystr = "",
                                lvlstr = "",
                                spacestr = "";
                            try {
                                spellName = SWUtils.escapeForChatLinkButton(spellName);
                                spellName = SWUtils.escapeForRollTemplate(spellName);
                                spellName = SWUtils.trimBoth(spellName);
                                usesStr = showUses ? "(" + spellObj.uses + ")" : "";
                                if (showUses && isPrepared[spellObj.spellClass] && spellObj.isDomain) {
                                    usesStr = "";
                                }
                                mystr = spellObj.isMythic ? "&#x1f11c;" : ""; //   // "&#x24A8;":"";//"(m)":"";//
                                dstr = spellObj.isDomain ? "&#x1f113;" : ""; // "";  //"&#x249F;":"";//"(d)":"";//
                                lvlstr = groupBySchool ? spellObj.level + ":" : "";
                                spacestr = usesStr || mystr || dstr ? " " : "";
                                spellName = " [" + lvlstr + spellName + spacestr + dstr + mystr + usesStr + "]";
                            } catch (maperr) {
                                _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.resetCommandMacro error creating link name:", maperr);
                            } finally {
                                spellObj.pcChatLink = spellName + "(~@{character_id}|repeating_spells_" + spellObj.id + "_roll)";
                                spellObj.npcChatLink = spellName + "(~@{character_id}|repeating_spells_" + spellObj.id + "_npc-roll)";
                                return spellObj;
                            }
                        }).value();
                        if (!customSorted) {
                            spellsByClass = _underscore2.default.sortBy(spellsByClass, 'level');
                        }
                        spellsByClass = _underscore2.default.chain(spellsByClass).groupBy('spellClassstr').mapObject(function (classArray) {
                            return _underscore2.default.chain(classArray).sortBy(groupBySchool ? 'school' : 'levelstr').groupBy(groupBySchool ? 'school' : 'levelstr').value();
                        }).value();

                        //TAS.debug("#############################");
                        //TAS.debug(spellsByClass);
                        //TAS.debug("#############################");

                        //was 2 sets of 3 reduces but can do this faster with 3 each loops and populating both at once 
                        spellsPC = {};
                        spellsNPC = {};
                        rollTemplateCounter = 10;
                        _underscore2.default.each(spellsByClass, function (groupList, classGroup) {
                            var pcstr = "",
                                npcstr = "";
                            _underscore2.default.each(groupList, function (spellList, groupName) {
                                rollTemplateCounter++;
                                pcstr += " {{row" + rollTemplateCounter + "=**" + groupName + "**}}";
                                npcstr += " {{row" + rollTemplateCounter + "=**" + groupName + "**}}";
                                rollTemplateCounter++;
                                pcstr += " {{row" + rollTemplateCounter + "=";
                                npcstr += " {{row" + rollTemplateCounter + "=";
                                _underscore2.default.each(spellList, function (spellObj) {
                                    pcstr += spellObj.pcChatLink;
                                    npcstr += spellObj.npcChatLink;
                                });
                                pcstr += "}}";
                                npcstr += "}}";
                            });
                            spellsPC[classGroup] = pcstr;
                            spellsNPC[classGroup] = npcstr;
                        });
                        //TAS.debug("#############################");
                        //TAS.debug(spellsPC,spellsNPC);
                        //TAS.debug("#############################");

                        for (i = 0; i < 3; i++) {
                            tempstr = pcBaseMacro[i] + spellsPC['class' + i];
                            if (tempstr && configV["spellclass-" + i + "-book"].slice(13) !== tempstr.slice(13)) {
                                attrs["spellclass-" + i + "-book"] = tempstr;
                            } else if (!tempstr && configV["spellclass-" + i + "-book"].slice(13) !== pcBaseMacro[i].slice(13)) {
                                attrs["spellclass-" + i + "-book"] = "";
                            }
                            tempstr = npcBaseMacro[i] + spellsNPC['class' + i];
                            if (tempstr && configV["spellclass-" + i + "-book-npc"].slice(13) !== tempstr.slice(13)) {
                                attrs["spellclass-" + i + "-book-npc"] = tempstr;
                            } else if (!tempstr && configV["spellclass-" + i + "-book-npc"].slice(13) !== npcBaseMacro[i].slice(13)) {
                                attrs["spellclass-" + i + "-book-npc"] = "";
                            }
                        }
                        if (_underscore2.default.size(attrs) > 0) {
                            setAttrs(attrs, {
                                silent: true
                            }, done);
                        } else {
                            done();
                        }
                    } catch (err) {
                        _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.resetCommandMacro", err);
                        done();
                    }
                });
            });
        });
    });
}

/** update spells if a user changes "uses" on spell row
 * @param {string} dummy normally id but not used
 * @param {map} eventInfo from event, not used
 * @param {function} callbackwhen done
 * @param {boolean} silently if you want to update silently
 */
function updateSpellsPerDay(dummy, eventInfo, callback, silently) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSpells.updateSpellsPerDay");
        if (typeof callback === "function") {
            callback();
        }
    }),
        fields = ['total_spells_manually', 'repeating_spells_used', 'repeating_spells_spellclass_number', 'repeating_spells_spell_level', 'repeating_spells_slot', 'repeating_spells_metamagic'];
    getAttrs(fields, function (v) {
        var classNum = 0,
            spellLevel,
            slot = 0,
            metamagic = 0,
            fieldname = '',
            fieldname2 = '',
            initialtot = {};
        _exportsLoaderTASTheAaronSheet2.default.debug("PFSpells.updateSpellsPerDay: ", v);
        if (!parseInt(v.total_spells_manually, 10)) {
            spellLevel = parseInt(v.repeating_spells_spell_level, 10);
            _exportsLoaderTASTheAaronSheet2.default.debug("total spells manually is off spellLEvel is " + spellLevel);
            if (!isNaN(spellLevel)) {
                classNum = parseInt(v.repeating_spells_spellclass_number, 10) || 0;
                metamagic = parseInt(v.repeating_spells_metamagic, 10) || 0;
                if (metamagic) {
                    slot = parseInt(v.repeating_spells_slot, 10);
                    if (!isNaN(slot)) {
                        spellLevel = slot;
                    }
                }
                //now update the spells per day for the associated class idx and spell level
                fieldname = "spellclass-" + classNum + "-level-" + spellLevel + "-spells-per-day";
                fieldname2 = "spellclass-" + classNum + "-level-" + spellLevel + "-spells-prepared";
                initialtot[fieldname] = 0;
                initialtot[fieldname2] = 0;
                _exportsLoaderTASTheAaronSheet2.default.debug("about to set " + fieldname + ", and " + fieldname2);
                _exportsLoaderTASTheAaronSheet2.default.repeating('spells').attrs(fieldname, fieldname2).fields('row_id', 'used', 'spell_level', 'metamagic', 'slot').reduce(function (m, r) {
                    try {
                        if (r.I.spell_level === spellLevel || r.I.metamagic && r.I.slot === spellLevel) {
                            m += r.I.used;
                            // m[fieldname2]+=r.I.used;
                            _exportsLoaderTASTheAaronSheet2.default.debug("adding " + r.I.used);
                        }
                        _exportsLoaderTASTheAaronSheet2.default.debug(fieldname + " now at " + m); //, m);
                    } catch (innererr) {
                        _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.updateSpellsPerDay innererr", innererr);
                    } finally {
                        return m;
                    }
                }, 0, function (m, r, a) {
                    a.S[fieldname] = m;
                    a.S[fieldname2] = m;
                }).execute(done);
            } else {
                done();
            }
        } else {
            done();
        }
    });
}

function getSpellTotals(ids, v, setter) {
    var doNotProcess = 0,
        casterTypeMap = { 'spontaneous': 1, 'prepared': 2 },
        casterTypes = [0, 0, 0],
        totalPrepped = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        totalListed = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];
    try {
        doNotProcess = parseInt(v.total_spells_manually, 10) || 0;
        casterTypes[0] = parseInt(v['spellclass-0-casting_type'], 10) || 0;
        if (parseInt(v.spellclasses_multiclassed, 10)) {
            casterTypes[1] = parseInt(v['spellclass-1-casting_type'], 10) || 0;
            casterTypes[2] = parseInt(v['spellclass-2-casting_type'], 10) || 0;
        }
        _underscore2.default.each(ids, function (id) {
            var prefix = "repeating_spells_" + SWUtils.getRepeatingIDStr(id),
                spellLevel,
                classNum = 0,
                metamagic = 0,
                slot,
                uses = 0;
            try {
                spellLevel = parseInt(v[prefix + "spell_level"], 10);
                if (!isNaN(spellLevel)) {
                    classNum = parseInt(v[prefix + "spellclass_number"], 10) || 0;
                    metamagic = parseInt(v[prefix + "metamagic"], 10) || 0;
                    slot = parseInt(v[prefix + "slot"], 10);
                    if (metamagic && !isNaN(slot)) {
                        spellLevel = slot;
                    }
                    totalListed[classNum][spellLevel] += 1;
                    if (!doNotProcess) {
                        uses = parseInt(v[prefix + "used"], 10) || 0;
                        totalPrepped[classNum][spellLevel] += uses;
                    }
                } else {
                    _exportsLoaderTASTheAaronSheet2.default.warn("PFSpells.getSpellTotals: Spelllevel NAN: spellLevel:" + spellLevel);
                }
            } catch (err2) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.getSpellTotals err2", err2);
            }
        });

        _underscore2.default.each(_PFConst2.default.spellClassIndexes, function (classidx) {
            _underscore2.default.each(spellLevels, function (spellLevel) {
                var prefix = "spellclass-" + classidx + "-level-" + spellLevel,
                    total = 0,
                    prepped = 0,
                    perday = 0;
                total = parseInt(v[prefix + "-total-listed"], 10) || 0;
                if (total !== totalListed[classidx][spellLevel]) {
                    setter[prefix + "-total-listed"] = totalListed[classidx][spellLevel];
                }
                //prepped  = parseInt(v[prefix + "-spells-prepared"], 10) || 0;
                perday = parseInt(v[prefix + "-spells-per-day"], 10) || 0;
                if (casterTypes[classidx] > 0 && !doNotProcess) {
                    //if (prepped !== totalPrepped[classidx][spellLevel]) {
                    //    setter[prefix + "-spells-prepared"] = totalPrepped[classidx][spellLevel];
                    //}
                    if (perday !== totalPrepped[classidx][spellLevel]) {
                        setter[prefix + "-spells-per-day"] = totalPrepped[classidx][spellLevel];
                    }
                } else {
                    //if (prepped !== 0){
                    //    setter[prefix + "-spells-prepared"] =0;
                    //}
                    if (perday !== 0) {
                        setter[prefix + "-spells-per-day"] = 0;
                    }
                }
            });
        });
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.getSpellTotals", err);
    } finally {
        return setter;
    }
}

function resetSpellsTotals(dummy, eventInfo, callback, silently) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSpells.resetSpellsTotals");
        if (typeof callback === "function") {
            callback();
        }
    });

    getSectionIDs("repeating_spells", function (ids) {
        var fields = ['total_spells_manually', 'spellclasses_multiclassed', 'spellclass-0-casting_type', 'spellclass-1-casting_type', 'spellclass-2-casting_type'],
            rowattrs = ['spellclass_number', 'spell_level', 'slot', 'metamagic', 'used'];
        try {
            _underscore2.default.each(ids, function (id) {
                var prefix = "repeating_spells_" + SWUtils.getRepeatingIDStr(id);
                _underscore2.default.each(rowattrs, function (attr) {
                    fields.push(prefix + attr);
                });
            });
            _underscore2.default.each(_PFConst2.default.spellClassIndexes, function (classidx) {
                _underscore2.default.each(spellLevels, function (spellLevel) {
                    fields.push("spellclass-" + classidx + "-level-" + spellLevel + "-total-listed");
                    fields.push("spellclass-" + classidx + "-level-" + spellLevel + "-spells-prepared");
                    fields.push("spellclass-" + classidx + "-level-" + spellLevel + "-spells-per-day");
                });
            });
            getAttrs(fields, function (v) {
                var setter = {};
                try {
                    setter = getSpellTotals(ids, v, setter);
                    if (_underscore2.default.size(setter)) {
                        setAttrs(setter, _PFConst2.default.silentParams, done);
                    } else {
                        done();
                    }
                } catch (innererr) {
                    _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.resetSpellsTotals innererror:", innererr);
                    done();
                }
            });
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.resetSpellsTotals:", err);
            done();
        }
    });
}
/* ******************************** REPEATING SPELL FUNCTIONS ********************************** */
function setAttackEntryVals(spellPrefix, weaponPrefix, v, setter, noName) {
    var notes = "",
        attackType = "";
    setter = setter || {};
    try {
        attackType = PFUtils.findAbilityInString(v[spellPrefix + "spell-attack-type"]);
        if (v[spellPrefix + "name"]) {
            if (!noName) {
                setter[weaponPrefix + "name"] = v[spellPrefix + "name"];
            }
            setter[weaponPrefix + "source-spell-name"] = v[spellPrefix + "name"];
        }
        if (attackType) {
            setter[weaponPrefix + "attack-type"] = v[spellPrefix + "spell-attack-type"];
            if (/CMB/i.test(attackType)) {
                setter[weaponPrefix + "vs"] = "cmd";
            } else {
                setter[weaponPrefix + "vs"] = "touch";
            }
        }
        if (v[spellPrefix + "range_numeric"]) {
            setter[weaponPrefix + "range"] = v[spellPrefix + "range_numeric"];
        }
        if (v[spellPrefix + "range"] && v[spellPrefix + "range_pick"] === "see_text") {
            notes += "Range:" + v[spellPrefix + "range"];
        }

        if (v[spellPrefix + "damage-macro-text"]) {
            setter[weaponPrefix + "precision_dmg_macro"] = v[spellPrefix + "damage-macro-text"];
            if (attackType) {
                setter[weaponPrefix + "critical_dmg_macro"] = v[spellPrefix + "damage-macro-text"];
            }
        }
        if (v[spellPrefix + "damage-type"]) {
            setter[weaponPrefix + "precision_dmg_type"] = v[spellPrefix + "damage-type"];
            if (attackType) {
                setter[weaponPrefix + "critical_dmg_type"] = v[spellPrefix + "damage-type"];
            }
        }
        if (v[spellPrefix + "save"]) {
            notes += "Save: " + v[spellPrefix + "save"] + " DC: " + v[spellPrefix + "savedc"];
        }
        if (v[spellPrefix + "sr"]) {
            if (notes) {
                notes += ", ";
            }
            notes += "Spell resist:" + v[spellPrefix + "sr"];
        }
        if (notes) {
            setter[weaponPrefix + "notes"] = notes;
        }
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.setAttackEntryVals", err);
    } finally {
        return setter;
    }
}
/*Triggered from a button in repeating spells */
function createAttackEntryFromRow(id, callback, silently, eventInfo, weaponId) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSpells.createAttackEntryFromRow");
        if (typeof callback === "function") {
            callback();
        }
    }),
        attribList = [],
        itemId = id || (eventInfo ? SWUtils.getRowId(eventInfo.sourceAttribute) : ""),
        idStr = SWUtils.getRepeatingIDStr(id),
        item_entry = 'repeating_spells_' + idStr,
        attributes = ["range_pick", "range", "range_numeric", "damage-macro-text", "damage-type", "sr", "savedc", "save"],
        commonAttributes = ["spell-attack-type", "name"];

    //TAS.debug("at PFSpells creatattack entry ");
    attributes.forEach(function (attr) {
        attribList.push(item_entry + attr);
    });
    commonAttributes.forEach(function (attr) {
        attribList.push(item_entry + attr);
    });
    //TAS.debug("attribList=" + attribList);
    getAttrs(attribList, function (v) {
        var newRowId = "",
            setter = {},
            prefix = "repeating_weapon_",
            idStr = "",
            params = {};
        try {
            //TAS.debug("at PFSpells.createAttackEntryFromRow",v);
            if (!PFUtils.findAbilityInString(v[item_entry + "spell-attack-type"]) && !v[item_entry + "damage-macro-text"]) {
                _exportsLoaderTASTheAaronSheet2.default.warn("no attack to create for spell " + v[item_entry + "name"] + ", " + itemId);
            } else {
                if (!weaponId) {
                    newRowId = generateRowID();
                } else {
                    newRowId = weaponId;
                }
                idStr = newRowId + "_";
                prefix += idStr;
                setter = setAttackEntryVals(item_entry, prefix, v, setter, weaponId);
                setter[prefix + "source-spell"] = itemId;
                setter[prefix + "group"] = "Spell";
                setter[prefix + 'link_type'] = PFAttacks.linkedAttackType.spell;
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.createAttackEntryFromRow", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                setter[item_entry + "create-attack-entry"] = 0;
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                setAttrs(setter, {}, function () {
                    //can do these in parallel
                    PFAttackOptions.resetOption(newRowId);
                    PFAttackGrid.resetCommandMacro();
                    done();
                });
            } else {
                setter[item_entry + "create-attack-entry"] = 0;
                setAttrs(setter, _PFConst2.default.silentParams, done);
            }
        }
    });
}
function updateAssociatedAttack(id, callback, silently, eventInfo) {
    var done = _underscore2.default.once(function () {
        //TAS.debug("leaving PFSpells.updateAssociatedAttack");
        if (typeof callback === "function") {
            callback();
        }
    }),
        itemId = id || (eventInfo ? SWUtils.getRowId(eventInfo.sourceAttribute) : ""),
        item_entry = 'repeating_spells_' + SWUtils.getRepeatingIDStr(itemId),
        attrib = eventInfo ? SWUtils.getAttributeName(eventInfo.sourceAttribute) : "",
        attributes = [];
    if (attrib) {
        attributes = [item_entry + attrib];
        if (/range/i.test(attrib)) {
            attributes = [item_entry + 'range_pick', item_entry + 'range', item_entry + 'range_numeric'];
        }
    } else {
        attributes = ["range_pick", "range", "range_numeric", "damage-macro-text", "damage-type", "sr", "savedc", "save", "spell-attack-type", "name"];
    }
    getAttrs(attributes, function (spellVal) {
        getSectionIDs("repeating_weapon", function (idarray) {
            // get the repeating set
            var spellsourcesFields = [];
            spellsourcesFields = _underscore2.default.reduce(idarray, function (memo, currentID) {
                memo.push("repeating_weapon_" + currentID + "_source-spell");
                return memo;
            }, []);
            getAttrs(spellsourcesFields, function (v) {
                var setter = {},
                    params = {},
                    idlist = [];
                try {
                    _underscore2.default.each(idarray, function (currentID) {
                        var prefix = "repeating_weapon_" + currentID + "_";
                        if (v[prefix + "source-spell"] === itemId) {
                            idlist.push(currentID);
                            setter = setAttackEntryVals(item_entry, prefix, spellVal, setter);
                        }
                    });
                    if (silently) {
                        params = _PFConst2.default.silentParams;
                    }
                } catch (err) {
                    _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.updateAssociatedAttack", err);
                } finally {
                    if (_underscore2.default.size(setter) > 0) {
                        setAttrs(setter, params, function () {
                            PFAttackOptions.resetSomeOptions(idlist);
                        });
                    } else {
                        done();
                    }
                }
            });
        });
    });
}
function updatePreparedSpellState(id, eventInfo) {
    getAttrs(["repeating_spells_used", "repeating_spells_spellclass_number", "repeating_spells_prepared_state", "spellclass-0-hide_unprepared", "spellclass-1-hide_unprepared", "spellclass-2-hide_unprepared"], function (values) {
        var uses = parseInt(values.repeating_spells_used, 10) || 0,
            preparedState = parseInt(values.repeating_spells_prepared_state, 10) || 0,
            classnum = values["repeating_spells_spellclass_number"],
            isPrepared = (parseInt(values["spellclass-" + classnum + "-casting_type"], 10) || 0) === 2 ? 1 : 0,
            hideUnprepared = isPrepared * (parseInt(values["spellclass-" + classnum + "-hide_unprepared"], 10) || 0),
            setter = {};
        if (uses > 0 && preparedState === 0) {
            setter["repeating_spells_prepared_state"] = "1";
        } else if (uses < 1 && preparedState !== 0) {
            setter["repeating_spells_prepared_state"] = "0";
        }
        if (_underscore2.default.size(setter)) {
            if (hideUnprepared) {
                setAttrs(setter, _PFConst2.default.silentParams, resetCommandMacro());
            } else {
                setAttrs(setter, {
                    silent: true
                });
            }
        }
    });
}
/** - sets prepared_state to 1 if used has a value > 0 */
function resetSpellsPrepared() {
    getSectionIDs("repeating_spells", function (ids) {
        var fieldarray = [];
        _underscore2.default.each(ids, function (id) {
            var idStr = SWUtils.getRepeatingIDStr(id),
                prefix = "repeating_spells_" + idStr;
            fieldarray.push(prefix + "used");
            fieldarray.push(prefix + "prepared_state");
        });
        getAttrs(fieldarray, function (v) {
            var setter = {};
            _underscore2.default.each(ids, function (id) {
                var idStr = SWUtils.getRepeatingIDStr(id),
                    prefix = "repeating_spells_" + idStr,
                    uses = parseInt(v[prefix + "used"], 10) || 0,
                    preparedState = parseInt(v[prefix + "prepared_state"], 10) || 0,
                    setter = {};
                if (uses > 0 && preparedState === 0) {
                    setter[prefix + "prepared_state"] = "1";
                    //TAS.debug("resetSpellsPrepared, setting to 1:" + prefix);
                } else if (uses < 1 && preparedState !== 0) {
                    setter[prefix + "prepared_state"] = "0";
                }
            });
            if (_underscore2.default.size(setter)) {
                setAttrs(setter, {
                    silent: true
                });
            }
        });
    });
}
/************* SPELL OPTIONS *********************/
/** updates all spells when level or concentration or spell penetration is updated 
*@param {int} classIdx 0..2
*@param {object} eventInfo from on event 
*@param {function} callback when done
*/
function updateSpellsCasterLevelRelated(classIdx, eventInfo, callback) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    //TAS.debug("updateSpellsCasterLevelRelated", eventInfo);
    if (!(classIdx >= 0 && classIdx <= 2) || isNaN(parseInt(classIdx, 10))) {
        done();
        return;
    }
    getAttrs(["spellclass-" + classIdx + "-level-total", "spellclasses_multiclassed", "Concentration-" + classIdx + "-misc", "spellclass-" + classIdx + "-name", "spellclass-" + classIdx + "-SP-mod", "Concentration-" + classIdx + "-def", "Concentration-" + classIdx + "-mod"], function (vout) {
        var classLevel = parseInt(vout["spellclass-" + classIdx + "-level-total"], 10) || 0,
            abilityMod = parseInt(vout["Concentration-" + classIdx + "-mod"], 10) || 0,
            multiclassed = parseInt(vout["spellclasses_multiclassed"], 10) || 0,
            defMod = parseInt(vout["Concentration-" + classIdx + "-def"], 10),
            classConcentrationMisc = parseInt(vout["Concentration-" + classIdx + "-misc"], 10) || 0,
            classSPMisc = parseInt(vout["spellclass-" + classIdx + "-SP-mod"], 10) || 0,
            newClassName = vout["spellclass-" + classIdx + "-name"],
            updateDefensiveCasting = eventInfo ? /\-def$/i.test(eventInfo.sourceAttribute) : false;
        if (classLevel <= 0) {
            done();
            return;
        }
        //TAS.debug("updateSpellsCasterLevelRelated,class:"+classIdx+", class values:",vout);				
        getSectionIDs("repeating_spells", function (ids) {
            var rowFieldAppnd = ['casterlevel', 'CL_misc', 'spell_class_r', 'spellclass_number', 'spellclass', 'range', 'range_numeric', 'range_pick', 'SP-mod', 'SP_misc', 'Concentration_misc', 'Concentration-mod', 'spell_options'],
                fields = _underscore2.default.reduce(ids, function (memo, id) {
                var prefix = "repeating_spells_" + SWUtils.getRepeatingIDStr(id),
                    row;
                row = _underscore2.default.map(rowFieldAppnd, function (field) {
                    return prefix + field;
                });
                return memo.concat(row);
            }, ['spellclass-0-name']);
            getAttrs(fields, function (v) {
                var doneOneRow = _underscore2.default.after(_underscore2.default.size(ids), done),
                    classNumSetter = {},
                    setter = {};
                try {
                    //TAS.debug("updateSpellsCasterLevelRelated,class:"+classIdx+", spells:",v);
                    _underscore2.default.each(ids, function (id) {
                        var prefix = "repeating_spells_" + SWUtils.getRepeatingIDStr(id),
                            classNum = parseInt(v[prefix + "spellclass_number"], 10),
                            classRadio = parseInt(v[prefix + "spell_class_r"], 10),
                            chosenRange = v[prefix + "range_pick"] || "",
                            currRange = parseInt(v[prefix + "range_numeric"], 10) || 0,
                            spellConcentrationMisc = parseInt(v[prefix + "Concentration_misc"], 10) || 0,
                            optionText = v[prefix + "spell_options"],
                            setOption = 0,
                            tempstr = "",
                            casterlevel = 0,
                            newcasterlevel = 0,
                            newConcentration = 0,
                            newSP = 0,
                            newClassName = "",
                            newRange = 0;
                        try {
                            if (isNaN(classNum)) {
                                classNum = 0;
                                classNumSetter[prefix + "spellclass_number"] = 0;
                                classNumSetter[prefix + "spellclass"] = v['spellclass-0-name'];
                            } else if (!multiclassed || classNum === classIdx) {
                                if (classNum !== classRadio || isNaN(classRadio)) {
                                    setter[prefix + "spell_class_r"] = classNum;
                                }
                                newClassName = v['spellclass-' + classNum + '-name'];
                                if (newClassName !== v[prefix + "spellclass"]) {
                                    setter[prefix + "spellclass"] = newClassName;
                                    if (optionText) {
                                        optionText = optionText.replace(PFSpellOptions.optionTemplateRegexes.spellclass, PFSpellOptions.optionTemplates.spellclass.replace("REPLACE", SWUtils.escapeForRollTemplate(v[prefix + "spellclass"])));
                                        setOption = 1;
                                    }
                                }
                                casterlevel = parseInt(v[prefix + "casterlevel"], 10);
                                newcasterlevel = classLevel + (parseInt(v[prefix + "CL_misc"], 10) || 0);
                                if (newcasterlevel < 1) {
                                    newcasterlevel = 1;
                                }
                                if (newcasterlevel !== casterlevel || isNaN(casterlevel)) {
                                    casterlevel = newcasterlevel;
                                    setter[prefix + "casterlevel"] = newcasterlevel;
                                    if (optionText) {
                                        optionText = optionText.replace(PFSpellOptions.optionTemplateRegexes.casterlevel, PFSpellOptions.optionTemplates.casterlevel.replace("REPLACE", newcasterlevel));
                                        optionText = optionText.replace(PFSpellOptions.optionTemplateRegexes.casterlevel_chk, PFSpellOptions.optionTemplates.casterlevel_chk.replace("REPLACE", newcasterlevel));
                                        setOption = 1;
                                    }
                                }
                                newRange = PFUtils.findSpellRange(v[prefix + "range"], chosenRange, casterlevel) || 0;
                                if (newRange !== currRange) {
                                    setter[prefix + "range_numeric"] = newRange;
                                    if (optionText) {
                                        optionText = optionText.replace(PFSpellOptions.optionTemplateRegexes.range, PFSpellOptions.optionTemplates.range.replace("REPLACE", newRange));
                                        setOption = 1;
                                    }
                                }
                                if (updateDefensiveCasting && optionText) {
                                    if (defMod > 0) {
                                        tempstr = PFSpellOptions.optionTemplates.cast_def.replace("REPLACE", defMod);
                                    } else {
                                        tempstr = "{{cast_def=}}";
                                    }
                                    if (optionText.indexOf("{{cast_def=") >= 0) {
                                        optionText = optionText.replace(PFSpellOptions.optionTemplateRegexes.cast_def, tempstr);
                                    } else {
                                        optionText += tempstr;
                                    }
                                    setOption = 1;
                                }
                                newConcentration = newcasterlevel + abilityMod + classConcentrationMisc + spellConcentrationMisc;
                                if (newConcentration !== (parseInt(v[prefix + "Concentration-mod"], 10) || 0)) {
                                    setter[prefix + "Concentration-mod"] = newConcentration;
                                    if (optionText) {
                                        optionText = optionText.replace(PFSpellOptions.optionTemplateRegexes.Concentration, PFSpellOptions.optionTemplates.Concentration.replace("REPLACE", newConcentration));
                                        optionText = optionText.replace(PFSpellOptions.optionTemplateRegexes.Concentration_chk, PFSpellOptions.optionTemplates.Concentration_chk.replace("REPLACE", newConcentration));
                                        setOption = 1;
                                    }
                                }
                                newSP = classSPMisc + (parseInt(v[prefix + "SP_misc"], 10) || 0);
                                if (newSP !== (parseInt(v[prefix + "SP-mod"], 10) || 0)) {
                                    setter[prefix + "SP-mod"] = newSP;
                                    if (optionText) {
                                        optionText = optionText.replace(PFSpellOptions.optionTemplateRegexes.spellPen, PFSpellOptions.optionTemplates.spellPen.replace("REPLACE", newSP));
                                        setOption = 1;
                                    }
                                }
                                if (setOption) {
                                    setter[prefix + "spell_options"] = optionText;
                                }
                            }
                        } catch (innererror) {
                            _exportsLoaderTASTheAaronSheet2.default.error("updateSpellsCasterLevelRelated innererror on id: " + id, innererror);
                        }
                    });
                } catch (err) {
                    _exportsLoaderTASTheAaronSheet2.default.error("updateSpellsCasterLevelRelated error:", err);
                } finally {
                    if (_underscore2.default.size(setter) > 0 || _underscore2.default.size(classNumSetter) > 0) {
                        //TAS.debug"updateSpellsCasterLevelRelated, setting:",classNumSetter,setter);
                        if (_underscore2.default.size(classNumSetter) > 0) {
                            setAttrs(classNumSetter, {}, done);
                        }
                        if (_underscore2.default.size(setter) > 0) {
                            setAttrs(setter, _PFConst2.default.silentParams, done);
                        }
                    } else {
                        done();
                    }
                }
            });
        });
    });
}
/** updates all spells when caster ability or DCs are updated 
 *@param {int} classIdx 0..2
 *@param {map} eventInfo from on event 
 *@param {function} callback when done
 */
function updateSpellsCasterAbilityRelated(classIdx, eventInfo, callback) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    //TAS.debug("updateSpellsCasterAbilityRelated", eventInfo);
    if (!(classIdx >= 0 && classIdx <= 2) || isNaN(parseInt(classIdx, 10))) {
        done();
        return;
    }
    getAttrs(["spellclass-" + classIdx + "-level-total", "Concentration-" + classIdx + "-mod", "Concentration-" + classIdx + "-misc", "spellclasses_multiclassed"], function (vout) {
        var abilityMod, classConcentrationMisc, multiclassed;
        try {
            abilityMod = parseInt(vout["Concentration-" + classIdx + "-mod"], 10) || 0;
            classConcentrationMisc = parseInt(vout["Concentration-" + classIdx + "-misc"], 10) || 0;
            multiclassed = parseInt(vout["spellclasses_multiclassed"], 10) || 0;
            if (!parseInt(vout["spellclass-" + classIdx + "-level-total"], 10)) {
                done();
                return;
            }
            //var updateAbilityScore = eventInfo?(/concentration\-[012]\-mod/i.test(eventInfo.sourceAttribute)):true;
            getSectionIDs("repeating_spells", function (ids) {
                var fields = [];
                //TAS.debug("updateSpellsCasterAbilityRelated",classIdx,eventInfo);
                //TAS.debug(ids);
                _underscore2.default.each(ids, function (id) {
                    var prefix = "repeating_spells_" + SWUtils.getRepeatingIDStr(id);
                    fields = fields.concat([prefix + "spellclass_number", prefix + "spell_level", prefix + "spell_level_r", prefix + "spellclass_number", prefix + "casterlevel", prefix + "DC_misc", prefix + "savedc", prefix + "Concentration-mod", prefix + "Concentration_misc", prefix + "spell_options"]);
                });
                getAttrs(fields, function (v) {
                    var newConcentration = 0,
                        casterlevel = 0,
                        setter = {};
                    try {
                        _exportsLoaderTASTheAaronSheet2.default.debug("updateSpellsCasterAbilityRelated,class:" + classIdx + ", spells:", v);
                        _underscore2.default.each(ids, function (id) {
                            var spellLevel = 0,
                                spellLevelRadio = 0,
                                newDC = 0,
                                setOption = 0,
                                currDC = 0,
                                prefix = "repeating_spells_" + SWUtils.getRepeatingIDStr(id),
                                optionText = v[prefix + "spell_options"],
                                spellConcentrationMisc = parseInt(v[prefix + "Concentration_misc"], 10) || 0;
                            try {
                                if (!multiclassed || parseInt(v[prefix + "spellclass_number"], 10) === classIdx) {
                                    spellLevel = parseInt(v[prefix + "spell_level"], 10);
                                    spellLevelRadio = parseInt(v[prefix + "spell_level_r"], 10);
                                    if (isNaN(spellLevel)) {
                                        _exportsLoaderTASTheAaronSheet2.default.warn("spell level is NaN for " + prefix);
                                        if (spellLevelRadio !== -1 || isNaN(spellLevelRadio)) {
                                            setter[prefix + "spell_level_r"] = "-1";
                                            //setter[prefix + "savedc"] = 0;
                                        }
                                    } else {
                                        if (spellLevel !== spellLevelRadio || isNaN(spellLevelRadio)) {
                                            setter[prefix + "spell_level_r"] = spellLevel;
                                        }
                                        newDC = 10 + spellLevel + abilityMod + (parseInt(v[prefix + "DC_misc"], 10) || 0);
                                        currDC = parseInt(v[prefix + "savedc"], 10) || 0;
                                        if (newDC !== currDC) {
                                            setter[prefix + "savedc"] = newDC;
                                            if (optionText) {
                                                optionText = optionText.replace(PFSpellOptions.optionTemplateRegexes.dc, PFSpellOptions.optionTemplates.dc.replace("REPLACE", newDC));
                                                setOption = 1;
                                            }
                                        }
                                        casterlevel = parseInt(v[prefix + "casterlevel"], 10) || 0;
                                        if (!isNaN(casterlevel)) {
                                            newConcentration = casterlevel + abilityMod + classConcentrationMisc + spellConcentrationMisc;
                                            if (newConcentration !== (parseInt(v[prefix + "Concentration-mod"], 10) || 0)) {
                                                setter[prefix + "Concentration-mod"] = newConcentration;
                                                if (optionText) {
                                                    optionText = optionText.replace(PFSpellOptions.optionTemplateRegexes.Concentration, PFSpellOptions.optionTemplates.Concentration.replace("REPLACE", newConcentration));
                                                    optionText = optionText.replace(PFSpellOptions.optionTemplateRegexes.Concentration_chk, PFSpellOptions.optionTemplates.Concentration_chk.replace("REPLACE", newConcentration));
                                                    setOption = 1;
                                                }
                                            }
                                        } else {
                                            _exportsLoaderTASTheAaronSheet2.default.warn("spell casterlevel is NaN for " + prefix);
                                            if ((parseInt(v[prefix + "Concentration-mod"], 10) || 0) !== 0) {
                                                setter[prefix + "Concentration-mod"] = "";
                                            }
                                        }
                                    }
                                    if (setOption) {
                                        //TAS.debug("setting option for id "+ id +" to "+optionText);
                                        setter[prefix + "spell_options"] = optionText;
                                    }
                                }
                            } catch (innererror) {
                                _exportsLoaderTASTheAaronSheet2.default.error("updateSpellsCasterAbilityRelated innererror on id:" + id, innererror);
                            }
                        });
                    } catch (miderr) {
                        _exportsLoaderTASTheAaronSheet2.default.error("updateSpellsCasterAbilityRelated miderr :", miderr);
                    } finally {
                        if (_underscore2.default.size(setter) > 0) {
                            _exportsLoaderTASTheAaronSheet2.default.debug("updateSpellsCasterAbilityRelated setting:", setter);
                            setAttrs(setter, _PFConst2.default.silentParams, done());
                        } else {
                            done();
                        }
                    }
                });
            });
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("updateSpellsCasterAbilityRelated outer error:", err);
        }
    });
}
//faster smaller than updateSpell
function updateSpellSlot(id, eventInfo, callback) {
    var outerdone = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    }),
        done = _underscore2.default.once(function () {
        resetCommandMacro(eventInfo, outerdone);
    }),
        idStr = SWUtils.getRepeatingIDStr(id),
        prefix = "repeating_spells_" + idStr,
        spellLevelRadioField = prefix + "spell_level_r",
        spellSlotField = prefix + "slot",
        spellLevelField = prefix + "spell_level",
        metamagicField = prefix + "metamagic";
    //TAS.debug("updateSpellSlot", eventInfo, id);
    getAttrs([spellSlotField, spellLevelField, spellLevelRadioField], function (v) {
        var slot = parseInt(v[spellSlotField], 10),
            level = parseInt(v[spellLevelField], 10),
            metamagic = parseInt(v[metamagicField], 10) || 0,
            spellLevelRadio = parseInt(v[spellLevelRadioField], 10) || 0,
            setter = {};
        try {
            //TAS.debug("updateSpellSlot", v);
            if (metamagic) {
                if (isNaN(level)) {
                    slot = -1;
                }
                if (isNaN(slot)) {
                    slot = level;
                    setter[spellSlotField] = level;
                    setAttrs(setter, {
                        silent: true
                    }, done);
                    return;
                }
                if (slot !== spellLevelRadio) {
                    //TAS.debug("updating slot to " + slot);
                    setter[spellLevelRadioField] = slot;
                    if (spellLevelRadio === -1) {
                        setter["spells_tab"] = slot;
                    }
                    setAttrs(setter, {
                        silent: true
                    }, done);
                    return;
                }
            }
            outerdone();
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("updateSpellSlot", err);
            outerdone();
        }
    });
}
/** updates a spell
 *@param {string} id optional, pass id if looping through list of IDs. Null if context is row itself. 
 *@param {eventInfo} eventInfo ACTUALLY USED : if not present forces recalc of everything
 *@param {function} callback - to call when done.
 *@param {bool} doNotUpdateTotals - if true do NOT call resetSpellsTotals() and resetCommandMacro() at end, otherwise do.
 */
function updateSpell(id, eventInfo, callback, doNotUpdateTotals) {
    var spellLevelUndefined = false,
        classNumWasUndefined = false,
        done = _underscore2.default.once(function () {
        //TAS.debug("leaving PFSpells.updateSpell: id:" + id + " spelllevelundefined=" + spellLevelUndefined);
        //these asynchronous functions can be called at same time as callback.
        if (!spellLevelUndefined) {
            PFSpellOptions.resetOption(id, eventInfo);
            if (!doNotUpdateTotals) {
                resetSpellsTotals();
                resetCommandMacro();
            }
        }
        if (typeof callback === "function") {
            callback();
        }
    }),
        idStr = SWUtils.getRepeatingIDStr(id),
        prefix = "repeating_spells_" + idStr,
        classNameField = prefix + "spellclass",
        classRadioField = prefix + "spell_class_r",
        classNumberField = prefix + "spellclass_number",
        casterlevelField = prefix + "casterlevel",
        spellLevelField = prefix + "spell_level",
        spellLevelRadioField = prefix + "spell_level_r",
        dcMiscField = prefix + "DC_misc",
        currDCField = prefix + "savedc",
        fields = [classNumberField, classRadioField, classNameField, casterlevelField, prefix + "CL_misc", prefix + "spellclass_number", prefix + "range_pick", prefix + "range", prefix + "range_numeric", prefix + "SP-mod", prefix + "SP_misc", prefix + "Concentration_misc", prefix + "Concentration-mod", prefix + "spell_options", prefix + "used", prefix + "slot", prefix + "metamagic", spellLevelField, spellLevelRadioField, dcMiscField, currDCField, "spellclass-0-level-total", "spellclass-1-level-total", "spellclass-2-level-total", "spellclass-0-SP-mod", "spellclass-1-SP-mod", "spellclass-2-SP-mod", "Concentration-0-mod", "Concentration-1-mod", "Concentration-2-mod", "Concentration-0-misc", "Concentration-1-misc", "Concentration-2-misc", "Concentration-0-def", "Concentration-1-def", "Concentration-2-def", "spellclass-0-name", "spellclass-1-name", "spellclass-2-name"];
    getAttrs(fields, function (v) {
        var setter = {},
            baseClassNum,
            classNum = 0,
            classRadio,
            currClassName = "",
            className = "",
            baseSpellLevel,
            spellLevel,
            spellSlot,
            metaMagic,
            spellLevelRadio,
            currCasterLevel,
            casterlevel,
            spellAbilityMod,
            newDC = 10,
            levelSlot,
            currRange,
            currChosenRange,
            newSP = 0,
            newConcentration = 0,
            updateClass = false,
            updateClassLevel = false,
            updateRange = false,
            updateSP = false,
            updateConcentration = false,
            updateSpellLevel = false,
            updateDC = false,
            updateSlot = false,
            updateStr = "",
            tempMatches,
            hadToSetClass = false,
            newRange = 0;
        try {
            baseClassNum = parseInt(v[classNumberField], 10);
            classNum = baseClassNum || 0;
            classRadio = parseInt(v[classRadioField], 10);
            baseSpellLevel = parseInt(v[spellLevelField], 10);
            spellLevel = baseSpellLevel || 0;
            spellSlot = parseInt(v[prefix + "slot"], 10);
            metaMagic = parseInt(v[prefix + "metamagic"], 10) || 0;
            spellLevelRadio = parseInt(v[spellLevelRadioField], 10);
            currCasterLevel = parseInt(v[casterlevelField], 10);
            casterlevel = currCasterLevel || 0;
            spellAbilityMod = parseInt(v["Concentration-" + classNum + "-mod"], 10) || 0;
            levelSlot = metaMagic ? spellSlot : spellLevel;
            currRange = parseInt(v[prefix + "range_numeric"], 10) || 0;
            currChosenRange = v[prefix + "range_pick"] || "blank";
            //cannot perform calculations
            if (isNaN(baseClassNum) && isNaN(baseSpellLevel)) {
                _exportsLoaderTASTheAaronSheet2.default.warn("cannot update spell! id:" + id + " both class and level are not numbers", v);
                return;
            }
            //TAS.debug("spell slot:" + spellSlot + ", metamagic:" + metaMagic + ", spelllevel:" + spellLevel + ", radio:" + spellLevelRadio);
            //if looping through with id then force update of all fields.
            if (!eventInfo) {
                updateClass = true;
            }
            //if class is not set, then set to default class 0
            if (isNaN(baseClassNum)) {
                //force to zero?
                classNumWasUndefined = true;
                _exportsLoaderTASTheAaronSheet2.default.debug("#########################", "Forcing spell " + id + " to class 0");
                setter[classNumberField] = String(classNum);
                updateClass = true;
                hadToSetClass = true;
            }
            if (classNum !== classRadio) {
                setter[classRadioField] = classNum;
                updateClass = true;
            }
            if (!updateClass && eventInfo && eventInfo.sourceAttribute) {
                updateStr = eventInfo.sourceAttribute.toLowerCase();
                tempMatches = updateStr.match(/lvlstr|category|range_pick|range|sp_misc|cl_misc|spellclass_number|spell_level|dc_misc|concen|slot/);
                if (tempMatches && tempMatches[0]) {
                    switch (tempMatches[0]) {
                        case 'range_pick':
                        case 'range':
                            updateRange = true;
                            break;
                        case 'sp_misc':
                            updateSP = true;
                            break;
                        case 'cl_misc':
                            updateClassLevel = true;
                            break;
                        case 'spellclass_number':
                            updateClass = true;
                            break;
                        case 'concen':
                            updateConcentration = true;
                            break;
                        case 'spell_level':
                            updateSpellLevel = true;
                            break;
                        case 'dc_misc':
                            updateDC = true;
                            break;
                        case 'slot':
                            updateSlot = true;
                            break;
                        case 'lvlstr':
                        case 'category':
                            updateClass = true;
                            updateClassLevel = true;
                            updateConcentration = true;
                            updateSP = true;
                            updateDC = true;
                            updateRange = true;
                            break;
                        default:
                            updateClass = true; //unknown just update all
                    }
                } else {
                    //if we called from importFromCompendium then it's lvlstr
                    _exportsLoaderTASTheAaronSheet2.default.warn("Unimportant field updated, do not update row: " + eventInfo.sourceAttribute);
                    done();
                    return;
                }
            }
            if (isNaN(baseSpellLevel)) {
                if (spellLevelRadio !== -1) {
                    setter[spellLevelRadioField] = "-1";
                    setter[prefix + "slot"] = "";
                }
                spellLevelUndefined = true;
            } else if (!metaMagic && (updateSpellLevel || spellLevel !== spellLevelRadio)) {
                //TAS.debug("reset radio field after spell update");
                setter[spellLevelRadioField] = spellLevel;
                if (spellLevelRadio === -1) {
                    setter["spells_tab"] = spellLevel;
                }
                updateSpellLevel = true;
            } else if (metaMagic && !isNaN(spellSlot) && (updateSlot || spellSlot !== spellLevelRadio)) {
                //TAS.debug("reset radio field after spell SLOT update");
                setter[spellLevelRadioField] = spellSlot;
                if (spellLevelRadio === -1) {
                    setter["spells_tab"] = spellSlot;
                }
            }
            //keep slot in sync
            if (!spellLevelUndefined) {
                if (isNaN(spellSlot)) {
                    setter[prefix + "slot"] = spellLevel;
                    spellSlot = spellLevel;
                    updateSlot = true;
                } else if (!metaMagic && (updateSpellLevel || spellSlot !== spellLevel)) {
                    setter[prefix + "slot"] = spellLevel;
                }
            }
            //classname
            className = v["spellclass-" + classNum + "-name"];
            if (updateClass) {
                currClassName = v[classNameField];
                if (currClassName !== className) {
                    _exportsLoaderTASTheAaronSheet2.default.debug("setting class name field, should be doing this if classnum was undefined");
                    setter[classNameField] = className;
                }
            }
            if (isNaN(currCasterLevel)) {
                updateClassLevel = true;
            }
            //set caster level
            if (updateClass || updateClassLevel) {
                casterlevel = (parseInt(v["spellclass-" + classNum + "-level-total"], 10) || 0) + (parseInt(v[prefix + "CL_misc"], 10) || 0);
                if (casterlevel < 1) {
                    casterlevel = 1;
                }
                if (currCasterLevel !== casterlevel || isNaN(currCasterLevel)) {
                    setter[prefix + "casterlevel"] = casterlevel;
                    updateClassLevel = true;
                }
            }
            if (!spellLevelUndefined && (updateClass || updateSpellLevel || updateDC)) {
                newDC = 10 + spellLevel + spellAbilityMod + (parseInt(v[dcMiscField], 10) || 0);
                if (newDC !== (parseInt(v[currDCField], 10) || 0)) {
                    setter[currDCField] = newDC;
                }
            }
            if (updateClass || updateClassLevel || updateConcentration) {
                newConcentration = casterlevel + spellAbilityMod + (parseInt(v["Concentration-" + classNum + "-misc"], 10) || 0) + (parseInt(v[prefix + "Concentration_misc"], 10) || 0);
                if (newConcentration !== (parseInt(v[prefix + "Concentration-mod"], 10) || 0)) {
                    setter[prefix + "Concentration-mod"] = newConcentration;
                }
            }
            if (updateClass || updateRange || updateClassLevel) {
                newRange = PFUtils.findSpellRange(v[prefix + "range"], currChosenRange, casterlevel) || 0;
                if (newRange !== currRange) {
                    setter[prefix + "range_numeric"] = newRange;
                }
            }
            if (updateClass || updateSP || updateClassLevel) {
                newSP = (parseInt(v["spellclass-" + classNum + "-SP-mod"], 10) || 0) + (parseInt(v[prefix + "SP_misc"], 10) || 0);
                if (newSP !== (parseInt(v[prefix + "SP-mod"], 10) || 0)) {
                    setter[prefix + "SP-mod"] = newSP;
                }
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.updateSpell:" + id, err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                setAttrs(setter, {
                    silent: true
                }, done);
            } else {
                done();
            }
        }
    });
}
/** - updates all spells
 *@param {function} callback when done
 *@param {silently} if should call setAttrs with {silent:true}
 *@param {object} eventInfo not used
 */
function updateSpells(callback, silently, eventInfo) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSpells.updateSpells");
        if (typeof callback === "function") {
            callback();
        }
    }),
        doneOne = _underscore2.default.after(3, done);
    getAttrs(['use_spells', 'spellclass-0-exists', 'spellclass-1-exists', 'spellclass-2-exists'], function (v) {
        //TAS.debug"at PFSpells.updateSpells. Existing classes:",v);
        if (parseInt(v.use_spells, 10)) {
            _underscore2.default.times(3, function (n) {
                //TAS.debug("###############", "PFSpells.updateSpells index is: "+n);
                if (parseInt(v['spellclass-' + n + '-exists'], 10)) {
                    updateSpellsCasterAbilityRelated(n, null, function () {
                        updateSpellsCasterLevelRelated(n, null, doneOne);
                    });
                } else {
                    doneOne();
                }
            });
        } else {
            done();
        }
    });
}

function updateSpellsOld(callback, silently, eventInfo) {
    getSectionIDs("repeating_spells", function (ids) {
        var done = _underscore2.default.after(_underscore2.default.size(ids), function () {
            _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSpells.updateSpells after " + _underscore2.default.size(ids) + " rows");
            if (typeof callback === "function") {
                callback();
            }
        });
        _underscore2.default.each(ids, function (id) {
            try {
                updateSpell(id, eventInfo, done, true);
            } catch (err) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFSpells.updateSpells error - should never happen!", err);
                done();
            }
        });
    });
}

/** gets level and class from repeating_spells_spell_lvlstr then updates spell
 * matches class name in compendium against current spell classes in this order:
 * spell class already selected by spell dropdown, spellclass0, spellclass1, spellclass2
 * then sets spell level to the matching level for that class
 * if it cannot find then sets class name to the class level string and updates silently.
 *@param {string} id the id of the row
 *@param {object} eventInfo used to find row id since id param will be null
 */
function importFromCompendium(id, eventInfo) {
    var trueId = "";

    trueId = id || (eventInfo ? SWUtils.getRowId(eventInfo.sourceAttribute) : "");

    getAttrs(["repeating_spells_compendium_category", "repeating_spells_spell_lvlstr", "spellclass-0-name", "spellclass-1-name", "spellclass-2-name", "repeating_spells_range_from_compendium", "repeating_spells_target_from_compendium", "repeating_spells_area_from_compendium", "repeating_spells_effect_from_compendium", "repeating_spells_description"], function (v) {
        var levelStrBase = v["repeating_spells_spell_lvlstr"],
            rangeText = v["repeating_spells_range_from_compendium"],
            areaEffectText = (v["repeating_spells_target_from_compendium"] || "") + (v["repeating_spells_area_from_compendium"] || "") + (v["repeating_spells_effect_from_compendium"] || ""),
            classesInital = [],
            classes = [],
            originalClasses = ["", "", ""],
            classMatch = "",
            level = 0,
            idx = -1,
            foundMatch = false,
            setSilent = {},
            i = 0,
            classesToMatch = {},
            tempclassname = "",
            newRangeSettings,
            hasHunter = false,
            hasDruid = false,
            hasRanger = false,
            minHunterSpellLevel = 99,
            hunterIdx = 99,
            isAttack = false,
            allSame = 1,
            modeLevel = -1,
            counter = 0,
            callUpdateSpell = true;
        //TAS.debug("at pfspells.importFromCompendium",v);
        if (levelStrBase) {
            try {
                levelStrBase = levelStrBase.toLowerCase();
                //get first word in names of classes (since users may put archetypes or other variables in)
                //if (currClass) {classesToMatch[0]=currClass.toLowerCase().replace(/^\s+/,"").match(/\w[^\d]+/)[0];}
                if (v["spellclass-0-name"]) {
                    tempclassname = v["spellclass-0-name"].toLowerCase().replace(/^\s+/, "").match(/\w+/)[0];
                    classesToMatch[tempclassname] = 0;
                    originalClasses[0] = tempclassname;
                    if (/hunter/.test(tempclassname)) {
                        hasHunter = true;
                        hunterIdx = 0;
                    } else if (/druid/.test(tempclassname)) {
                        hasDruid = true;
                    } else if (/ranger/.test(tempclassname)) {
                        hasRanger = true;
                    }
                }
                if (v["spellclass-1-name"]) {
                    tempclassname = v["spellclass-1-name"].toLowerCase().replace(/^\s+/, "").match(/\w+/)[0];
                    classesToMatch[tempclassname] = 1;
                    originalClasses[1] = tempclassname;
                    if (/hunter/.test(tempclassname)) {
                        hasHunter = true;
                        hunterIdx = 1;
                    } else if (/druid/.test(tempclassname)) {
                        hasDruid = true;
                    } else if (/ranger/.test(tempclassname)) {
                        hasRanger = true;
                    }
                }
                if (v["spellclass-2-name"]) {
                    tempclassname = v["spellclass-2-name"].toLowerCase().replace(/^\s+/, "").match(/\w+/)[0];
                    classesToMatch[tempclassname] = 2;
                    originalClasses[2] = tempclassname;
                    if (/hunter/.test(tempclassname)) {
                        hasHunter = true;
                        hunterIdx = 2;
                    } else if (/druid/.test(tempclassname)) {
                        hasDruid = true;
                    } else if (/ranger/.test(tempclassname)) {
                        hasRanger = true;
                    }
                }
                if (!(hasHunter && (hasDruid || hasRanger))) {
                    //if user is hunter AND other class it's based on then can't tell.
                    if (_underscore2.default.size(classesToMatch) > 0) {
                        //add the translated classes from classesUsingOtherSpellLists
                        _underscore2.default.each(classesToMatch, function (classindex, classname) {
                            _underscore2.default.each(classesUsingOtherSpellLists, function (toclass, fromclass) {
                                if (classname.indexOf(fromclass) >= 0) {
                                    classesToMatch[toclass] = classindex;
                                }
                            });
                        });
                        //from spell: first split on comma between classes, then on spaces between classname and level
                        classesInital = levelStrBase.split(/\s*,\s*/);
                        classes = _underscore2.default.map(classesInital, function (a) {
                            return a.split(/\s+/);
                        });
                        for (i = 0; i < classes.length; i++) {
                            classes[i][1] = parseInt(classes[i][1], 10) || 0;
                            if (i === 0) {
                                modeLevel = classes[i][1];
                            } else {
                                if (modeLevel !== classes[i][1]) {
                                    allSame = 0;
                                }
                            }
                        }
                        //classes example: [["sorcerer/wizard","2"],["summoner","1"],["inquisitor","3"],["magus","2"]]
                        if (hasHunter) {
                            for (i = 0; i < classes.length; i++) {
                                if (/druid|ranger/.test(classes[i][0]) && classes[i][1] < minHunterSpellLevel) {
                                    minHunterSpellLevel = classes[i][1];
                                    classMatch = classes[i][0];
                                }
                            }
                            if (minHunterSpellLevel < 99) {
                                counter++;
                                foundMatch = true;
                                level = minHunterSpellLevel;
                                idx = hunterIdx;
                            }
                        }
                        _underscore2.default.each(classesToMatch, function (classindex, classname) {
                            for (i = 0; i < classes.length; i++) {
                                //classes on left because it can be longer and have multiple class names such as cleric/druid
                                if (classes[i][0].indexOf(classname) >= 0) {
                                    counter++;
                                    if (!foundMatch) {
                                        classMatch = originalClasses[classindex];
                                        level = classes[i][1];
                                        idx = classindex;
                                        foundMatch = true;
                                    }
                                }
                            }
                        });
                    }
                }
            } catch (err) {
                classMatch = "";
            }
            if (!foundMatch) {
                //get mode 
                // IF FOODS IS AN ARRAY then : so how to do it with 
                var levels = _underscore2.default.map(classes, function (oneclass) {
                    return oneclass[1];
                });
                level = _underscore2.default.chain(levels).countBy().pairs().max(_underscore2.default.last).head().value();
                idx = 0;
                classMatch = originalClasses[0];
                setSilent['repeating_spells_description'] = 'Original spell level:' + v['repeating_spells_spell_lvlstr'] + ' \r\n' + v['repeating_spells_description'];
            }
            if (counter > 1 || !foundMatch) {
                _exportsLoaderTASTheAaronSheet2.default.warn("importFromCompendium: did not find class match");
                //leave at current choice if there is one
                setSilent["repeating_spells_spell_level"] = "";
                setSilent["repeating_spells_spell_level_r"] = -1;
                setSilent["repeating_spells_spell_class_r"] = -1;
                setSilent["repeating_spells_spellclass_number"] = "";
                setSilent["repeating_spells_spellclass"] = levelStrBase;
                callUpdateSpell = false;
            } else {
                setSilent["repeating_spells_spellclass_number"] = idx;
                setSilent["repeating_spells_spell_level"] = level;
                setSilent["repeating_spells_spell_level_r"] = level;
                setSilent["repeating_spells_spellclass"] = classMatch;
                setSilent["repeating_spells_spell_class_r"] = idx;
                //change tab so spell doesn't disappear.
                setSilent["spells_tab"] = level;
            }
        }
        if (rangeText) {
            try {
                newRangeSettings = PFUtils.parseSpellRangeText(rangeText, areaEffectText);
                setSilent["repeating_spells_range_pick"] = newRangeSettings.dropdown;
                setSilent["repeating_spells_range"] = newRangeSettings.rangetext;
                if (newRangeSettings.dropdown === 'touch') {
                    isAttack = true;
                    setSilent["repeating_spells_spell-attack-type"] = 'attk-melee';
                } else if (/ranged touch|ray\s/i.test(v["repeating_spells_description"])) {
                    isAttack = true;
                    setSilent["repeating_spells_spell-attack-type"] = 'attk-ranged';
                }
            } catch (err2) {
                _exportsLoaderTASTheAaronSheet2.default.error(err2);
                setSilent["repeating_spells_range"] = rangeText.replace(/\s*\(..*/, '');
                setSilent["repeating_spells_range_pick"] = "unknownrange";
            }
        }
        if (areaEffectText) {
            setSilent["repeating_spells_targets"] = areaEffectText;
        }
        setSilent["repeating_spells_spell_lvlstr"] = "";
        setSilent["repeating_spells_range_from_compendium"] = "";
        setSilent["repeating_spells_target_from_compendium"] = "";
        setSilent["repeating_spells_area_from_compendium"] = "";
        setSilent["repeating_spells_effect_from_compendium"] = "";
        if (_underscore2.default.size(setSilent) > 0) {
            setAttrs(setSilent, _PFConst2.default.silentParams, function () {
                if (callUpdateSpell) {
                    updateSpell(null, eventInfo);
                }
            });
        }
    });
}
function migrateRepeatingMacros(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSpells.migrateRepeatingMacros");
        if (typeof callback === "function") {
            callback();
        }
    }),
        migrated = _underscore2.default.after(2, function () {
        resetCommandMacro();
        setAttrs({ 'migrated_spells_macrosv1': 1 }, _PFConst2.default.silentParams, done);
    });
    //TAS.debug("at PFSpells.migrateRepeatingMacros");
    getAttrs(['migrated_spells_macrosv1'], function (v) {
        if (parseInt(v.migrated_spells_macrosv1, 10) !== 1) {
            PFMacros.migrateRepeatingMacros(migrated, 'spells', 'npc-macro-text', defaultRepeatingMacro, defaultRepeatingMacroMap, defaultDeletedMacroAttrs, '@{NPC-Whisper}');
            PFMacros.migrateRepeatingMacros(migrated, 'spells', 'macro-text', defaultRepeatingMacro, defaultRepeatingMacroMap, defaultDeletedMacroAttrs, '@{PC-Whisper}');
        } else {
            done();
        }
    });
}
function migrate(callback) {
    PFMigrate.migrateSpells(function () {
        PFMigrate.migrateSpellRanges(function () {
            migrateRepeatingMacros(function () {
                if (typeof callback === "function") {
                    callback();
                }
            });
        });
    });
}

function recalculate(callback, silently, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSpells.recalculate");
        if (typeof callback === "function") {
            callback();
        }
    }),
        recalcTotals = _underscore2.default.once(function () {
        //TAS.debug("at PFSpells.recalculate.recalcTotals");
        resetSpellsPrepared();
        resetSpellsTotals(null, null, null, silently);
        resetCommandMacro();
        //do not call because updateSpells already calls update options
        done();
    }),
        callUpdateSpells = _underscore2.default.once(function () {
        getAttrs(["use_spells"], function (v) {
            if (parseInt(v.use_spells, 10)) {
                updateSpells(recalcTotals, silently);
            } else {
                done();
            }
        });
    });
    migrate(callUpdateSpells);
}
var events = {
    //events for spell repeating rows
    repeatingSpellEventsPlayer: {
        "change:repeating_spells:DC_misc change:repeating_spells:slot change:repeating_spells:Concentration_misc change:repeating_spells:range change:repeating_spells:range_pick change:repeating_spells:CL_misc change:repeating_spells:SP_misc": [updateSpell],
        "change:repeating_spells:spell_lvlstr": [importFromCompendium],
        "change:repeating_spells:used": [updateSpellsPerDay, updatePreparedSpellState],
        "change:repeating_spells:slot": [updateSpellSlot]
    },
    repeatingSpellEventsEither: {
        "change:repeating_spells:spellclass_number change:repeating_spells:spell_level": [updateSpell]
    },
    repeatingSpellAttackEvents: ["range_pick", "range", "range_numeric", "damage-macro-text", "damage-type", "sr", "savedc", "save", "spell-attack-type", "name"]
};
function registerEventHandlers() {
    //SPELLS
    //all repeating spell updates
    var tempstr = "";
    _underscore2.default.each(events.repeatingSpellEventsPlayer, function (functions, eventToWatch) {
        _underscore2.default.each(functions, function (methodToCall) {
            on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventRepeatingSpellsPlayer(eventInfo) {
                if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                    _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                    methodToCall(null, eventInfo);
                }
            }));
        });
    });
    _underscore2.default.each(events.repeatingSpellEventsEither, function (functions, eventToWatch) {
        _underscore2.default.each(functions, function (methodToCall) {
            on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventRepeatingSpellsEither(eventInfo) {
                _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                methodToCall(null, eventInfo);
            }));
        });
    });
    on("change:spellmenu_groupby_school change:spellmenu_show_uses change:spellclass-0-hide_unprepared change:spellclass-1-hide_unprepared change:spellclass-2-hide_unprepared change:spellclass-0-show_domain_spells change:spellclass-1-show_domain_spells change:spellclass-2-show_domain_spells", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUnpreparedSpellCommandChange(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            resetCommandMacro();
        }
    }));

    on("remove:repeating_spells", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateRemoveLinkedSpell(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        PFAttacks.removeLinkedAttack(null, PFAttacks.linkedAttackType.spell, SWUtils.getRowId(eventInfo.sourceAttribute));
    }));

    on("remove:repeating_spells change:repeating_spells:spellclass_number change:repeating_spells:spell_level change:repeating_spells:slot change:repeating_spells:used change:repeating_spells:school change:repeating_spells:metamagic change:repeating_spells:isDomain change:repeating_spells:isMythic change:_reporder_repeating_spells", _exportsLoaderTASTheAaronSheet2.default.callback(function eventRepeatingSpellAffectingMenu(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            resetCommandMacro();
        }
    }));
    on("remove:repeating_spells change:repeating_spells:spellclass_number change:repeating_spells:spell_level", _exportsLoaderTASTheAaronSheet2.default.callback(function eventRepeatingSpellsTotals(eventInfo) {
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            resetSpellsTotals();
        }
    }));
    on("change:repeating_spells:create-attack-entry", _exportsLoaderTASTheAaronSheet2.default.callback(function eventcreateAttackEntryFromSpell(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            createAttackEntryFromRow(null, null, false, eventInfo);
        }
    }));
    tempstr = _underscore2.default.reduce(events.repeatingSpellAttackEvents, function (memo, attr) {
        memo += "change:repeating_spells:" + attr + " ";
        return memo;
    }, "");
    on(tempstr, _exportsLoaderTASTheAaronSheet2.default.callback(function eventupdateAssociatedSpellAttack(eventInfo) {
        var attr;
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event" + eventInfo.sourceType);
        attr = SWUtils.getAttributeName(eventInfo.sourceAttribute);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api" || attr === 'spell-attack-type') {
            updateAssociatedAttack(null, null, null, eventInfo);
        }
    }));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFSpells module loaded         ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.copyToAbilities = copyToAbilities;
exports.resetCommandMacro = resetCommandMacro;
exports.importFromCompendium = importFromCompendium;
exports.setAttackEntryVals = setAttackEntryVals;
exports.createAttackEntryFromRow = createAttackEntryFromRow;
exports.updateAssociatedAttack = updateAssociatedAttack;
exports.migrateRepeatingMacros = migrateRepeatingMacros;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFUtilsAsync = __webpack_require__(9);

var PFUtilsAsync = _interopRequireWildcard(_PFUtilsAsync);

var _PFMacros = __webpack_require__(10);

var PFMacros = _interopRequireWildcard(_PFMacros);

var _PFMenus = __webpack_require__(14);

var PFMenus = _interopRequireWildcard(_PFMenus);

var _PFDB = __webpack_require__(28);

var PFDB = _interopRequireWildcard(_PFDB);

var _PFAttackOptions = __webpack_require__(12);

var PFAttackOptions = _interopRequireWildcard(_PFAttackOptions);

var _PFAttackGrid = __webpack_require__(7);

var PFAttackGrid = _interopRequireWildcard(_PFAttackGrid);

var _PFFeatures = __webpack_require__(29);

var PFFeatures = _interopRequireWildcard(_PFFeatures);

var _PFAttacks = __webpack_require__(8);

var PFAttacks = _interopRequireWildcard(_PFAttacks);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var optionFields = ['is_sp', 'hasposrange', 'hasuses', 'hasattack', 'abil-attacktypestr'],
    optionRepeatingHelperFields = ['ability_type', 'range_numeric', 'frequency', 'abil-attack-type'],
    allOptionRepeatingFields = optionFields.concat(optionRepeatingHelperFields),
    tabRuleSorted = {
	'class-features': 0,
	'feats': 1,
	'monster-rule': 8,
	'mythic-abilities': 3,
	'mythic-feats': 1,
	'other': 8,
	'racial-traits': 2,
	'special-abilities': 5,
	'special-attacks': 4,
	'special-qualities': 7,
	'spell-like-abilities': 6,
	'traits': 2
},
    tabTypeSorted = {
	'Ex': 9,
	'Sp': 10,
	'Su': 11
},
    categoryAttrs = ['tabcat-1', 'tabcat0', 'tabcat1', 'tabcat2', 'tabcat3', 'tabcat4', 'tabcat5', 'tabcat6', 'tabcat7', 'tabcat8', 'tabcat9', 'tabcat10', 'tabcat11'],
    otherCommandMacros = {
	'ex': " [^{extraordinary-abilities-menu}](~@{character_id}|NPCPREFIXex_button)",
	'sp': " [^{spell-like-abilities-menu}](~@{character_id}|NPCPREFIXsp_button)",
	'su': " [^{supernatural-abilities-menu}](~@{character_id}|NPCPREFIXsu_button)"
},
    defaultMacroMap = {
	'abilities': 'default'
},
    defaultMacros = {
	'default': {
		defaultRepeatingMacro: '&{template:pf_ability} @{toggle_accessible_flag} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_ability}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle=^{@{rule_category}}}} {{name=@{name}}} {{rule_category=@{rule_category}}} {{source=@{class-name}}} {{is_sp=@{is_sp}}} {{hasspellrange=@{range_pick}}} {{spell_range=^{@{range_pick}}}} {{casterlevel=[[@{casterlevel}]]}} {{spell_level=[[@{spell_level}]]}} {{hasposrange=@{hasposrange}}} {{custrange=@{range}}} {{range=[[@{range_numeric}]]}} {{save=@{save}}} {{savedc=[[@{savedc}]]}} {{hassr=@{abil-sr}}} {{sr=^{@{abil-sr}}}} {{hasfrequency=@{hasfrequency}}} {{frequency=^{@{frequency}}}} {{next_cast=@{rounds_between}}} {{hasuses=@{hasuses}}} {{uses=@{used}}} {{uses_max=@{used|max}}} {{cust_category=@{cust-category}}} {{concentration=[[@{Concentration-mod}]]}} {{damage=@{damage-macro-text}}} {{damagetype=@{damage-type}}} {{hasattack=@{hasattack}}} {{attacktype=^{@{abil-attacktypestr}}}} {{targetarea=@{targets}}} {{duration=@{duration}}} {{shortdesc=@{short-description}}} {{description=@{description}}} {{deafened_note=@{SpellFailureNote}}}',
		defaultRepeatingMacroMap: {
			'&{template:': { 'current': 'pf_ability}' },
			'@{toggle_accessible_flag}': { 'current': '@{toggle_accessible_flag}' },
			'@{toggle_rounded_flag}': { 'current': '@{toggle_rounded_flag}' },
			'{{color=': { 'current': '@{rolltemplate_color}}}' },
			'{{header_image=': { 'current': '@{header_image-pf_ability}}}', 'old': ['@{header_image-pf_block}}}'] },
			'{{character_name=': { 'current': '@{character_name}}}' },
			'{{character_id=': { 'current': '@{character_id}}}' },
			'{{subtitle=': { 'current': '^{@{rule_category}}}}' },
			'{{name=': { 'current': '@{name}}}' },
			'{{rule_category=': { 'current': '@{rule_category}}}' },
			'{{source=': { 'current': '@{class-name}}}' },
			'{{is_sp=': { 'current': '=@{is_sp}}}' },
			'{{hasspellrange=': { 'current': '@{range_pick}}}' },
			'{{hassave=': { 'current': '@{save}}}' },
			'{{spell_range=': { 'current': '^{@{range_pick}}}}' },
			'{{hasposrange=': { 'current': '@{hasposrange}}}' },
			'{{custrange=': { 'current': '@{range}}}' },
			'{{range=': { 'current': '[[@{range_numeric}]]}}' },
			'{{save=': { 'current': '@{save}}}' },
			'{{savedc=': { 'current': '[[@{savedc}]]}}', 'old': ['@{savedc}}}'] },
			'{{casterlevel=': { 'current': '[[@{casterlevel}]]}}' },
			'{{spell_level=': { 'current': '[[@{spell_level}]]}}' },
			'{{hassr=': { 'current': '@{abil-sr}}}' },
			'{{sr=': { 'current': '^{@{abil-sr}}}}' },
			'{{^{duration}=': { 'current': '@{duration}}}' },
			'{{hasfrequency=': { 'current': '@{frequency}}}' },
			'{{frequency=': { 'current': '^{@{frequency}}}}' },
			'{{next_cast=': { 'current': '@{rounds_between}}}' },
			'{{hasuses=': { 'current': '@{hasuses}}}' },
			'{{uses=': { 'current': '@{used}}}' },
			'{{uses_max=': { 'current': '@{used|max}}}' },
			'{{cust_category=': { 'current': '@{cust-category}}}' },
			'{{concentration=': { 'current': '[[@{Concentration-mod}]]}}', 'old': ['@{Concentration-mod}}', '@{Concentration-mod}}}'] },
			'{{damage=': { 'current': '@{damage-macro-text}}}' },
			'{{damagetype=': { 'current': '@{damage-type}}}' },
			'{{hasattack=': { 'current': '@{hasattack}}}' },
			'{{attacktype=': { 'current': '^{@{abil-attacktypestr}}}}' },
			'{{targetarea=': { 'current': '@{targets}}}' },
			'{{shortdesc=': { 'current': '@{short-description}}}' },
			'{{description=': { 'current': '@{description}}}' },
			'{{deafened_note=': { 'current': '@{SpellFailureNote}}}' }
		},
		defaultDeletedArray: null
	}
},
    events = {
	attackEventsSLA: ["damage-macro-text", "damage-type", "abil-sr", "save", "abil-attack-type", "name", "range_numeric"],
	commandMacroFields: ["name", "used", "used_max", "showinmenu", "ability_type", "frequency", "rule_category"]
};
/** sets tab for an ability. these have multiple checkboxes, not a radio
 *@param {string} id optional id of row
 *@param {function} callback call when done
 *@param {obj} eventInfo from 'on' event change:rule_category
 */
function setRuleTab(id, callback, eventInfo) {
	var idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = "repeating_ability_" + idStr,
	    catfields = [],
	    ruleCategoryField = prefix + "rule_category",
	    abilityTypeField = prefix + 'ability_type',
	    fields = [ruleCategoryField, abilityTypeField];
	catfields = _underscore2.default.map(categoryAttrs, function (attr) {
		return prefix + attr;
	});
	fields = fields.concat(catfields);
	getAttrs(fields, function (v) {
		var setter,
		    ruleType = 0,
		    abilityType = 0;
		setter = _underscore2.default.reduce(catfields, function (m, attr) {
			m[attr] = 0;
			return m;
		}, {});
		if (v[abilityTypeField]) {
			abilityType = tabTypeSorted[v[abilityTypeField]];
			setter[prefix + 'tabcat' + abilityType] = 1;
		}
		if (v[ruleCategoryField]) {
			ruleType = tabRuleSorted[v[ruleCategoryField]];
			setter[prefix + 'tabcat' + ruleType] = 1;
			setter[prefix + 'tabcat-1'] = 0;
		} else {
			setter[prefix + 'tabcat-1'] = 1;
		}

		//TAS.debug("PFAbility.setRuleTab, setting",setter);
		setAttrs(setter, _PFConst2.default.silentParams);
	});
}
function setRuleTabs() {
	getSectionIDs("repeating_ability", function (ids) {
		_underscore2.default.each(ids, function (id) {
			setRuleTab(id);
		});
	});
}

/** returns all rule_category and ability_type used
 * @returns {'rules':[values of rule_category], 'types':[valuesof ability_type]} object of rules
 */
function getAbilityTypes(callback) {
	var done = function done(typeObj) {
		//TAS.debug('Ability.getAbilityTypes returning with ',typeObj);
		if (typeof callback === "function") {
			callback(typeObj);
		}
	};
	getSectionIDs('repeating_ability', function (ids) {
		var fields = [];
		if (!ids || _underscore2.default.size(ids) === 0) {
			done({ 'rules': [], 'types': [] });
			return;
		}
		_underscore2.default.each(ids, function (id) {
			var prefix = 'repeating_ability_' + id + '_';
			fields.push(prefix + 'rule_category');
			fields.push(prefix + 'showinmenu');
			fields.push(prefix + 'ability_type');
		});
		getAttrs(fields, function (v) {
			var basearray = [],
			    rulearray = [],
			    typearray = [];
			basearray = _underscore2.default.chain(ids).map(function (id) {
				var retObj = {},
				    prefix = 'repeating_ability_' + id + '_';
				retObj.id = id;
				retObj.showinmenu = parseInt(v[prefix + 'showinmenu'], 10) || 0;
				retObj.rule_category = v[prefix + 'rule_category'] || '';
				retObj.ability_type = (v[prefix + 'ability_type'] || '').toLowerCase();
				//TAS.debug("row "+id+" is ",retObj);
				return retObj;
			}).filter(function (o) {
				return o.showinmenu;
			}).value();

			if (basearray) {
				rulearray = _underscore2.default.chain(basearray).groupBy('rule_category').keys().compact().value();
				typearray = _underscore2.default.chain(basearray).groupBy('ability_type').keys().compact().value();
			}
			if (!rulearray) {
				rulearray = [];
			}
			if (!typearray) {
				typearray = [];
			}
			done({ 'rules': rulearray, 'types': typearray });
		});
	});
}
function getNewAbilityAttrs(ability) {
	var setter = {},
	    id = '',
	    prefix = '',
	    matches;
	try {
		id = generateRowID();
		prefix = 'repeating_ability_' + id + '_';
		setter[prefix + 'row_id'] = id;
		setter[prefix + 'showinmenu'] = ability['showinmenu'] || 0;
		setter[prefix + 'name'] = ability.name || '';
		setter[prefix + 'used'] = ability['used'] || '';
		setter[prefix + 'used_max'] = ability['used_max'] || '';
		setter[prefix + 'max-calculation'] = ability['max-calculation'] || '';
		setter[prefix + 'short-description'] = ability['short-description'] || '';
		setter[prefix + 'description'] = ability['description'] || '';
		setter[prefix + 'rule_category'] = ability['rule_category'] || '';
		setter[prefix + 'CL-basis'] = ability['CL-basis'] || '0';
		setter[prefix + 'class-name'] = ability['class-name'] || '';
		if (ability.rule_category === 'spell-like-abilities') {
			setter[prefix + 'ability_type'] = 'Sp';
			if (ability['spell_level-misc']) {
				setter[prefix + 'spell_level-misc'] = ability['spell_level-misc'];
				setter[prefix + 'spell_level-misc-mod'] = ability['spell_level-misc-mod'];
				setter[prefix + 'spell_level-basis'] = ability['spell_level-basis'];
			}
			if (ability['range_numeric']) {
				setter[prefix + 'range'] = ability['range'];
				setter[prefix + 'range_numeric'] = ability['range_numeric'];
				setter[prefix + 'range_pick'] = ability['range_pick'];
			}
			if (ability["abil-sr"]) {
				setter[prefix + 'abil-sr'] = ability["abil-sr"];
			}
			if (ability['save']) {
				setter[prefix + 'save'] = ability['save'];
			}
		} else {
			matches = ability.name.match(/\b(Sp|Su|Ex)\b/i);
			if (matches && matches[1]) {
				setter[prefix + 'ability_type'] = matches[0][0].toUpperCase() + matches[0][1].toLowerCase();
			} else {
				setter[prefix + 'ability_type'] = '';
			}
		}
		setter[prefix + 'macro-text'] = ability['macro-text'] || '';
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.getNewAbilityAttrs", err, ability);
	} finally {
		return setter;
	}
}
function copyToAbilities(callback, abilities) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAbility.copyToAbilities");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    setter = {};
	_exportsLoaderTASTheAaronSheet2.default.debug("At PFAbility.copyToAbilities");
	if (_underscore2.default.size(abilities)) {
		_underscore2.default.each(abilities, function (ability) {
			var xtra = getNewAbilityAttrs(ability);
			_exportsLoaderTASTheAaronSheet2.default.debug("PFAbility.copyToAbilities adding ", xtra);
			_underscore2.default.extend(setter, xtra);
		});
		_exportsLoaderTASTheAaronSheet2.default.debug("##########################", "PFAbility.copyToAbilities setting", setter);
	}
	if (_underscore2.default.size(setter)) {
		setAttrs(setter, _PFConst2.default.silentParams, done);
	} else {
		done();
	}
}

/** resetTopCommandMacro sets all-abilities_buttons_macro (menu of ability menus)
 *@param {function} callback call when done	
 */
function getTopOfMenu(callback, isNPC) {
	var done = function done(str) {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAbility.getTopOfMenu");
		if (typeof callback === "function") {
			callback(str);
		}
	},
	    newMacro = "",
	    setter = {};
	try {
		newMacro = " @{orig_ability_header_macro}";
		getAbilityTypes(function (used) {
			var addlMacros = "",
			    prefix = "";
			try {
				if (isNPC) {
					prefix = "NPC-";
				}
				if (used.types) {
					_underscore2.default.each(used.types, function (type) {
						if (otherCommandMacros[type]) {
							addlMacros += otherCommandMacros[type].replace("NPCPREFIX", prefix);
						} else if (type) {
							_exportsLoaderTASTheAaronSheet2.default.warn("cound not find top macro for " + type);
						}
					});
				}
				if (addlMacros) {
					newMacro += " {{row03=^{ability-menus}}} {{row04=" + addlMacros + "}}";
				}
				//TAS.debug("PFAbility.getTopOfMenu: done building top macro it is :",newMacro);
			} catch (innererr) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.getTopOfMenu innererr", innererr);
			} finally {
				done(newMacro);
			}
		});
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.getTopOfMenu", err);
		done(newMacro);
	}
}
function resetCommandMacro(callback) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	}),
	    doneOne = _underscore2.default.after(8, done);

	getTopOfMenu(function (header) {
		PFMenus.resetOneCommandMacro('ability', true, doneOne, header);
	}, true);
	getTopOfMenu(function (header) {
		PFMenus.resetOneCommandMacro('ability', false, doneOne, header);
	}, false);
	PFMenus.resetOneCommandMacro('ex', true, doneOne);
	PFMenus.resetOneCommandMacro('sp', true, doneOne);
	PFMenus.resetOneCommandMacro('su', true, doneOne);
	PFMenus.resetOneCommandMacro('ex', false, doneOne);
	PFMenus.resetOneCommandMacro('sp', false, doneOne);
	PFMenus.resetOneCommandMacro('su', false, doneOne);
}
function importFromCompendium(callback, eventInfo) {
	var done = _underscore2.default.once(function () {
		resetCommandMacro();
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAbility.importFromCompendium");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    id = SWUtils.getRowId(eventInfo.sourceAttribute),
	    //row doesn't really exist yet so get id from event
	prefix = 'repeating_ability_' + id + '_';
	//TAS.debug"at PFAbility.importFromCompendium for "+ prefix);
	getAttrs(['is_undead', prefix + 'name', prefix + 'compendium_category', prefix + 'rule_category', prefix + 'ability_type_compendium', prefix + 'ability_type', prefix + 'description', prefix + 'range_from_compendium', prefix + 'target_from_compendium', prefix + 'area_from_compendium', prefix + 'effect_from_compendium'], function (v) {
		var compcat = '',
		    abilitytype = '',
		    ability_basis = '',
		    location = '',
		    setter = {},
		    newcat = '',
		    abilname = '',
		    silentSetter = {},
		    match,
		    note = '',
		    areaEffectText = '',
		    newRangeSettings;
		try {
			//TAS.debug("PFAbility.importFromCompendium got values: ",v);
			if (v[prefix + 'ability_type_compendium']) {
				abilitytype = v[prefix + 'ability_type_compendium'];
				setter[prefix + 'ability_type'] = abilitytype;
				silentSetter[prefix + 'ability_type_compendium'] = "";
			}
			compcat = v[prefix + 'compendium_category'];
			silentSetter[prefix + 'compendium_category'] = "";
			if (compcat) {
				compcat = compcat.toLowerCase();
				if (compcat === 'feats') {
					newcat = 'feats';
				} else if (compcat === 'monster rule') {
					newcat = 'monster-rule';
				} else if (compcat === 'spell') {
					newcat = 'spell-like-abilities';
				}
				if (newcat === 'monster-rule') {
					if (v[prefix + 'description']) {
						match = v[prefix + 'description'].match(/Location\:\s*(.*)$/i);
						//TAS.debug"matching "+match);
						if (match && match[1]) {
							location = SWUtils.trimBoth(match[1].toLowerCase());
							match = location.match(/special qual|sq|special att|special abil|defens|spell/i);
							if (match) {
								switch (match[0]) {
									case 'special qual':
									case 'sq':
										newcat = 'special-qualities';break;
									case 'special att':
										newcat = 'special-attacks';break;
									case 'special abil':
										newcat = 'special-abilities';break;
									case 'defens':
										newcat = 'defensive-abilities';break;
									case 'spell':
										newcat = 'spell-like-abilities';break;
								}
							}
						}
					}
				}
				if (abilitytype === 'Sp' && !newcat) {
					newcat = 'spell-like-abilities';
				}
				if (!abilitytype && newcat === 'spell-like-abilities') {
					abilitytype = 'Sp';
					setter[prefix + 'ability_type'] = 'Sp';
				} else if (abilitytype === 'Sp' && !newcat) {
					newcat = 'spell-like-abilities';
				}

				if (newcat) {
					setter[prefix + 'rule_category'] = newcat;
				} else {
					note += compcat;
				}
				if (abilitytype === 'Sp') {
					areaEffectText = v[prefix + 'target_from_compendium'] || v[prefix + 'area_from_compendium'] || v[prefix + 'effect_from_compendium'] || "";
					setter[prefix + 'targets'] = areaEffectText;
					if (v[prefix + 'range_from_compendium']) {
						newRangeSettings = PFUtils.parseSpellRangeText(v[prefix + 'range_from_compendium'], areaEffectText);
						setter[prefix + "range_pick"] = newRangeSettings.dropdown;
						setter[prefix + "range"] = newRangeSettings.rangetext;
					}
					setter[prefix + 'ability-basis'] = '@{CHA-mod}';
				} else if (v[prefix + 'name']) {
					abilname = v[prefix + 'name'].tolowercase();
					abilname = abilname.match(/^[^(]+/);
					if (PFDB.specialAttackDCAbilityBase[abilname]) {
						ability_basis = PFDB.specialAttackDCAbilityBase[abilname];
					} else {
						ability_basis = 'CON';
					}
					if (ability_basis === 'CON' && parseInt(v.is_undead, 10)) {
						ability_basis = 'CHA';
					}
					ability_basis = '@{' + ability_basis + '}';
					setter[prefix + 'ability-basis'] = ability_basis;
				}
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.importFromCompendium", err);
		} finally {
			if (_underscore2.default.size(silentSetter) > 0) {
				setAttrs(silentSetter, _PFConst2.default.silentParams);
			}
			//TAS.debug"PFAbility.importFromCompendium, setting",setter);
			if (_underscore2.default.size(setter) > 0) {
				setAttrs(setter, {}, done);
			} else {
				done();
			}
		}
	});
}
function setClassName(id, callback, eventInfo) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	}),
	    idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = "repeating_ability_" + idStr,
	    clbasisField = prefix + "CL-basis";
	getAttrs([prefix + 'CL-basis', prefix + 'class-name', "race", "class-0-name", "class-1-name", "class-2-name", "class-3-name", "class-4-name", "class-5-name"], function (v) {
		var clBase = '',
		    setter = {},
		    match;
		try {
			if (v[clbasisField]) {
				if (v[clbasisField] === "@{level}") {
					clBase = v["race"];
				} else if (v[clbasisField] === "@{npc-hd-num}") {
					clBase = v["race"];
				} else if (parseInt(v[clbasisField], 10) === 0) {
					clBase = "";
				} else {
					match = v[prefix + "CL-basis"].match(/\d+/);
					if (match) {
						clBase = v["class-" + match[0] + "-name"];
					}
				}
				if (v[prefix + 'class-name'] !== clBase) {
					setter[prefix + 'class-name'] = clBase;
				}
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.setClassName", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				setAttrs(setter, _PFConst2.default.silentParams, done);
			} else {
				done();
			}
		}
	});
}
function setAttackEntryVals(spellPrefix, weaponPrefix, v, setter, noName) {
	var notes = "",
	    attackType = "";
	setter = setter || {};
	try {
		attackType = PFUtils.findAbilityInString(v[spellPrefix + "abil-attack-type"]);
		if (v[spellPrefix + "name"]) {
			if (!noName) {
				setter[weaponPrefix + "name"] = v[spellPrefix + "name"];
			}
			setter[weaponPrefix + "source-ability-name"] = v[spellPrefix + "name"];
		}
		if (attackType) {
			setter[weaponPrefix + "attack-type"] = v[spellPrefix + "abil-attack-type"];
			if (/CMB/i.test(attackType)) {
				setter[weaponPrefix + "vs"] = "cmd";
			} else if (/ranged/i.test(attackType)) {
				setter[weaponPrefix + "vs"] = "touch";
				setter[weaponPrefix + "isranged"] = 1;
				setter[weaponPrefix + "range"] = v[spellPrefix + "range_numeric"] || 0;
			} else {
				setter[weaponPrefix + "vs"] = "touch";
				setter[weaponPrefix + "range"] = 0;
			}
		}

		if (v[spellPrefix + "damage-macro-text"]) {
			setter[weaponPrefix + "precision_dmg_macro"] = v[spellPrefix + "damage-macro-text"];
			if (attackType) {
				setter[weaponPrefix + "critical_dmg_macro"] = v[spellPrefix + "damage-macro-text"];
			} else {
				setter[weaponPrefix + "critical_dmg_macro"] = "";
			}
		}
		if (v[spellPrefix + "damage-type"]) {
			setter[weaponPrefix + "precision_dmg_type"] = v[spellPrefix + "damage-type"];
			if (attackType) {
				setter[weaponPrefix + "critical_dmg_type"] = v[spellPrefix + "damage-type"];
			} else {
				setter[weaponPrefix + "critical_dmg_type"] = "";
			}
		}

		if (v[spellPrefix + "save"]) {
			if (notes) {
				notes += ", ";
			}
			notes += "Save: " + v[spellPrefix + "save"] + " DC: [[@{" + spellPrefix + "savedc}]]";
		}
		if (v[spellPrefix + "abil-sr"]) {
			if (notes) {
				notes += ", ";
			}
			notes += "Spell resist:" + v[spellPrefix + "abil-sr"];
		}
		if (notes) {
			setter[weaponPrefix + "notes"] = notes;
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.setAttackEntryVals", err);
	} finally {
		return setter;
	}
}
/**Triggered from a button in repeating spells 
 *@param {string} id the row id or null
 *@param {function} callback when done
 *@param {boolean} silently setattrs silent:true
 *@param {object} eventInfo if id is null get id from here.
 */
function createAttackEntryFromRow(id, callback, silently, eventInfo, weaponId) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAbility.createAttackEntryFromRow");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    attribList = [],
	    itemId = id || (eventInfo ? SWUtils.getRowId(eventInfo.sourceAttribute) : ""),

	//idStr = SWUtils.getRepeatingIDStr(itemId),
	item_entry = 'repeating_ability_' + itemId + '_',
	    slaPrefix = item_entry,
	    //'repeating_ability_' + idStr,
	attributes = ["range_numeric", "damage-macro-text", "damage-type", "abil-sr", "savedc", "save", "abil-attack-type", "name"];
	if (!itemId) {
		_exportsLoaderTASTheAaronSheet2.default.warn("Cannot create usable attack entry from SLA since we cannot identify the row id");
	}
	attributes.forEach(function (attr) {
		attribList.push(slaPrefix + attr);
	});

	//TAS.debug("PFAbility.createAttackEntryFromRow: attribList=" + attribList);
	getAttrs(attribList, function (v) {
		var newRowId = "",
		    setter = {},
		    prefix = "repeating_weapon_",
		    idStr = "",
		    params = {};
		try {
			//TAS.debug("at PFAbility.createAttackEntryFromRow",v);
			if (!PFUtils.findAbilityInString(v[slaPrefix + "abil-attack-type"]) && !v[slaPrefix + "damage-macro-text"]) {
				_exportsLoaderTASTheAaronSheet2.default.warn("no attack to create for ability " + v[slaPrefix + "name"] + ", " + itemId);
			} else {
				if (!weaponId) {
					newRowId = generateRowID();
				} else {
					newRowId = weaponId;
				}
				idStr = newRowId + "_";
				prefix += idStr;
				setter = setAttackEntryVals(slaPrefix, prefix, v, setter, weaponId);
				setter[prefix + "source-ability"] = itemId;
				setter[prefix + "group"] = "Special";
				setter[prefix + 'link_type'] = PFAttacks.linkedAttackType.ability;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.createAttackEntryFromRow", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				setter[slaPrefix + "create-attack-entry"] = 0;
				if (silently) {
					params = _PFConst2.default.silentParams;
				}
				//TAS.debug("PFAbility.createAttackEntryFromRow setting:",setter);
				setAttrs(setter, {}, function () {
					//can do these in parallel
					//TAS.debug("PFAbility.createAttackEntryFromRow came back from setter ");
					PFAttackOptions.resetOption(newRowId);
					PFAttackGrid.resetCommandMacro();
					done();
				});
			} else {
				setter[slaPrefix + "create-attack-entry"] = 0;
				setAttrs(setter, _PFConst2.default.silentParams, done);
			}
		}
	});
}
function updateAssociatedAttack(id, callback, silently, eventInfo) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAbility.updateAssociatedAttack");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    itemId = "",
	    item_entry = "",
	    attrib = "",
	    attributes = [];
	itemId = id || (eventInfo ? SWUtils.getRowId(eventInfo.sourceAttribute) : "");
	item_entry = 'repeating_ability_' + SWUtils.getRepeatingIDStr(itemId);
	attrib = eventInfo ? SWUtils.getAttributeName(eventInfo.sourceAttribute) : "";
	attributes = [];
	//TAS.debug("at PF Spell like abilities updateAssociatedAttack: for row" + id   );
	if (attrib) {
		attributes = [item_entry + attrib];
		if (/range/i.test(attrib)) {
			attributes = [item_entry + 'range_pick', item_entry + 'range', item_entry + 'range_numeric'];
		}
	} else {
		attributes = ["range_pick", "range", "range_numeric", "damage-macro-text", "damage-type", "sr", "savedc", "save", "abil-attack-type", "name"];
	}
	getAttrs(attributes, function (spellVal) {
		getSectionIDs("repeating_weapon", function (idarray) {
			// get the repeating set
			var spellsourcesFields = [];
			spellsourcesFields = _underscore2.default.reduce(idarray, function (memo, currentID) {
				memo.push("repeating_weapon_" + currentID + "_source-ability");
				return memo;
			}, []);
			getAttrs(spellsourcesFields, function (v) {
				var setter = {},
				    params = {},
				    idlist = [];
				try {
					_underscore2.default.each(idarray, function (currentID) {
						var prefix = "repeating_weapon_" + currentID + "_";
						if (v[prefix + "source-ability"] === itemId) {
							idlist.push(currentID);
							setter = setAttackEntryVals(item_entry, prefix, spellVal, setter);
						}
					});
				} catch (err) {
					_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.updateAssociatedAttack", err);
				} finally {
					if (_underscore2.default.size(setter) > 0) {
						if (silently) {
							params = _PFConst2.default.silentParams;
						}
						setAttrs(setter, params, function () {
							PFAttackOptions.resetSomeOptions(idlist);
						});
					} else {
						done();
					}
				}
			});
		});
	});
}
function updateCharLevel(id, callback, eventInfo) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving updateCharLevel");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = "repeating_ability_" + idStr;
	getAttrs([prefix + "CL-misc-mod", prefix + "CL-basis-mod", prefix + "casterlevel", prefix + "ability_type", "buff_CasterLevel-total", "CasterLevel-Penalty"], function (v) {
		var clBase = 0,
		    cl = 0,
		    misc = 0,
		    pen = 0,
		    isSP = 0,
		    setter = {};
		try {
			isSP = parseInt(v[prefix + "ability_type"], 10) || 0;
			clBase = parseInt(v[prefix + "CL-basis-mod"], 10) || 0;
			misc = parseInt(v[prefix + "CL-misc-mod"], 10) || 0;
			pen = parseInt(v["CasterLevel-Penalty"], 10) || 0;
			cl = clBase + misc + pen;
			if (isSP) {
				cl += parseInt(v["buff_CasterLevel-total"], 10) || 0;
			}
			if (cl !== parseInt(v[prefix + 'casterlevel'], 10)) {
				setter[prefix + 'casterlevel'] = cl;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.updateCharLevel", err);
		} finally {
			if (_underscore2.default.size(setter)) {
				setAttrs(setter, {}, done);
			} else {
				done();
			}
		}
	});
}
function updateAbilityRange(id, callback, silently, eventInfo) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving updateAbilityRange");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = "repeating_ability_" + idStr;
	getAttrs([prefix + "range_pick", prefix + "range", prefix + "range_numeric", prefix + "casterlevel", prefix + "ability_type"], function (v) {
		var newRange = 0,
		    currRange = 0,
		    cl = 0,
		    setter = {},
		    isSP = 0,
		    currPosRange = 0;
		try {
			isSP = v[prefix + 'ability_type'] === 'Sp' ? 1 : 0;
			currRange = parseInt(v[prefix + "range_numeric"], 10) || 0;
			if (isSP) {
				cl = parseInt(v[prefix + 'casterlevel'], 10) || 0;
				newRange = PFUtils.findSpellRange(v[prefix + "range"], v[prefix + "range_pick"], cl) || 0;
			} else {
				newRange = parseInt(SWUtils.trimBoth(v[prefix + 'range']), 10) || 0;
			}
			if (newRange !== currRange) {
				//TAS.debug("updating range");
				setter[prefix + "range_numeric"] = newRange;
			}
			currPosRange = parseInt(v[prefix + 'hasposrange'], 10) || 0;
			if (newRange > 0 && !currPosRange) {
				setter[prefix + 'hasposrange'] = 1;
			} else if (currPosRange) {
				setter[prefix + 'hasposrange'] = 0;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("updateAbilityRange", err);
		} finally {
			if (_underscore2.default.size(setter)) {
				setAttrs(setter, {}, done);
			} else {
				done();
			}
		}
	});
}
/** to use in calls to _.invoke or otherwise, sets switch variables to setter for given row
 * @param {jsobj} setter to pass in first var of setAttrs
 * @param {string} id the id of this row, or null if we are within the row context already
 * @param {jsobj} v the values needed returned by getAttrs
 */
function resetOption(setter, id, v, eventInfo) {
	var idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = 'repeating_ability_' + idStr,
	    isSP = '',
	    posRange = '',
	    hasUses = '',
	    hasFrequency = '',
	    hasAttack = '',
	    atkstr = '',
	    attackStrForDisplay = '';
	setter = setter || {};
	try {
		if (!v) {
			return setter;
		}
		isSP = v[prefix + 'ability_type'] === 'Sp' ? '1' : '';

		if (isSP !== v[prefix + 'is_sp']) {
			setter[prefix + 'is_sp'] = isSP;
		}
		posRange = (parseInt(v[prefix + 'range_numeric'], 10) || 0) > 0 ? '1' : '';
		if (posRange !== v[prefix + 'hasposrange']) {
			setter[prefix + 'hasposrange'] = posRange;
		}
		if (v[prefix + 'frequency'] && v[prefix + 'frequency'] !== 'not-applicable') {
			hasFrequency = '1';
			switch (v[prefix + 'frequency']) {
				case 'perday':
				case 'permonth':
				case 'hexfreq':
				case 'other':
					hasUses = '1';
					break;
			}
		}
		if (hasFrequency !== v[prefix + 'hasfrequency']) {
			setter[prefix + 'hasfrequency'] = hasFrequency;
		}
		if (hasUses !== v[prefix + 'hasuses']) {
			setter[prefix + 'hasuses'] = hasUses;
		}
		if (PFUtils.findAbilityInString(v[prefix + 'abil-attack-type'])) {
			hasAttack = '1';
		}
		if (hasAttack !== v[prefix + 'hasattack']) {
			setter[prefix + 'hasattack'] = hasAttack;
		}
		if (hasAttack) {
			atkstr = v[prefix + 'abil-attack-type'].toLowerCase();
			if (atkstr.indexOf('melee') >= 0) {
				attackStrForDisplay = 'touch';
			} else if (atkstr.indexOf('range') >= 0) {
				attackStrForDisplay = 'ranged-touch-ray';
			} else if (atkstr.indexOf('cmb') >= 0) {
				attackStrForDisplay = 'combat-maneuver-bonus-abbrv';
			}
		}
		if (attackStrForDisplay !== v[prefix + 'abil-attacktypestr']) {
			setter[prefix + 'abil-attacktypestr'] = attackStrForDisplay;
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.recalcAbilities", err);
	} finally {
		return setter;
	}
}
function resetOptionAsync(id, callback, eventInfo) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAbility.resetOption");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = 'repeating_ability_' + idStr,
	    fields = [];
	fields = _underscore2.default.map(allOptionRepeatingFields, function (attr) {
		return prefix + attr;
	});
	getAttrs(fields, function (v) {
		var setter = {};
		try {
			setter = resetOption(setter, id, v);
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.recalcAbilities", err);
		} finally {
			if (_underscore2.default.size(setter)) {
				setAttrs(setter, _PFConst2.default.silentParams, done, eventInfo);
			} else {
				done();
			}
		}
	});
}

function recalcAbilities(callback, silently, eventInfo, levelOnly) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAbility.recalcAbilities");
		if (typeof callback === "function") {
			callback();
		}
	});
	getSectionIDs('repeating_ability', function (ids) {
		var numids = _underscore2.default.size(ids),
		    doneOne,
		    calllevel;
		if (numids === 0) {
			done();
			return;
		}
		//TAS.debug("there are "+ numids+" rows to recalc");
		doneOne = _underscore2.default.after(numids, done);
		//refactor to do all rows at once
		calllevel = function calllevel(id) {
			PFUtilsAsync.setRepeatingDropdownValue('ability', id, 'CL-basis', 'CL-basis-mod', function () {
				//TAS.debug("PFAbility.recalcAbilities calling updateCharLevel for "+id);
				updateCharLevel(id, function () {
					//TAS.debug("PFAbility.recalcAbilities calling updateAbilityRange for "+id);
					updateAbilityRange(id, function () {
						//	TAS.debug("PFAbility.recalcAbilities calling updateAssociatedAttack for "+id);
						//	updateAssociatedAttack(id,null,false,null);
						doneOne();
					});
				});
			});
		};
		_underscore2.default.each(ids, function (id) {
			calllevel(id);
			if (!levelOnly) {
				resetOptionAsync(id);
			}
		});
	});
}
function migrateRepeatingMacros(callback) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAbility.migrateRepeatingMacros");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    migrated = _underscore2.default.once(function () {
		setAttrs({ 'migrated_ability_macrosv112': 1 }, _PFConst2.default.silentParams);
		done();
	}),
	    defaultName = '',
	    defaultMacro = '',
	    section = 'ability';
	getAttrs(['migrated_ability_macrosv112'], function (v) {
		try {
			if (!parseInt(v.migrated_ability_macrosv112, 10)) {

				defaultName = defaultMacroMap[section] || 'default';
				defaultMacro = defaultMacros[defaultName];
				if (!defaultMacro) {
					_exportsLoaderTASTheAaronSheet2.default.error("cannot find default macro for section " + section);
					done();
					return;
				}
				//TAS.debug("PFAbility.migrateRepeatingMacros about to call PFMacros",defaultMacro);
				PFMacros.migrateRepeatingMacros(migrated, section, 'macro-text', defaultMacro.defaultRepeatingMacro, defaultMacro.defaultRepeatingMacroMap, defaultMacro.defaultDeletedArray, '@{NPC-whisper}');
			} else {
				migrated();
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.migrateRepeatingMacros error setting up " + section, err);
			done();
		}
	});
}
function migrate(callback) {
	var done = function done() {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFAbility.migrate");
		if (typeof callback === "function") {
			callback();
		}
	};
	migrateRepeatingMacros(done);
}
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.info("leaving PFAbility.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    doneWithList = function doneWithList() {
		//TAS.debug("now calling resetcommandmacro");
		resetCommandMacro();
		done();
	},
	    callRecalcAbilities = function callRecalcAbilities() {
		//TAS.debug("PF1 calling recalcAbilities");
		recalcAbilities(_exportsLoaderTASTheAaronSheet2.default.callback(doneWithList));
		setRuleTabs();
	};
	try {
		//TAS.debug("at PFAbility.recalculate");
		migrate(_exportsLoaderTASTheAaronSheet2.default.callback(callRecalcAbilities));
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFAbility.recalculate, ", err);
		done();
	}
}
function registerEventHandlers() {
	var eventToWatch = "",
	    macroEvent = "remove:repeating_ability ",
	    singleEvent = "change:repeating_ability:";

	on("remove:repeating_ability", _exportsLoaderTASTheAaronSheet2.default.callback(function eventRemoveAbility(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		PFAttacks.removeLinkedAttack(null, PFAttacks.linkedAttackType.ability, SWUtils.getRowId(eventInfo.sourceAttribute));
	}));
	macroEvent = _underscore2.default.reduce(events.commandMacroFields, function (m, a) {
		m += singleEvent + a + " ";
		return m;
	}, macroEvent);
	on(macroEvent, _exportsLoaderTASTheAaronSheet2.default.callback(function eventRepeatingCommandMacroUpdate(eventInfo) {
		var attr;
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		attr = SWUtils.getAttributeName(eventInfo.sourceAttribute);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api" || eventInfo.sourceType === "sheetworker" && attr === 'used_max') {
			PFFeatures.resetTopCommandMacro(null, eventInfo);
			resetCommandMacro();
		}
	}));
	on("change:repeating_ability:CL-basis", _exportsLoaderTASTheAaronSheet2.default.callback(function eventAbilityClassDropdown(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		SWUtils.evaluateAndSetNumber('repeating_ability_CL-basis', 'repeating_ability_CL-basis-mod');
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			setClassName(null, null, eventInfo);
		}
	}));
	eventToWatch = _underscore2.default.reduce(optionRepeatingHelperFields, function (m, a) {
		m += 'change:repeating_ability:' + a + ' ';
		return m;
	}, "");
	on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventChangeAbilityTypeFrequencyOrRange(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api" || eventInfo.sourceAttribute.indexOf('range') > 0) {
			resetOptionAsync();
		}
	}));
	on("change:repeating_ability:CL-misc change:repeating_ability:spell_level-misc", _exportsLoaderTASTheAaronSheet2.default.callback(function eventSLAEquationMacro(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		SWUtils.evaluateAndSetNumber(eventInfo.sourceAttribute, eventInfo.sourceAttribute + "-mod");
	}));
	on("change:buff_CasterLevel-total change:CasterLevel-Penalty", _exportsLoaderTASTheAaronSheet2.default.callback(function eventAbilityLevelChange(eventInfo) {
		if (eventInfo.sourceType === "sheetworker") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			recalcAbilities(null, null, eventInfo, true);
		}
	}));
	on("change:repeating_ability:CL-basis-mod change:repeating_ability:CL-misc-mod", _exportsLoaderTASTheAaronSheet2.default.callback(function eventAbilityLevelChange(eventInfo) {
		if (eventInfo.sourceType === "sheetworker") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			updateCharLevel(null, null, eventInfo);
		}
	}));
	on("change:repeating_ability:compendium_category", _exportsLoaderTASTheAaronSheet2.default.callback(function eventAbilityCompendium(eventInfo) {
		if (eventInfo.sourceAttribute !== "sheetworker") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			importFromCompendium(null, eventInfo);
		}
	}));
	on("change:repeating_ability:create-attack-entry", _exportsLoaderTASTheAaronSheet2.default.callback(function eventcreateAttackEntryFromSLA(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			createAttackEntryFromRow(null, null, false, eventInfo);
		}
	}));
	on("change:repeating_ability:CL-misc-mod change:repeating_ability:CL-basis-mod change:repeating_ability:range_pick change:repeating_ability:range", _exportsLoaderTASTheAaronSheet2.default.callback(function eventClassRangeMod(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		//cl-misc-mod, cl-basis-mod  is sheetworker, range_pick and range must be player
		if (/range/i.test(eventInfo.sourceAttribute) && (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") || /CL/i.test(eventInfo.sourceAttribute) && eventInfo.sourceType === "sheetworker") {
			updateAbilityRange(null, null, false, eventInfo);
		}
	}));
	eventToWatch = _underscore2.default.reduce(events.attackEventsSLA, function (memo, attr) {
		memo += "change:repeating_ability:" + attr + " ";
		return memo;
	}, "");
	on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventupdateAssociatedSLAttackAttack(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event" + eventInfo.sourceType);
		updateAssociatedAttack(null, null, null, eventInfo);
	}));
	on("change:repeating_ability:rule_category change:repeating_ability:ability_type", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateSLARuleCat(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event" + eventInfo.sourceType);
		setRuleTab(null, null, eventInfo);
	}));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFAbility module loaded        ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.applyConditions = applyConditions;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* PFChecks.applyConditions - handles changes to skill and ability checks due to conditions AND buffs.
 * Reads in condition that affect Ability and Skill checks and updates condition fields.
 * checks-cond, Phys-skills-cond, Perception-cond.
 */
function applyConditions(callback, silently) {
	var done = function done() {
		if (typeof callback === "function") {
			callback();
		}
	};
	getAttrs(["condition-Blinded", "condition-Fear", "condition-Drained", "condition-Sickened", "condition-Wounds", "has_endurance_feat", "wounds_gritty_mode", "checks-cond", "Phys-skills-cond", "Perception-cond", "wound_threshold-show", "CasterLevel-Penalty"], function (v) {
		//there is no Fascinated, if we add it then:
		//,"condition-Fascinated" -4 to perception
		var setter = {},
		    params = {},
		    drained = 0,
		    fear = 0,
		    sick = 0,
		    woundPenalty = 0,
		    wounds = 0,
		    allSkillsMod = 0,
		    casterlevel = 0,
		    blindedMod = 0,
		    currAllSkills = 0,
		    currPhysSkills = 0,
		    currPerSkills = 0,
		    currCaster = 0;
		try {
			drained = parseInt(v["condition-Drained"], 10) || 0;
			fear = -1 * (parseInt(v["condition-Fear"], 10) || 0);
			sick = -1 * (parseInt(v["condition-Sickened"], 10) || 0);
			woundPenalty = PFUtils.getWoundPenalty(parseInt(v["condition-Wounds"], 10) || 0, parseInt(v.has_endurance_feat, 10) || 0, parseInt(v.wounds_gritty_mode, 10) || 0);
			wounds = (parseInt(v["wound_threshold-show"], 10) || 0) * woundPenalty;
			allSkillsMod = drained + fear + sick + wounds;
			casterlevel = drained + wounds;
			blindedMod = -2 * (parseInt(v["condition-Blinded"], 10) || 0);
			currAllSkills = parseInt(v["checks-cond"], 10) || 0;
			currPhysSkills = parseInt(v["Phys-skills-cond"], 10) || 0;
			currPerSkills = parseInt(v["Perception-cond"], 10) || 0;
			currCaster = parseInt(v["CasterLevel-Penalty"], 10) || 0;
			if (allSkillsMod !== currAllSkills || isNaN(currAllSkills)) {
				setter["checks-cond"] = allSkillsMod;
			}
			if (blindedMod !== currPhysSkills || isNaN(currPhysSkills)) {
				setter["Phys-skills-cond"] = blindedMod;
			}
			if (blindedMod !== currPerSkills || isNaN(currPerSkills)) {
				setter["Perception-cond"] = blindedMod;
			}
			if (casterlevel !== currCaster || isNaN(currCaster)) {
				setter["CasterLevel-Penalty"] = casterlevel;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFChecks.applyConditions", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				setAttrs(setter, {}, done);
			} else {
				done();
			}
		}
	});
}
_PFLog.PFConsole.log('   PFChecks module loaded         ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.updateLoadsAndLift = updateLoadsAndLift;
exports.updateModifiedSpeed = updateModifiedSpeed;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFDefense = __webpack_require__(13);

var PFDefense = _interopRequireWildcard(_PFDefense);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Returns the carrying capacity for a given strength score and load type
// Will recursively calculate for strength scores over 29
function getCarryingCapacity(str, load) {
    var l, m, h, r;
    switch (str) {
        case 0:
            l = 0;
            m = 0;
            h = 0;
            break;
        case 1:
            l = 3;
            m = 6;
            h = 10;
            break;
        case 2:
            l = 6;
            m = 13;
            h = 20;
            break;
        case 3:
            l = 10;
            m = 20;
            h = 30;
            break;
        case 4:
            l = 13;
            m = 26;
            h = 40;
            break;
        case 5:
            l = 16;
            m = 33;
            h = 50;
            break;
        case 6:
            l = 20;
            m = 40;
            h = 60;
            break;
        case 7:
            l = 23;
            m = 46;
            h = 70;
            break;
        case 8:
            l = 26;
            m = 53;
            h = 80;
            break;
        case 9:
            l = 30;
            m = 60;
            h = 90;
            break;
        case 10:
            l = 33;
            m = 66;
            h = 100;
            break;
        case 11:
            l = 38;
            m = 76;
            h = 115;
            break;
        case 12:
            l = 43;
            m = 86;
            h = 130;
            break;
        case 13:
            l = 50;
            m = 100;
            h = 150;
            break;
        case 14:
            l = 58;
            m = 116;
            h = 175;
            break;
        case 15:
            l = 66;
            m = 133;
            h = 200;
            break;
        case 16:
            l = 76;
            m = 153;
            h = 230;
            break;
        case 17:
            l = 86;
            m = 173;
            h = 260;
            break;
        case 18:
            l = 100;
            m = 200;
            h = 300;
            break;
        case 19:
            l = 116;
            m = 233;
            h = 350;
            break;
        case 20:
            l = 133;
            m = 266;
            h = 400;
            break;
        case 21:
            l = 153;
            m = 306;
            h = 460;
            break;
        case 22:
            l = 173;
            m = 346;
            h = 520;
            break;
        case 23:
            l = 200;
            m = 400;
            h = 600;
            break;
        case 24:
            l = 233;
            m = 466;
            h = 700;
            break;
        case 25:
            l = 266;
            m = 533;
            h = 800;
            break;
        case 26:
            l = 306;
            m = 613;
            h = 920;
            break;
        case 27:
            l = 346;
            m = 693;
            h = 1040;
            break;
        case 28:
            l = 400;
            m = 800;
            h = 1200;
            break;
        case 29:
            l = 466;
            m = 933;
            h = 1400;
            break;
        default:
            l = getCarryingCapacity(str - 10, "light") * 4;
            m = getCarryingCapacity(str - 10, "medium") * 4;
            h = getCarryingCapacity(str - 10, "heavy") * 4;
            break;
    }
    switch (load) {
        case "light":
            r = l;
            break;
        case "medium":
            r = m;
            break;
        case "heavy":
            r = h;
            break;
    }
    return r;
}

/* updateCurrentLoad-updates the current load radio button */
function updateCurrentLoad(callback, silently) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    };
    getAttrs(["load-light", "load-medium", "load-heavy", "load-max", "current-load", "carried-total", "max-dex-source"], function (v) {
        var curr = 0,
            carried = 0,
            light = 0,
            medium = 0,
            heavy = 0,
            max = 0,
            maxDexSource = 0,
            ignoreEncumbrance = 0,
            newLoad = 0,
            setter = {},
            params = {};
        try {
            //TAS.debug("at updateCurrentLoad",v);
            maxDexSource = parseInt(v["max-dex-source"], 10) || 0;
            ignoreEncumbrance = maxDexSource === 1 || maxDexSource === 3 ? 1 : 0;
            curr = parseInt(v["current-load"], 10) || 0;
            if (ignoreEncumbrance) {
                newLoad = 0;
            } else {

                carried = parseInt(v["carried-total"], 10) || 0;
                light = parseInt(v["load-light"], 10) || 0;
                medium = parseInt(v["load-medium"], 10) || 0;
                heavy = parseInt(v["load-heavy"], 10) || 0;
                max = heavy * 2;

                //TAS.debug"current-load=" + curr + ", carried-total=" + carried + ", load-light=" + light + ", load-medium=" + medium);
                if (carried <= light) {
                    //TAS.debug("light load");
                    newLoad = 0;
                } else if (carried <= medium) {
                    //TAS.debug("medium load");
                    newLoad = 1;
                } else if (carried <= heavy) {
                    //TAS.debug("heavy load");
                    newLoad = 2;
                } else if (carried <= max) {
                    //TAS.debug"over heavy but under max");
                    newLoad = 3;
                } else if (carried > max) {
                    //TAS.debug"maximum load");
                    newLoad = 4;
                }
            }
            if (curr !== newLoad) {
                setter["current-load"] = newLoad;
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFEncumbrance.updateCurrentLoad", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                setAttrs(setter, params, done);
            } else {
                done();
            }
        }
    });
}
/* updateLoadsAndLift
 * updates the load and lift numbers
 */
function updateLoadsAndLift(callback, silently) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    getAttrs(["STR", "size", "size-multiplier", "legs", "load-light", "load-medium", "load-heavy", "load-max", "lift-above-head", "lift-off-ground", "lift-drag-and-push", "load-str-bonus", "load-multiplier", "total-load-multiplier", "load-misc"], function (v) {
        var str = 10,
            size = 1,
            sizeMult = 1,
            currSizeMult = 1,
            currTotalLoadMult = 1,
            legs = 2,
            light = 0,
            medium = 0,
            heavy = 0,
            max = 0,
            aboveHead = 0,
            offGround = 0,
            drag = 0,
            strMod = 0,
            loadMult = 1,
            mult = 1,
            misc = 0,
            l = 0,
            m = 0,
            h = 0,
            a = 0,
            o = 0,
            d = 0,
            setter = {},
            params = {};
        try {
            str = parseInt(v["STR"], 10) || 0;
            size = parseInt(v["size"], 10) || 0;
            sizeMult = parseInt(v["size-multiplier"], 10) || 0;
            currSizeMult = sizeMult;
            currTotalLoadMult = parseInt(v["total-load-multiplier"], 10) || 0;
            legs = parseInt(v["legs"], 10) || 0;
            if (legs !== 4) {
                legs = 2;
            }
            light = parseInt(v["load-light"], 10) || 0;
            medium = parseInt(v["load-medium"], 10) || 0;
            heavy = parseInt(v["load-heavy"], 10) || 0;
            max = parseInt(v["load-max"], 10) || 0;
            aboveHead = parseInt(v["lift-above-head"], 10) || 0;
            offGround = parseInt(v["lift-off-ground"], 10) || 0;
            drag = parseInt(v["lift-drag-and-push"], 10) || 0;
            strMod = parseInt(v["load-str-bonus"], 10) || 0;
            loadMult = parseInt(v["load-multiplier"], 10) || 0;
            mult = 1;
            misc = parseInt(v["load-misc"], 10) || 0;
            l = getCarryingCapacity(str + strMod, "light") + misc;
            m = getCarryingCapacity(str + strMod, "medium") + misc;
            h = getCarryingCapacity(str + strMod, "heavy") + misc;
            if (loadMult < 1) {
                loadMult = 1;
            }
            loadMult--;
            //TAS.debug("STR=" + str + ", legs=" + legs + ", load-light=" + light + ", load-medium=" + medium + ", load-heavy=" + heavy + ", lift-above-head=" + aboveHead + ", lift-off-ground=" + offGround + ", lift-drag-and-push=" + drag + ", load-str-bonus=" + strMod + ", load-multiplier=" + loadMult + ", load-misc=" + misc);
            if (legs !== 4) {
                switch (size) {
                    case -8:
                        sizeMult = 16;
                        break;
                    case -4:
                        sizeMult = 8;
                        break;
                    case -2:
                        sizeMult = 4;
                        break;
                    case -1:
                        sizeMult = 2;
                        break;
                    case 1:
                        sizeMult = 3 / 4;
                        break;
                    case 2:
                        sizeMult = 1 / 2;
                        break;
                    case 4:
                        sizeMult = 1 / 4;
                        break;
                    case 8:
                        sizeMult = 1 / 8;
                        break;
                    default:
                        sizeMult = 1;
                }
            } else if (legs === 4) {
                switch (size) {
                    case -8:
                        sizeMult = 24;
                        break;
                    case -4:
                        sizeMult = 12;
                        break;
                    case -2:
                        sizeMult = 6;
                        break;
                    case -1:
                        sizeMult = 3;
                        break;
                    case 0:
                        sizeMult = 1.5;
                        break;
                    case 1:
                        sizeMult = 1;
                        break;
                    case 2:
                        sizeMult = 3 / 4;
                        break;
                    case 4:
                        sizeMult = 1 / 2;
                        break;
                    case 8:
                        sizeMult = 1 / 4;
                        break;
                    default:
                        sizeMult = 1.5;
                }
            }
            mult += loadMult;
            mult *= sizeMult;
            l *= mult;
            m *= mult;
            h *= mult;
            a = h;
            o = h * 2;
            d = h * 5;
            //TAS.debug("new light load=" + l + ", new medium load=" + m + ", new heavy load=" + h + ", new above head=" + a + ", new off ground=" + o + ", new drag=" + d);
            if (currSizeMult !== sizeMult) {
                setter["size-multiplier"] = sizeMult;
            }
            if (currTotalLoadMult !== mult) {
                setter["total-load-multiplier"] = mult;
            }
            if (light !== l) {
                setter["load-light"] = l;
            }
            if (medium !== m) {
                setter["load-medium"] = m;
            }
            if (heavy !== h) {
                setter["load-heavy"] = h;
            }
            if (max !== h * 2) {
                setter["load-max"] = h * 2;
            }
            if (aboveHead !== a) {
                setter["lift-above-head"] = a;
            }
            if (offGround !== o) {
                setter["lift-off-ground"] = o;
            }
            if (drag !== d) {
                setter["lift-drag-and-push"] = d;
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("updateLoadsAndLift", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                setAttrs(setter, params, done);
            } else {
                done();
            }
        }
    });
}
/* updateModifiedSpeed
 * updates the modified speed and run values  */
function updateModifiedSpeed(callback) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    }),
        attribList = ["current-load", "speed-base", "speed-modified", "speed-run", "race", "is_dwarf", "max-dex-source", "run-mult", "buff_speed-total"];
    _underscore2.default.each(PFDefense.defenseArmorShieldRows, function (row) {
        attribList.push(row + "-equipped");
        attribList.push(row + "-type");
    });
    getAttrs(attribList, function (v) {
        var currSpeed = parseInt(v["speed-modified"], 10) || 0,
            currRun = parseInt(v["speed-run"], 10) || 0,
            currLoad = parseInt(v["current-load"], 10) || 0,
            base = parseInt(v["speed-base"], 10) || 0,
            speedDropdown = parseInt(v["max-dex-source"], 10) || 0,
            origRunMult = isNaN(parseInt(v["run-mult"], 10)) ? 4 : parseInt(v["run-mult"], 10),
            buff = parseInt(v["buff_speed-total"], 10) || 0,
            newSpeed = base,
            runMult = origRunMult,
            newRun = base * runMult,
            combinedLoad = 0,
            isDwarf = false,
            inHeavy = false,
            inMedium = false,
            armor3Equipped = 0,
            armorLoad = 0,
            setter = {};
        try {
            base = base + buff;
            newSpeed = newSpeed + buff;
            //TAS.debug("speed-modified=" + currSpeed + ", speed-run=" + currRun + ", current-load=" + currLoad + ", speed-base=" + base + ", load-heavy=" + heavy + ", carried-total=" + carried);
            // #0: Armor, Shield & Load
            // #1: Armor & Shield only
            // #2: Load only
            // #3: None
            if (speedDropdown !== 3) {
                armor3Equipped = parseInt(v["armor3-equipped"], 10) || 0;
                //dwarf base speed not lowered but run multiplier can be.
                isDwarf = parseInt(v.is_dwarf, 10) || 0;
                if (!isDwarf) {
                    isDwarf = typeof v.race === "undefined" ? false : v.race.toLowerCase().indexOf("dwarf") >= 0;
                    if (isDwarf) {
                        setter["is_dwarf"] = 1;
                    }
                }
                if (speedDropdown === 0 || speedDropdown === 1) {
                    if (armor3Equipped) {
                        if (v["armor3-type"] === "Heavy") {
                            armorLoad = 2;
                        } else if (v["armor3-type"] === "Medium") {
                            armorLoad = 1;
                        }
                    }
                }
                combinedLoad = Math.max(armorLoad, currLoad);
                if (combinedLoad === 4) {
                    newSpeed = 0;
                    newRun = 0;
                    runMult = 0;
                } else if (combinedLoad === 3) {
                    newSpeed = 5;
                    newRun = 0;
                    runMult = 0;
                } else if (combinedLoad === 2 || combinedLoad === 1) {
                    if (!isDwarf) {
                        if (base <= 5) {
                            newSpeed = 5;
                        } else if (base % 15 === 0) {
                            newSpeed = base * 2 / 3;
                        } else if ((base + 5) % 15 === 0) {
                            newSpeed = (base + 5) * 2 / 3;
                        } else {
                            newSpeed = (base + 10) * 2 / 3 - 5;
                        }
                    }
                    runMult--;
                } else {
                    newSpeed = base;
                }
            }
            newRun = newSpeed * runMult;
            if (currSpeed !== newSpeed) {
                setter["speed-modified"] = newSpeed;
            }
            if (currRun !== newRun) {
                setter["speed-run"] = newRun;
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFEncumbrance.updateModifiedSpeed", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                setAttrs(setter, {}, done);
            } else {
                done();
            }
        }
    });
}
function migrate(callback) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    };
    getAttrs(['max-dex-source'], function (v) {
        var val = parseInt(v['max-dex-source'], 10);
        if (isNaN(val)) {
            setAttrs({ 'max-dex-source': 0 }, _PFConst2.default.silentParams, done);
        } else {
            done();
        }
    });
}
function recalculate(callback, silently, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFEncumbrance.recalculate");
        if (typeof callback === "function") {
            callback();
        }
    }),
        setSpeedWhenDone = _underscore2.default.once(function () {
        updateModifiedSpeed(done);
    }),
        setEncumbrance = _underscore2.default.once(function () {
        updateCurrentLoad(setSpeedWhenDone);
    }),
        setLoadCapability = _underscore2.default.once(function () {
        updateLoadsAndLift(setEncumbrance, silently);
    });
    try {
        migrate(setLoadCapability);
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFEncumbrance.recalculate", err);
        done();
    }
}
function registerEventHandlers() {
    on("change:current-load change:speed-base change:race change:armor3-equipped change:armor3-type change:max-dex-source change:run-mult", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateModifiedSpeed(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        updateModifiedSpeed();
    }));
    on('change:load-light change:carried-total', _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateCurrentLoad(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "sheetworker") {
            updateCurrentLoad();
        }
    }));
    on("change:STR change:legs change:load-str-bonus change:load-multiplier change:load-misc", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateLoadsAndLift(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        updateLoadsAndLift();
    }));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFEncumbrance module loaded    ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.setWoundThreshholdsLookup = setWoundThreshholdsLookup;
exports.updateCurrHPLookup = updateCurrHPLookup;
exports.updateMaxHPLookup = updateMaxHPLookup;
exports.updateTempMaxHP = updateTempMaxHP;
exports.setToPFS = setToPFS;
exports.ensureNPCHPZero = ensureNPCHPZero;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

var _PFClassRaceGrid = __webpack_require__(27);

var PFClassRaceGrid = _interopRequireWildcard(_PFClassRaceGrid);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*setWoundLevel sets would level based on current HP when you already have all fields.
 * sets  @{condition-Wounds} based on :
 *@hp current hp
 *@grazed {int} hp  value for grazed level
 *@wounded {int} hp value for wounded level
 *@critical {int} hp value for critical level
 *@currWounds {int}  value of @{condition-Wounds}
 */
function setWoundLevel(hp, grazed, wounded, critical, currWounds) {
	var setWounds = 0;
	_exportsLoaderTASTheAaronSheet2.default.debug("at PFHealth.setWoundLevel, hp is " + hp);
	if (hp <= grazed) {
		if (hp > wounded) {
			setWounds = 1;
		} else if (hp > critical) {
			setWounds = 2;
		} else {
			setWounds = 3;
		}
	}
	//TAS.debug("PFHealth.setWoundLevel, hp:"+hp+", currWounds:"+currWounds+", setWounds:"+setWounds);
	if (setWounds !== currWounds) {
		setAttrs({
			"condition-Wounds": setWounds
		});
	}
}
/*setWoundLevelLookup - looks up data needed to set current would level.
 * calls setWoundLevel
 * @hp {int} the current hit points. will look up if this is not set.
 */
function setWoundLevelLookup(hp) {
	//TAS.debug"PFHealth.setWoundLevelLookup, hp passed in is:" + hp);
	_exportsLoaderTASTheAaronSheet2.default.debug("at PFHealth.setWoundLevelLookup, hp is " + hp);
	getAttrs(["HP", "HP_grazed", "HP_wounded", "HP_critical", "condition-Wounds", "wound_threshold-show"], function (v) {
		if (parseInt(v["wound_threshold-show"], 10)) {
			if (isNaN(parseInt(hp, 10))) {
				hp = parseInt(v["HP"], 10) || 0;
			}
			//TAS.debug("PFHealth.setWoundLevelLookup",v);
			setWoundLevel(hp, parseInt(v["HP_grazed"], 10) || 0, parseInt(v["HP_wounded"], 10) || 0, parseInt(v["HP_critical"], 10) || 0, parseInt(v["condition-Wounds"], 10) || 0);
		}
	});
}
/*setWoundThreshholds - sets wound thresholds when you already have hp data.
 * Also calls setWoundLevel
 * @hp {int} = current hit points @{HP}
 * @maxHP {int} = max hp @{HP|max}
 * @currWoundLevel {int} = @{condition-Wounds}
 * @abilityMod {int} = usually @{CON-mod} or mod of whataver ability is used. 0 if no ability (like undead)
 */
function setWoundThreshholds(hp, maxHP, currWoundLevel, abilityMod, v) {
	var setter = {},
	    grazed = 0,
	    wounded = 0,
	    critical = 0,
	    disabled = 0;
	try {
		_exportsLoaderTASTheAaronSheet2.default.debug("at PFHealth.setWoundThreshholds, hp is" + hp);
		grazed = Math.floor(maxHP * 0.75);
		wounded = Math.floor(maxHP * 0.5);
		critical = Math.floor(maxHP * 0.25);
		disabled = (abilityMod > 0 ? abilityMod : 0) * -1;
		if ((parseInt(v["HP_grazed"], 10) || 0) !== grazed) {
			setter["HP_grazed"] = grazed;
		}
		if ((parseInt(v["HP_wounded"], 10) || 0) !== wounded) {
			setter["HP_wounded"] = wounded;
		}
		if ((parseInt(v["HP_critical"], 10) || 0) !== critical) {
			setter["HP_critical"] = critical;
		}
		if ((parseInt(v["HP_disabled"], 10) || 0) !== disabled) {
			setter["HP_disabled"] = disabled;
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFHealth.setWoundThresholds", err);
	} finally {
		if (_underscore2.default.size(setter) > 0) {
			setAttrs(setter, _PFConst2.default.silentParams, function () {
				setWoundLevel(hp, grazed, wounded, critical, currWoundLevel);
			});
		} else {
			setWoundLevel(hp, grazed, wounded, critical, currWoundLevel);
		}
	}
}
/*setWoundThreshholdsLookup
 * Sets wound thresholds by looking up values for "are we even useing wound threshold rules?" and the max hit points.
 * Calls the other setWoundThresholds
 * If Wound Threshholds are not used, makes sure that condition-Wounds is set to 0.
 */
function setWoundThreshholdsLookup() {
	_exportsLoaderTASTheAaronSheet2.default.debug("at PFHealth.setWoundThreshholdsLookup");
	getAttrs(["HP", "HP_max", "wound_threshold-show", "condition-Wounds", "HP-ability-mod", "HP_grazed", "HP_wounded", "HP_critical", "HP_disabled"], function (v) {
		if (parseInt(v["wound_threshold-show"], 10) === 1) {
			setWoundThreshholds(parseInt(v["HP"], 10) || 0, parseInt(v["HP_max"], 10) || 0, parseInt(v["condition-Wounds"], 10) || 0, parseInt(v["HP-ability-mod"], 10) || 0, v);
		} else if ((parseInt(v["condition-Wounds"], 10) || 0) !== 0) {
			setAttrs({
				"condition-Wounds": "0"
			});
		}
	});
}
/** updateCurrHP- when updating hp, check nonLethalDmg level and wound threshold levels
 * 
 * @param {int} hp 
 * @param {int} temphp 
 * @param {int} nonLethalDmg 
 * @param {boolean} usesWounds 
 * @param {string} hpAbility value of hp dropdown 
 * @param {int} hpAbilityMod 
 * @param {boolean} staggered 
 */
function updateCurrHP(hp, temphp, nonLethalDmg, usesWounds, hpAbility, hpAbilityMod, staggered) {
	if (hpAbility !== "0") {
		if (nonLethalDmg >= hp + temphp + (usesWounds ? 1 + hpAbilityMod : 0)) {
			setAttrs({
				"condition-Staggered": "1"
			}, _PFConst2.default.silentParams);
		} else if (staggered) {
			setAttrs({
				"condition-Staggered": "0"
			}, _PFConst2.default.silentParams);
		}
	}
	if (usesWounds) {
		setWoundLevelLookup(hp);
	}
}
/* updateCurrHPLookup - looks up data and calls updateCurrHP */
function updateCurrHPLookup() {
	getAttrs(["HP", "HP-temp", "non-lethal-damage", "wound_threshold-show", "HP-ability", "HP-ability-mod", "condition-Staggered"], function (v) {
		//TAS.debug("PFHealth.updateCurrHPLookup",v);
		updateCurrHP(parseInt(v["HP"], 10) || 0, parseInt(v["HP-temp"], 10) || 0, parseInt(v["non-lethal-damage"], 10) || 0, parseInt(v["wound_threshold-show"], 10) || 0, v["HP-ability"], parseInt(v["HP-ability-mod"], 10) || 0, parseInt(v["condition-Staggered"], 10) || 0);
	});
}
/** updateMaxHPLookup
 * sets max HP
 * @param {function} callback when done
 * @param {boolean} silently if T then call setAttrs with {silent:True}
 * @param {boolean} forceReset recalculates max HP and sets HP to it.
 * @param {object} eventInfo unused
 */
function updateMaxHPLookup(callback, silently, eventInfo, forceReset) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving updateMaxHPLookup");
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["HP", "HP_max", "HP-ability", "HP-ability-mod", "level", "total-hp", "total-mythic-hp", "condition-Drained", "HP-formula-mod", "HP-temp", "mythic-adventures-show", "wound_threshold-show", "condition-Wounds", "non-lethal-damage", "non-lethal-damage_max", "condition-Staggered", "hp_ability_bonus", "HP_grazed", "HP_wounded", "HP_critical", "HP_disabled", "increase_hp"], function (v) {
		var abilityMod = 0,
		    abilityBonus = 0,
		    currHPMax = 0,
		    currHP = 0,
		    tempHP = 0,
		    newHP = 0,
		    increaseHPWhenMaxHPIncreases = 0,
		    nonLethal = 0,
		    newHPMax = 0,
		    mythic = 0,
		    currWoundLevel = 0,
		    usesWounds = 0,
		    setter = {};
		try {
			increaseHPWhenMaxHPIncreases = parseInt(v.increase_hp, 10) || 0;
			abilityMod = parseInt(v["HP-ability-mod"], 10) || 0;
			abilityBonus = abilityMod * (parseInt(v["level"], 10) || 0);
			currHPMax = parseInt(v["HP_max"], 10) || 0;
			currHP = parseInt(v["HP"], 10) || 0;
			tempHP = parseInt(v["HP-temp"], 10) || 0;
			usesWounds = parseInt(v["wound_threshold-show"], 10) || 0;
			newHP = currHP;
			nonLethal = parseInt(v["non-lethal-damage"], 10) || 0;
			mythic = parseInt(v["mythic-adventures-show"], 10) || 0;
			//TAS.debug("at updateMaxHPLookup",v);
			newHPMax = abilityBonus + (parseInt(v["total-hp"], 10) || 0) + (parseInt(v["HP-formula-mod"], 10) || 0) + 5 * (parseInt(v["condition-Drained"], 10) || 0) + (mythic ? parseInt(v["total-mythic-hp"], 10) || 0 : 0);
			if (usesWounds) {
				currWoundLevel = parseInt(v["condition-Wounds"], 10) || 0;
			}
			if (forceReset) {
				newHP = newHPMax;
				if (nonLethal !== 0) {
					setter["non-lethal-damage"] = 0;
					setter["condition-Staggered"] = 0;
				}
				if (usesWounds) {
					setter["condition-Wounds"] = 0;
				}
			} else {
				newHP = currHP + newHPMax - currHPMax;
			}
			if (abilityBonus !== parseInt(v.hp_ability_bonus, 10)) {
				setter["hp_ability_bonus"] = abilityBonus;
			}
			if (increaseHPWhenMaxHPIncreases && newHP !== currHP) {
				setter.HP = newHP;
			} else if (!increaseHPWhenMaxHPIncreases) {
				newHP = currHP;
			}
			if (currHPMax !== newHPMax) {
				setter.HP_max = newHPMax;
			}
			if (newHPMax !== parseInt(v["non-lethal-damage_max"], 10)) {
				setter["non-lethal-damage_max"] = newHPMax;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFHealth.updateMaxHPLookup", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				setAttrs(setter, _PFConst2.default.silentParams, function () {
					if (increaseHPWhenMaxHPIncreases && !(forceReset || currHPMax === newHPMax)) {
						updateCurrHP(newHP, tempHP, nonLethal, 0, v["HP-ability"], abilityMod, v["condition-Staggered"]);
						if (usesWounds) {
							setWoundThreshholds(newHP + tempHP, newHPMax, currWoundLevel, abilityMod, v);
						}
					}
					done();
				});
			} else {
				done();
			}
		}
	});
}
/* updateTempMaxHP
 * sets temp hp
 */
function updateTempMaxHP(callback, silently, forceReset) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["HP-temp", "HP-temp_max", "HP-temp-misc", "buff_HP-temp-total"], function (v) {
		var newHPTempMax,
		    currHPTemp,
		    newHPTemp,
		    params = {};
		try {
			//TAS.debug("at updateTempMaxHP",v);
			newHPTempMax = (parseInt(v["HP-temp-misc"], 10) || 0) + (parseInt(v["buff_HP-temp-total"], 10) || 0);
			currHPTemp = parseInt(v["HP-temp"], 10) || 0;
			newHPTemp = forceReset ? newHPTempMax : currHPTemp + newHPTempMax - currHPTemp;
			if (forceReset || newHPTemp !== currHPTemp) {
				if (silently) {
					params = _PFConst2.default.silentParams;
				}
				setAttrs({
					"HP-temp": newHPTemp,
					"HP-temp_max": newHPTempMax
				}, params, function () {
					updateCurrHPLookup(); //check for change due to non lethal
					done();
				});
			} else {
				done();
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("updateTempMaxHP", err);
			done();
		}
	});
}
function setToPFS(callback, eventInfo) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	setAttrs({ 'use_prestige_fame': 1, 'auto_calc_hp': 1, 'autohp_percent': 1, 'maxhp_lvl1': 1 }, _PFConst2.default.silentParams, function () {
		if (eventInfo) {
			PFClassRaceGrid.setHitPoints(done, false, eventInfo);
		}
	});
}
function ensureNPCHPZero(callback) {
	getAttrs(['npc-hd', 'npc-hd-num', 'NPC-HP', 'is_npc'], function (v) {
		var npcHD = parseInt(v['npc-hd'], 10) || 0,
		    npcLevels = parseInt(v['npc-hd-num'], 10) || 0,
		    npcHP = parseInt(v['NPC-HP'], 10) || 0,
		    isNPC = parseInt(v.is_npc, 10) || 0;
		if (!isNPC) {
			if (!npcHD && !npcLevels && npcHP) {
				setAttrs({ 'npc-hd-num': '', 'NPC-HP': 0 });
			}
		} else {
			setAttrs({
				'npc-hd-num2': 0,
				'npc-hd2': 0,
				'HP-misc': '',
				'HP-misc-mod': 0
			});
		}
	});
}
function migrate(callback, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFHealth.migrate 2");
		if (typeof callback === "function") {
			callback();
		}
	});
	PFMigrate.migrateHPMisc(done);
	if (oldversion < 1.18) {
		ensureNPCHPZero();
	}
}
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFHealth.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    resetWounds = _underscore2.default.once(function () {
		setWoundThreshholdsLookup();
		done();
	}),
	    callUpdateMaxHPLookup = _underscore2.default.once(function () {
		updateMaxHPLookup(resetWounds, silently);
	}),
	    callUpdateTempHP = _underscore2.default.once(function () {
		updateTempMaxHP(callUpdateMaxHPLookup);
	});
	_exportsLoaderTASTheAaronSheet2.default.debug("at PFHealth.recalculate");
	migrate(callUpdateTempHP, oldversion);
}
function registerEventHandlers() {
	on("change:set_pfs", _exportsLoaderTASTheAaronSheet2.default.callback(function eventsetPFSFlag(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			getAttrs(["set_pfs"], function (v) {
				if (parseInt(v.set_pfs, 10)) {
					setToPFS(null, eventInfo);
				}
			});
		}
	}));
	//hp************************************************************************
	on("change:hp-ability-mod change:level change:total-hp change:total-mythic-hp change:hp-formula-mod change:HP-misc", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateHPPlayerMisc(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api" || eventInfo.sourceType === "sheetworker" && eventInfo.sourceAttribute !== "hp-misc") {
			updateMaxHPLookup();
		}
	}));
	on("change:mythic-adventures-show", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateHPPlayer(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			getAttrs(["total-mythic-hp"], function (v) {
				if ((parseInt(v["total-mythic-hp"], 10) || 0) > 0) {
					updateMaxHPLookup();
				}
			});
		}
	}));
	on("change:hp-temp-misc", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateTempHP(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			updateTempMaxHP();
		}
	}));
	on("change:HP_reset", _exportsLoaderTASTheAaronSheet2.default.callback(function eventResetHP(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			updateMaxHPLookup(null, null, eventInfo, true);
			updateTempMaxHP(null, null, true);
			setAttrs({
				"HP_reset": "0"
			}, _PFConst2.default.silentParams);
		}
	}));
	on("change:HP change:non-lethal-damage", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateHPCurr(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			updateCurrHPLookup(eventInfo);
		}
	}));
	on("change:wound_threshold-show", _exportsLoaderTASTheAaronSheet2.default.callback(function eventResetConditionWounds(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			setWoundThreshholdsLookup(eventInfo);
		}
	}));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFHealth module loaded         ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.updateInitiative = updateInitiative;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Updates @{init} 
 * @param {function} callback when done
 * @param {boolean} silently if call setAttrs with silent:true
 * @param {boolean} force pass to SWUtils.updateRowTotal
 */
function updateInitiative(callback, silently, force) {
	getAttrs(['nodex-toggle'], function (v) {
		if (parseInt(v['nodex-toggle'], 10)) {
			//if lose dex then lose ability mod no matter what ability it is, since init is a dex check:
			//http://paizo.com/paizo/faq/v5748nruor1fm#v5748eaic9tga
			SWUtils.updateRowTotal(["init", "init-trait", "init-misc-mod", "checks-cond", "buff_initiative-total", "buff-Check-total"], 0, ["condition-Deafened"], false, callback, silently, force);
		} else {
			SWUtils.updateRowTotal(["init", "init-ability-mod", "init-trait", "init-misc-mod", "checks-cond", "buff_initiative-total", "buff-Check-total"], 0, ["condition-Deafened"], false, callback, silently, force);
		}
	});
}
function migrate(callback, oldversion) {
	var done = function done() {
		if (typeof callback === "function") {
			callback();
		}
	};
	if (oldversion < 1.18) {
		updateInitiative(done, false, true);
	} else {
		done();
	}
}
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.info("Leaving PFInitiative.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	});
	migrate(function () {
		updateInitiative(done, silently);
	}, oldversion);
}
function registerEventHandlers() {
	on("change:init-trait change:condition-Deafened ", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateInitPlayer(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			updateInitiative();
		}
	}));
	on("change:init-ability-mod change:init-misc-mod change:checks-cond change:nodex-toggle", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateInitSheet(eventInfo) {
		if (eventInfo.sourceType === "sheetworker") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			updateInitiative();
		}
	}));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFInitiative module loaded     ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.saveTypes = undefined;
exports.applyConditions = applyConditions;
exports.updateSave = updateSave;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var saveTypes = exports.saveTypes = ["Fort", "Ref", "Will"];
var events = {
	saveEventsAuto: "change:saves-cond change:total-REPLACE change:REPLACE-ability-mod",
	saveEventsPlayer: "change:REPLACE-trait change:REPLACE-enhance change:REPLACE-resist change:REPLACE-misc"
};

function applyConditions(callback, silently) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["condition-Fear", "condition-Sickened", "condition-Drained", "condition-Wounds", "saves-cond", "has_endurance_feat", "wounds_gritty_mode", "wound_threshold-show"], function (v) {
		var fear = 0,
		    sickened = 0,
		    drained = 0,
		    wounds = 0,
		    currCond = 0,
		    newCond = 0,
		    params = {},
		    setter = {};
		try {
			fear = parseInt(v["condition-Fear"], 10) || 0;
			sickened = parseInt(v["condition-Sickened"], 10) || 0;
			drained = parseInt(v["condition-Drained"], 10) || 0;
			wounds = (parseInt(v["wound_threshold-show"], 10) || 0) * PFUtils.getWoundPenalty(parseInt(v["condition-Wounds"], 10) || 0, parseInt(v.has_endurance_feat, 10) || 0, parseInt(v.wounds_gritty_mode, 10) || 0);
			currCond = parseInt(v["saves-cond"], 10) || 0;
			newCond = drained - fear - sickened + wounds;
			if (currCond !== newCond) {
				setter["saves-cond"] = newCond;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFSaves.applyConditions", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				if (silently) {
					params = _PFConst2.default.silentParams;
				}
				setAttrs(setter, params, done);
			} else {
				done();
			}
		}
	});
}
/* updateSave - updates the saves for a character
* @save = type of save: Fort, Ref, Will  (first character capitalized)
*/
function updateSave(save, callback, silently) {
	var fields = [save, "total-" + save, save + "-ability-mod", save + "-trait", save + "-enhance", save + "-resist", save + "-misc", "saves-cond", "buff_" + save + "-total"];
	SWUtils.updateRowTotal(fields, 0, [], false, callback, silently);
}
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.info("leaving PFSaves.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    saved = _underscore2.default.after(3, function () {
		//TAS.debug"finished 3 saves");
		done();
	});
	_exportsLoaderTASTheAaronSheet2.default.debug("at PFSaves.recalculate");
	try {
		applyConditions(function () {
			try {
				updateSave("Fort", saved, silently);
				updateSave("Ref", saved, silently);
				updateSave("Will", saved, silently);
			} catch (err2) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFSaves.recalculate inner saves", err2);
				done();
			}
		}, silently);
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFSaves.recalculate OUTER", err);
		done();
	}
}
function registerEventHandlers() {
	_underscore2.default.each(saveTypes, function (save) {
		var eventToWatch = events.saveEventsAuto.replace(/REPLACE/g, save);
		on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateSaveAuto(eventInfo) {
			if (eventInfo.sourceType === "sheetworker") {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event for " + save + ": " + eventInfo.sourceType);
				updateSave(save, eventInfo);
			}
		}));
	});
	_underscore2.default.each(saveTypes, function (save) {
		var eventToWatch = events.saveEventsPlayer.replace(/REPLACE/g, save);
		on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateSavePlayer(eventInfo) {
			if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event for " + save + ": " + eventInfo.sourceType);
				updateSave(save, eventInfo);
			}
		}));
	});
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFSaves module loaded          ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ifSpellClassExists = ifSpellClassExists;
exports.updateMultiClassedCasterFlag = updateMultiClassedCasterFlag;
exports.applyConditions = applyConditions;
exports.setCasterClassFromDropdown = setCasterClassFromDropdown;
exports.updateCasterFromClassLevel = updateCasterFromClassLevel;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFLog = __webpack_require__(0);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFUtilsAsync = __webpack_require__(9);

var PFUtilsAsync = _interopRequireWildcard(_PFUtilsAsync);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

var _PFSpells = __webpack_require__(17);

var PFSpells = _interopRequireWildcard(_PFSpells);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//the 3 spell classes at top of spells page

/**  returns whether a base spell level is filled in or not
*@param {int} spellclassidx 0,1,2 sellcasting class
*@param {function} callback - to call if exists
*@param {function} noExistCallback - to call if not exists
*/
function ifSpellClassExists(spellclassidx, callback, noExistCallback) {
    getAttrs(["use_spells", "spellclass-" + spellclassidx + "-exists"], function (v) {
        try {
            if (!parseInt(v.use_spells, 10)) {
                if (typeof noExistCallback === "function") {
                    noExistCallback();
                }
            } else if (parseInt(v["spellclass-" + spellclassidx + "-exists"], 10)) {
                if (typeof callback === "function") {
                    callback();
                }
            } else {
                if (typeof noExistCallback === "function") {
                    noExistCallback();
                }
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpellCasterClasses.ifSpellClassExists", err);
            if (typeof noExistCallback === "function") {
                noExistCallback();
            }
        }
    });
}
/**  sets {spellclasses_multiclassed} to 1 if more than one spellclass-X-exists is 1
*@param {nothing} dummy - only here so eventhandlers can call it, since spellclass index is in this position.
*@param {eventinfo} eventInfo  unused eventinfo from 'on' method
*/
function updateMultiClassedCasterFlag(dummy, eventInfo, callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving updateMultiClassedCasterFlag");
        if (typeof callback === "function") {
            callback();
        }
    });
    getAttrs(["spellclass-0-exists", "spellclass-1-exists", "spellclass-2-exists"], function (v) {
        var multiclassed = parseInt(v["spellclasses_multiclassed"], 10) || 0,
            setter = {};
        if ((parseInt(v["spellclass-0-exists"], 10) || 0) + (parseInt(v["spellclass-1-exists"], 10) || 0) + (parseInt(v["spellclass-2-exists"], 10) || 0) > 1) {
            if (!multiclassed) {
                setter.spellclasses_multiclassed = 1;
            }
        } else if (multiclassed) {
            setter.spellclasses_multiclassed = 0;
        }
        if (_underscore2.default.size(setter) > 0) {
            setAttrs(setter, _PFConst2.default.silentParams, done);
        } else {
            done();
        }
    });
}
/** updates the ranges at the top for this spellcasting class
*@param {int} spellclassidx 0,1,2 the spell casting tab
*@param {eventinfo} eventInfo unused eventinfo from 'on' method
*@param {bool} force if true update no matter if new ranges are same or not.
*@param {function} callback - to call when done.
*@param {bool} silently if true update with PFConst.silentParams
*/
function updateCasterRanges(spellclassidx, eventInfo, force, callback, silently) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    },
        prefix = "spellclass-" + spellclassidx,
        lvlField = prefix + "-level-total",
        closeField = prefix + "-close",
        medField = prefix + "-medium",
        longField = prefix + "-long";
    getAttrs([lvlField, closeField, medField, longField], function (v) {
        var level = parseInt(v[lvlField], 10) || 0,
            closeRng = parseInt(v[closeField], 10) || 0,
            medRng = parseInt(v[medField], 10) || 0,
            longRng = parseInt(v[longField], 10) || 0,
            ranges = {},
            setter = {},
            params = {};
        try {
            ranges = PFUtils.calculateSpellRanges(level);
            if (force || ranges.close !== closeRng || ranges.medium !== medRng || ranges["long"] !== longRng) {
                setter[closeField] = ranges.close;
                setter[medField] = ranges.medium;
                setter[longField] = ranges["long"];
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpellCasterClasses.updateCasterRanges", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                setAttrs(setter, params, done);
            } else {
                done();
            }
        }
    });
}
/** updateConcentration - updates concentration for spellclass
*@param {int} classidx 0,1,2 the spellclass
*@param {eventinfo} eventInfo unused eventinfo from 'on' method
*@param {function} callback - to call when done.
*@param {bool} silently if true update with PFConst.silentParams
*/
function updateConcentration(classidx, eventInfo, callback, silently) {
    //TAS.debug("at PFSpellCasterClasses.updateConcentration");
    SWUtils.updateRowTotal(["Concentration-" + classidx, "spellclass-" + classidx + "-level-total", "Concentration-" + classidx + "-mod", "Concentration-" + classidx + "-misc"], 0, null, false, callback, silently);
}
/*********************************** SPELLS PER DAY section *************************************/
/** updateSaveDCs - update save DCs on left  column of Spells Per Day grid
*@param {int} classidx 0,1,2 the spellclass
*@param {eventinfo} eventInfo unused eventinfo from 'on' method
*@param {function} callback - to call when done.
*@param {bool} silently if true update with PFConst.silentParams
*/
function updateSaveDCs(classidx, eventInfo, callback, silently) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    getAttrs(["use_spells", "spellclass-" + classidx + "-exists", "Concentration-" + classidx + "-mod", "spellclass-" + classidx + "-level-0-savedc"], function (v) {
        var mod = parseInt(v["Concentration-" + classidx + "-mod"], 10) || 0,
            dcLvlZero = 10 + mod,
            currDC = parseInt(v["spellclass-" + classidx + "-level-0-savedc"], 10),
            setter = {},
            params = {},
            i;
        try {
            //if 0 is different then rest are different. if 0 is same, rest are same.
            if (currDC !== dcLvlZero || isNaN(currDC)) {
                setter["spellclass-" + classidx + "-level-0-savedc"] = dcLvlZero;
                for (i = 1; i < 10; i++) {
                    setter["spellclass-" + classidx + "-level-" + i + "-savedc"] = dcLvlZero + i;
                }
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpellCasterClasses.updateSaveDCs", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                setAttrs(setter, params, done);
            } else {
                done();
            }
        }
    });
}
/** updateBonusSpells - updates Bonus Spells for the class
* Uses attribute, not the attribute-mod. So it does not change with ability damage or penalties.
*@param {number} classidx 0,1,2 the spellclass
*@param {eventinfo} eventInfo unused eventinfo from 'on' method
*@param {function} callback - to call when done.
*@param {bool} silently if true update with PFConst.silentParams
*/
function updateBonusSpells(classidx, eventInfo, callback, silently) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    }),
        conAbility = "Concentration-" + classidx + "-ability";
    getAttrs([conAbility, "INT", "WIS", "CHA", "STR", "DEX", "CON"], function (v) {
        //eliminate the modifier, we just want @{INT} not @{INT-mod}
        var abilityName = PFUtils.findAbilityInString(v[conAbility]).replace("-mod", ""),
            abilityVal = parseInt(v[abilityName], 10),
            setter = {},
            params = {
            silent: true
        },
            bonusSpells,
            bonusName,
            i,
            prefix = "spellclass-" + classidx + "-level-";
        try {
            if (!isNaN(abilityVal)) {
                if (abilityVal >= 12) {
                    for (i = 1; i < 10; i++) {
                        bonusSpells = Math.floor(Math.max(Math.floor((abilityVal - 10) / 2) + 4 - i, 0) / 4);
                        bonusName = prefix + i + "-bonus";
                        setter[bonusName] = bonusSpells;
                    }
                } else {
                    for (i = 1; i < 10; i++) {
                        bonusName = prefix + i + "-bonus";
                        setter[bonusName] = 0;
                    }
                }
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpellCasterClasses.updateBonusSpells", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                setAttrs(setter, params, done);
            } else {
                done();
            }
        }
    });
}
/** updates max spells per day for a given class. ALWAYS SILENT
 * 
 * @param {*} classidx 
 * @param {*} spelllvl 
 * @param {*} callback 
 * @param {*} silently 
 */
function updateMaxSpellsPerDay(classidx, spelllvl, callback, silently) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    getAttrs(["spellclass-" + classidx + "-level-" + spelllvl + "-spells-per-day_max", "spellclass-" + classidx + "-level-" + spelllvl + "-class", "spellclass-" + classidx + "-level-" + spelllvl + "-bonus", "spellclass-" + classidx + "-level-" + spelllvl + "-misc"], function (v) {
        var newCount = 0,
            base = 0,
            rest = 0,
            total = 0,
            curr = 0,
            setter = {};
        base = parseInt(v["spellclass-" + classidx + "-level-" + spelllvl + "-class"], 10);
        curr = parseInt(v["spellclass-" + classidx + "-level-" + spelllvl + "-spells-per-day_max"], 10) || 0;
        if (isNaN(base)) {
            newCount = 0;
        } else {
            rest = (parseInt(v["spellclass-" + classidx + "-level-" + spelllvl + "-bonus"], 10) || 0) + (parseInt(v["spellclass-" + classidx + "-level-" + spelllvl + "-misc"], 10) || 0);
            newCount = base + rest;
        }
        if (newCount !== curr) {
            setter["spellclass-" + classidx + "-level-" + spelllvl + "-spells-per-day_max"] = newCount;
            setAttrs(setter, _PFConst2.default.silentParams, done);
        } else {
            done();
        }
    });
    //SWUtils.updateRowTotal(["spellclass-" + classidx + "-level-" + spelllvl + "-spells-per-day_max", "spellclass-" + classidx + "-level-" + spelllvl + "-class", "spellclass-" + classidx + "-level-" + spelllvl + "-bonus", "spellclass-" + classidx + "-level-" + spelllvl + "-misc"], 0, [], false, callback, silently);
}
/**  applyConditions - for condition deafened update {SpellFailureNote} on DEFENSE PAGE
* note drain should have already been applied
*@param {function} callback - to call when done.
*@param {bool} silently if true update with PFConst.silentParams
*/
function applyConditions(callback, silently) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    //TAS.debug("at PFSpellCasterClasses.applyConditions");
    getAttrs(["condition-Deafened", "SpellFailureNote"], function (v) {
        var setter = {},
            params = {};
        try {
            if (parseInt(v["condition-Deafened"], 10) === 4) {
                if (!v["SpellFailureNote"]) {
                    setter["SpellFailureNote"] = "Yes";
                }
            } else {
                if (v["SpellFailureNote"]) {
                    setter["SpellFailureNote"] = "";
                }
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpellCasterClasses.applyConditions", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                setAttrs(setter, params, done);
            } else {
                done();
            }
        }
    });
}
function recalcOneClass(spellClassIdx, callback, silently) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSpells.recalculate.recalcOneClass");
        if (typeof callback === "function") {
            callback();
        }
    }),
        doneOne = _underscore2.default.after(5, done),
        doneOneLevel = _underscore2.default.after(10, doneOne);

    //TAS.debug("at PFSpellCasterClasses.recalcOneClass");
    _underscore2.default.times(10, function (spelllvl) {
        updateMaxSpellsPerDay(spellClassIdx, spelllvl, doneOneLevel, silently);
    });

    updateConcentration(spellClassIdx, null, doneOne, silently);
    updateSaveDCs(spellClassIdx, null, doneOne, silently);
    updateCasterRanges(spellClassIdx, null, true, doneOne, silently);
    updateBonusSpells(spellClassIdx, null, doneOne, silently);
}
/** updates {spellclass-X-level-total}, sets minimum of 1 if {spellclass-X-level} is > 0
 *@param {int} spellclassidx 0,1,2 the spell casting tab
 *@param {eventInfo} eventInfo unused eventinfo from 'on' method
 *@param {int} classlevel optional override for class level, use this if you know it and sheet attribute might not be updated yet.
 *@param {function} callback - to call when done.
 *@param {bool} silently if true update with PFConst.silentParams
 */
function updateCasterLevel(spellclassidx, eventInfo, classlevel, callback, silently, forceRecalc) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving updateCasterLevel " + spellclassidx);
        if (typeof callback === "function") {
            callback();
        }
    });
    getAttrs(["use_spells", "spellclass-" + spellclassidx + "-level", "spellclass-" + spellclassidx + "-level-total", "spellclass-" + spellclassidx + "-level-misc", "buff_CasterLevel-total", "CasterLevel-Penalty", "spellclass-" + spellclassidx + "-exists"], function (v) {
        var baseLevel = classlevel || parseInt(v["spellclass-" + spellclassidx + "-level"], 10) || 0,
            totalLevel = parseInt(v["spellclass-" + spellclassidx + "-level-total"], 10) || 0,
            spellClassExists = parseInt(v["spellclass-" + spellclassidx + "-exists"], 10) || 0,
            usesSpells = parseInt(v["use_spells"], 10) || 0,
            casterlevel = 0,
            setter = {},
            recalcAfter = 0,
            params = {};
        try {
            if (usesSpells) {
                casterlevel = baseLevel + (parseInt(v["spellclass-" + spellclassidx + "-level-misc"], 10) || 0) + (parseInt(v["buff_CasterLevel-total"], 10) || 0) + (parseInt(v["CasterLevel-Penalty"], 10) || 0);
                //if has spells then minimum level is 1 no matter what minuses apply
                if (casterlevel <= 0) {
                    if (baseLevel > 0) {
                        casterlevel = 1;
                    } else {
                        casterlevel = 0;
                    }
                }
                if (casterlevel !== totalLevel) {
                    setter["spellclass-" + spellclassidx + "-level-total"] = casterlevel;
                    if (baseLevel > 0) {
                        recalcAfter = 1;
                    }
                }
                if (baseLevel > 0) {
                    if (spellClassExists === 0) {
                        setter["spellclass-" + spellclassidx + "-exists"] = 1;
                        recalcAfter = 1;
                    }
                    if (forceRecalc) {
                        recalcAfter = 1;
                    }
                } else if (spellClassExists === 1) {
                    setter["spellclass-" + spellclassidx + "-exists"] = 0;
                }
            } else if (spellClassExists === 1) {
                setter["spellclass-" + spellclassidx + "-exists"] = 0;
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpellCasterClasses.updateCasterLevel", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                setAttrs(setter, params, function () {
                    if (recalcAfter) {
                        recalcOneClass(spellclassidx, done, silently);
                    } else {
                        done();
                    }
                });
            } else {
                done();
            }
        }
    });
}
/** updates all 3 caster class levels, usually due to change in buffs or debuffs 
*@param {nothing} dummy - only here so eventhandlers can call it, since spellclass index is in this position.
*@param {eventinfo} eventInfo unused eventinfo from 'on' method
*@param {function} callback - to call when done.
*@param {bool} silently if true update with PFConst.silentParams
*/
function updateCasterLevels(dummy, eventInfo, callback, silently) {
    updateCasterLevel(0, eventInfo, 0, callback, silently);
    updateCasterLevel(1, eventInfo, 0, callback, silently);
    updateCasterLevel(2, eventInfo, 0, callback, silently);
}
/** sets {spellclass-X-name} and {spellclass-X-level} from the class dropdown {spellclass-X}
* called when the class dropdown is changed.
*@param {int} spellclassidx 0,1,2 the spell casting tab
*@param {eventinfo} eventInfo unused eventinfo from 'on' method
*@param {function} callback - to call when done.
*@param {bool} silently if true update with PFConst.silentParams
*/
function setCasterClassFromDropdown(spellclassidx, eventInfo, callback, silently) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    }),
        spellclassdropdown = "spellclass-" + spellclassidx,
        spellclasslevel = "spellclass-" + spellclassidx + "-level";
    getAttrs([spellclassdropdown, spellclasslevel], function (va) {
        var classidx = parseInt(va[spellclassdropdown], 10),
            currClassLevel = parseInt(va[spellclasslevel], 10),
            spellclassname,
            classname,
            classlevel;
        try {
            if (isNaN(classidx) || !va[spellclassdropdown] || parseInt(va[spellclassdropdown], 10) === -1) {
                done();
                return;
            }
            spellclassname = "spellclass-" + spellclassidx + "-name";
            classname = "class-" + classidx + "-name";
            classlevel = "class-" + classidx + "-level";
            //if race indicated: use race and HD
            if (classidx === 6) {
                classname = "race";
                classlevel = "npc-hd-num";
            }
            getAttrs([classname, classlevel, spellclassname], function (v) {
                var setter = {},
                    setAny = 0,
                    updateLevel = 0,
                    newClassLevel = parseInt(v[classlevel], 10) || 0;
                try {
                    if (currClassLevel !== newClassLevel || isNaN(currClassLevel)) {
                        setter[spellclasslevel] = newClassLevel;
                        updateLevel = 1;
                    }
                    if (v[classname] && v[classname] !== v[spellclassname]) {
                        setter[spellclassname] = v[classname];
                    }
                } catch (err) {
                    _exportsLoaderTASTheAaronSheet2.default.error("PFSpellCasterClasses.setCasterClassFromDropdown", err);
                } finally {
                    if (_underscore2.default.size(setter) > 0) {
                        setAttrs(setter, {
                            silent: true
                        }, done);
                        if (updateLevel) {
                            updateCasterLevel(spellclassidx, eventInfo, newClassLevel);
                        }
                    } else {
                        done();
                    }
                }
            });
        } catch (errOuter) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpellCasterClasses.setCasterClassFromDropdown outer", errOuter);
            done();
        }
    });
}
/** update level on SPELL page when updated on CLASS page, but not vice versa
*@param {int} classidx 0..6 the row on the CLASS GRID starting with 0 to grab level from, or 6 if {npc-hd-num}
*@param {eventinfo} eventInfo unused eventinfo from 'on' method
*@param {bool} force if true update no matter if new ranges are same or not.
*@param {function} callback - to call when done.
*@param {bool} silently if true update with PFConst.silentParams
*/
function updateCasterFromClassLevel(classidx, eventInfo, force, callback, silently) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    }),
        spellclassdropdown0 = "spellclass-0",
        spellclassdropdown1 = "spellclass-1",
        spellclassdropdown2 = "spellclass-2";
    if (classidx === "npc-hd-num") {
        classidx = 6;
    } else {
        classidx = parseInt(classidx, 10) || 0;
    }
    getAttrs([spellclassdropdown0, spellclassdropdown1, spellclassdropdown2], function (va) {
        var spellclassidx, spellclasslevelField, classlevelField, prefix, classNameField;
        if (parseInt(va[spellclassdropdown0], 10) === classidx) {
            spellclassidx = 0;
        } else if (parseInt(va[spellclassdropdown1], 10) === classidx) {
            spellclassidx = 1;
        } else if (parseInt(va[spellclassdropdown2], 10) === classidx) {
            spellclassidx = 2;
        } else {
            return;
        }
        prefix = "spellclass-" + spellclassidx;
        spellclasslevelField = prefix + "-level";
        classlevelField = "class-" + classidx + "-level";
        classNameField = "class-" + classidx + "-name";
        getAttrs([spellclasslevelField, classlevelField, classNameField], function (v) {
            var setter = {},
                newCasterLevel = parseInt(v[classlevelField], 10) || 0,
                currCasterLevel = parseInt(v[spellclasslevelField], 10);
            if (newCasterLevel !== currCasterLevel || isNaN(currCasterLevel) || force) {
                setter[spellclasslevelField] = newCasterLevel;
                setter[prefix + "-name"] = v[classNameField];
                setAttrs(setter, {
                    silent: true
                });
                updateCasterLevel(classidx, eventInfo, newCasterLevel);
            }
        });
    });
}
function migrate(callback, oldversion) {
    //TAS.debug("At PFSpellCasterClasses.migrate");
    PFMigrate.migrateUsesSpellFlag(callback);
}
function recalculate(callback, silently, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.info("leaving PFSpellCasterClasses.recalculate");
        if (typeof callback === "function") {
            callback();
        }
    }),
        recalcTopSection = function recalcTopSection(callback, silently) {
        var done = _underscore2.default.once(function () {
            _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSpellCasterClasses.recalculate.recalcTopSection");
            if (typeof callback === "function") {
                callback();
            }
        }),
            doneOne = _underscore2.default.after(3, done);
        //TAS.debug("at PFSpellCasterClasses.recalculate.recalcTopSection");
        _underscore2.default.each(_PFConst2.default.spellClassIndexes, function (spellClassIdx) {
            try {
                setCasterClassFromDropdown(spellClassIdx, null, function () {
                    updateCasterLevel(spellClassIdx, null, 0, doneOne, silently, true);
                    //updateCasterLevel(spellClassIdx, null, 0,function () {
                    //    ifSpellClassExists(spellClassIdx, function () {
                    //        recalcOneClass(spellClassIdx,doneOne,silently);
                    //    }, doneOne);
                    //}, silently);
                }, silently);
            } catch (err) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFSpellCasterClasses.recalculate_recalcTopSection", err);
                doneOne();
            }
        });
    },
        finishAndLeave = _underscore2.default.once(function () {
        updateMultiClassedCasterFlag(null, null, function () {
            PFSpells.recalculate(done, silently, oldversion);
        });
    }),
        callTopSection = _underscore2.default.once(function () {
        recalcTopSection(finishAndLeave, silently);
    }),
        callApplyConditions = _underscore2.default.once(function () {
        applyConditions(callTopSection, silently);
    });
    migrate(function () {
        callApplyConditions();
    }, oldversion);
}
var events = {
    // events for updates to top of class page, each one calls isSpellClassExists
    spellcastingClassEventsAuto: {
        "change:concentration-REPLACE-mod": [updateBonusSpells, updateSaveDCs, updateConcentration, PFSpells.updateSpellsCasterAbilityRelated],
        "change:spellclass-REPLACE-level-total": [updateConcentration, updateCasterRanges, PFSpells.updateSpellsCasterLevelRelated],
        "change:spellclass-REPLACE-SP-mod": [PFSpells.updateSpellsCasterLevelRelated]
    },
    spellcastingClassEventsPlayer: {
        "change:concentration-REPLACE-misc": [updateConcentration, PFSpells.updateSpellsCasterLevelRelated],
        "change:concentration-REPLACE-def": [PFSpells.updateSpellsCasterLevelRelated]
    },
    // events for updates to top of class page even if no spellcasting class exists
    spellcastingClassEventsIgnoreLevel: {
        "change:spellclass-REPLACE-level-misc": [updateCasterLevel],
        "change:spellclass-REPLACE": [setCasterClassFromDropdown],
        "change:spellclass-REPLACE-level": [updateCasterLevel, updateMultiClassedCasterFlag],
        "change:buff_CasterLevel-total change:condition-Drained change:CasterLevel-Penalty": [updateCasterLevels]
    },
    //events for updateBonusSpells section CLASSIDX is the 0-2 classes, SPELLLEVEL is 0-9
    spellcastingClassEventsPerSpellLevel: "change:spellclass-CLASSIDX-level-SPELLLEVEL-class change:spellclass-CLASSIDX-level-SPELLLEVEL-bonus change:spellclass-CLASSIDX-level-SPELLLEVEL-misc"
};
function registerEventHandlers() {
    //spellclass section (3 tabs at top of spell page)
    _underscore2.default.each(_PFConst2.default.spellClassIndexes, function (spellClassIdx) {
        var numberIdx = parseInt(spellClassIdx, 10) || 0;
        on("change:Concentration-" + numberIdx + "-ability", _exportsLoaderTASTheAaronSheet2.default.callback(function eventChangeSpellDropdown(eventInfo) {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            PFUtilsAsync.setDropdownValue("Concentration-" + numberIdx + "-ability", "Concentration-" + numberIdx + "-mod");
        }));
        _underscore2.default.each(events.spellcastingClassEventsPlayer, function (functions, event) {
            var eventToWatch = event.replace(/REPLACE/g, numberIdx);
            _underscore2.default.each(functions, function (methodToCall) {
                on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventSpellcasterClassSpecificUpdatePlayerOnly(eventInfo) {
                    if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                        ifSpellClassExists(numberIdx, function () {
                            methodToCall(numberIdx, eventInfo);
                        });
                    }
                }));
            });
        });
        _underscore2.default.each(events.spellcastingClassEventsAuto, function (functions, event) {
            var eventToWatch = event.replace(/REPLACE/g, numberIdx);
            _underscore2.default.each(functions, function (methodToCall) {
                on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventSpellcasterClassSpecificUpdateAuto(eventInfo) {
                    if (eventInfo.sourceType === "sheetworker") {
                        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                        ifSpellClassExists(numberIdx, function () {
                            methodToCall(numberIdx, eventInfo);
                        });
                    }
                }));
            });
        });
        //ignore level means do not call "ifSpellClassExists" first
        _underscore2.default.each(events.spellcastingClassEventsIgnoreLevel, function (functions, event) {
            var eventToWatch = event.replace(/REPLACE/g, numberIdx);
            _underscore2.default.each(functions, function (methodToCall) {
                on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventSpellcasterClassUpdate(eventInfo) {
                    _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                    methodToCall(numberIdx, eventInfo);
                }));
            });
        });
        //spells per day
        _underscore2.default.each(PFSpells.spellLevels, function (spellLevel) {
            var spellNumber = parseInt(spellLevel, 10),
                eventToWatch = events.spellcastingClassEventsPerSpellLevel.replace(/CLASSIDX/g, numberIdx).replace(/SPELLLEVEL/g, spellNumber);
            on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventSpellsPerDay(eventInfo) {
                _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                ifSpellClassExists(numberIdx, function () {
                    updateMaxSpellsPerDay(numberIdx, spellNumber);
                });
            }));
        });
    }); //end of spell classes
}
registerEventHandlers();
_PFLog.PFConsole.log('PFSpellCasterClasses module loaded');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

var _PFDefense = __webpack_require__(13);

var PFDefense = _interopRequireWildcard(_PFDefense);

var _PFSize = __webpack_require__(15);

var PFSize = _interopRequireWildcard(_PFSize);

var _PFUtilsAsync = __webpack_require__(9);

var PFUtilsAsync = _interopRequireWildcard(_PFUtilsAsync);

var _PFInitiative = __webpack_require__(22);

var PFInitiative = _interopRequireWildcard(_PFInitiative);

var _PFSkills = __webpack_require__(16);

var PFSkills = _interopRequireWildcard(_PFSkills);

var _PFEncumbrance = __webpack_require__(20);

var PFEncumbrance = _interopRequireWildcard(_PFEncumbrance);

var _PFInventory = __webpack_require__(30);

var PFInventory = _interopRequireWildcard(_PFInventory);

var _PFAbilityScores = __webpack_require__(11);

var PFAbilityScores = _interopRequireWildcard(_PFAbilityScores);

var _PFBuffs = __webpack_require__(26);

var PFBuffs = _interopRequireWildcard(_PFBuffs);

var _PFSaves = __webpack_require__(23);

var PFSaves = _interopRequireWildcard(_PFSaves);

var _PFHealth = __webpack_require__(21);

var PFHealth = _interopRequireWildcard(_PFHealth);

var _PFChecks = __webpack_require__(19);

var PFChecks = _interopRequireWildcard(_PFChecks);

var _PFAbility = __webpack_require__(18);

var PFAbility = _interopRequireWildcard(_PFAbility);

var _PFNPC = __webpack_require__(36);

var PFNPC = _interopRequireWildcard(_PFNPC);

var _PFAttackGrid = __webpack_require__(7);

var PFAttackGrid = _interopRequireWildcard(_PFAttackGrid);

var _PFAttackOptions = __webpack_require__(12);

var PFAttackOptions = _interopRequireWildcard(_PFAttackOptions);

var _PFAttacks = __webpack_require__(8);

var PFAttacks = _interopRequireWildcard(_PFAttacks);

var _PFFeatures = __webpack_require__(29);

var PFFeatures = _interopRequireWildcard(_PFFeatures);

var _PFSpells = __webpack_require__(17);

var PFSpells = _interopRequireWildcard(_PFSpells);

var _PFSpellCasterClasses = __webpack_require__(24);

var PFSpellCasterClasses = _interopRequireWildcard(_PFSpellCasterClasses);

var _PFPsionic = __webpack_require__(38);

var PFPsionic = _interopRequireWildcard(_PFPsionic);

var _PFMythic = __webpack_require__(35);

var PFMythic = _interopRequireWildcard(_PFMythic);

var _PFClassRaceGrid = __webpack_require__(27);

var PFClassRaceGrid = _interopRequireWildcard(_PFClassRaceGrid);

var _PFConditions = __webpack_require__(33);

var PFConditions = _interopRequireWildcard(_PFConditions);

var _PFNPCParser = __webpack_require__(37);

var PFNPCParser = _interopRequireWildcard(_PFNPCParser);

var _PFHorror = __webpack_require__(34);

var PFHorror = _interopRequireWildcard(_PFHorror);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function expandAll() {
	getAttrs(["expandall"], function (v) {
		var skilltab = "4",
		    setter = {};
		if (parseInt(v["expandall"], 10)) {
			//set expandall to 0
			//set tabs to "all"
			//set conditions and buffs to "show"
			//set all others to default (which is "show")
			setAttrs({
				"expandall": "0",
				pagetab: "99",
				abilities_tab: "99",
				skills_tab: "99",
				spellclass_tab: "99",
				spells_tab: "99",
				npc_spellclass_tab: "99",
				equipment_tab: "99",
				'sheet-conditions-show': 0,
				'buffstop-show': 0,
				'command-buttons-show': 0,
				'NPC-command-buttons-show': 0,
				'character-details-show': 0,
				'ability-scores-show': 0,
				'class-info-show': 0,
				'class1_show': 0,
				'class2_show': 0,
				'class3_show': 0,
				'health-and-wounds-show': 0,
				'initiative-show': 0,
				'macro-text-show': 0,
				'notes-show': 0,
				'saves-show': 0,
				'extra_fields_saves_show': 1,
				'extra_fields_spells_show': 1,
				'extra_fields_caster_show': 1,
				'defense-values-show': 0,
				'armor-shield-show': 0,
				'sanity-show': 0,
				'defense-notes-show': 0,
				'attack-bonuses-show': 0,
				'atkm2_show': 0,
				'attack-notes-show': 0,
				'attack-options-show': 0,
				'two-weapon-show': 0,
				'attacks-show': 0,
				'skill-ranks-show': 0,
				'skill_options-show': 0,
				'skills-show': 0,
				'artistry-show': 0,
				'craft-show': 0,
				'knowledge-show': 0,
				'lore-show': 0,
				'perform-show': 0,
				'profession-show': 0,
				'misc-show': 0,
				'skill-notes-show': 0,
				'ability-command-buttons-show': 0,
				'NPC-ability-command-buttons-show': 0,
				'feats-show': 0,
				'mythic-info-show': 0,
				'psionic-info-show': 0,
				'abilities-show': 0,
				'spellclasses-show': 0,
				'spellclass-0-show': 0,
				'spellclass-0-spellpoints-show': 0,
				'spellclass-0-spells-notes-show': 0,
				'spellclass-0-perday-show': 0,
				'spellclass-0-domains-show': 0,
				'domain02_show': 0,
				'domain03_show': 0,
				'spellclass-1-show': 0,
				'spellclass-1-spellpoints-show': 0,
				'spellclass-1-spells-notes-show': 0,
				'spellclass-1-perday-show': 0,
				'spellclass-1-domains-show': 0,
				'spellclass-2-show': 0,
				'spellclass-2-spellpoints-show': 0,
				'spellclass-2-spells-notes-show': 0,
				'spellclass-2-perday-show': 0,
				'spellclass-2-domains-show': 0,
				'spelloptions-show': 0,
				'spell-lists-show': 0,
				'currency-show': 0,
				'carried-weight-show': 0,
				'loads-show': 0,
				'worn-items-show': 0,
				'other-items-show': 0,
				'equipment-show': 0,
				'npc-compimport-show': 0,
				'npc-details-show': 0,
				'npc-defense-show': 0,
				'npc-offense-show': 0,
				'npc-speed-show': 0,
				'npc-repeating-weapons-show': 0,
				'npc-spell-like-abilities-show': 0,
				'npc-tactics-show': 0,
				'npc-statistics-show': 0,
				'npc-feats-show': 0,
				'npc-mythic-feats-show': 0,
				'npc-skills-show': 0,
				'npc-ecology-show': 0,
				'npc-special-abilities-show': 0,
				'custom-attr-sect-a-show': 0,
				'custom-attr-sect-c-show': 0,
				'custom-attr-sect-b-show': 0,
				'custom-attr-sect-d-show': 0,
				'custom-attr-sect-n-show': 0,
				'header-image-show': 0,
				'sheet-import-show': 0,
				'roll-template-info-show': 1,
				'macros-show': 1,
				'migrations-show': 0,
				'cleanup-show': 0,
				'buff-min-show': 0,
				'buff-expand-show': 0,
				'buff-column-show': 0,
				'weapon-min-show': 0,
				'weapon-expand-show': 0,
				'weapon-column-show': 0,
				'abilities-min-show': 0,
				'abilities-expand-show': 0,
				'abilities-column-show': 0,
				'class-ability-min-show': 0,
				'class-ability-expand-show': 0,
				'class-ability-column-show': 0,
				'feat-min-show': 0,
				'feat-expand-show': 0,
				'feat-column-show': 0,
				'mythic-feats-min-show': 0,
				'mythic-feats-expand-show': 0,
				'mythic-feats-column-show': 0,
				'racial-trait-min-show': 0,
				'racial-trait-expand-show': 0,
				'racial-trait-column-show': 0,
				'traits-min-show': 0,
				'traits-expand-show': 0,
				'traits-column-show': 0,
				'npc-spell-like-abilities-min-show': 0,
				'npc-spell-like-abilities-expand-show': 0,
				'npc-spell-like-abilities-column-show': 0,
				'mythic-min-show': 0,
				'mythic-expand-show': 0,
				'mythic-column-show': 0,
				'newspells-min-show': 0,
				'newspells-expand-show': 0,
				'newspells-column-show': 0,
				'item-min-show': 0,
				'item-expand-show': 0,
				'item-column-show': 0,
				'npcweapon-min-show': 0,
				'npcweapon-expand-show': 0,
				'npcweapon-column-show': 0,
				'npcnewspells-min-show': 0,
				'npcnewspells-expand-show': 0,
				'npcnewspells-column-show': 0,
				'npcfeat-min-show': 0,
				'npcfeat-expand-show': 0,
				'npcfeat-column-show': 0,
				'npcmythic-feats-min-show': 0,
				'npcmythic-feats-expand-show': 0,
				'npcmythic-feats-column-show': 0,
				'npc-abilities-min-show': 0,
				'npc-abilities-expand-show': 0,
				'npc-abilities-column-show': 0,
				'npc-special-abilities-min-show': 0,
				'npc-special-abilities-expand-show': 0,
				'npc-special-abilities-column-show': 0
			});
			//now go through repeating sections and expand those to be sure users can see them.
			_underscore2.default.each(_PFConst2.default.repeatingSections, function (section) {
				var rsection = "repeating_" + section;
				getSectionIDs(rsection, function (ids) {
					var setter = _underscore2.default.reduce(ids, function (memo, id) {
						var prefix = rsection + "_" + id + "_";
						switch (section) {
							case 'weapon':
								memo[prefix + "add-damage-show"] = 0;
								memo[prefix + "iterative-attacks-show"] = 0;
								memo[prefix + "advmacro-text-show"] = 0;
								break;
							case 'buff':
								memo[prefix + "options-show"] = 0;
								memo[prefix + "description-show"] = 0;
								break;
							case 'spells':
								memo[prefix + "spell-misc-show"] = 0;
								memo[prefix + "description-show"] = 0;
								break;
							case 'class-ability':
							case 'feat':
							case 'racial-trait':
							case 'trait':
							case 'mythic-ability':
							case 'mythic-feat':
							case 'item':
								memo[prefix + "description-show"] = 0;
								memo[prefix + "armor-attributes-show"] = 0;
								memo[prefix + "weapon-attributes-show"] = 0;
								break;
							case 'npc-spell-like-abilities':
								memo[prefix + "attack-show"] = 0;
								break;
							case 'ability':
								memo[prefix + "options-show"] = 0;
								memo[prefix + "description-show"] = 0;
								memo[prefix + "misc-show"] = 0;
								memo[prefix + "showextrafields"] = 0;
								memo[prefix + "range-show"] = 0;
								break;
						}
						memo[prefix + "row-show"] = 0;
						memo[prefix + "ids-show"] = 0;
						if (section !== 'buff') {
							memo[prefix + "macro-text-show"] = 0;
						}
						return memo;
					}, {});
					setAttrs(setter, {
						silent: true
					});
				});
			});
		}
	});
}

/** Sets any values if sheet created brand new. Makes sure all migrations up to date.
* makes sure NPC value set. 
*/

//import * as PFMacros from './PFMacros';
//import * as PFMenus from './PFMenus';
function setupNewSheet(callback) {
	var done = _underscore2.default.once(function () {
		setAttrs({ 'is_newsheet': 0, 'is_v1': 1, 'use_advanced_options': 0, 'PFSheet_Version': String(_PFConst2.default.version.toFixed(2)),
			'attentionv156-show': 1 }, _PFConst2.default.silentParams, function () {
			if (typeof callback === "function") {
				callback();
			}
		});
	});

	getAttrs(['is_npc', 'set_pfs'], function (v) {
		var isNPC = parseInt(v.is_npc, 10) || 0,
		    isPFS = parseInt(v.set_pfs, 10) || 0;
		PFMigrate.setAllMigrateFlags(function () {
			if (isNPC) {
				PFNPC.setToNPC(done);
			} else if (isPFS) {
				PFHealth.setToPFS(done);
			} else {
				done();
			}
		});
	});
}
function recalcExpressions(callback, silently, oldversion) {
	var countEqs = _underscore2.default.size(_PFConst2.default.equationMacros),
	    done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSheet.recalcExpressions");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    doneOne = _underscore2.default.after(countEqs, done);
	try {
		_underscore2.default.each(_PFConst2.default.equationMacros, function (writeField, readField) {
			try {
				SWUtils.evaluateAndSetNumber(readField, writeField, 0, doneOne, silently);
			} catch (err) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFSheet.recalcExpressions", err);
				doneOne();
			}
		});
	} catch (err2) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFSheet.recalcExpressions OUTER wtf how did this happen?", err2);
	} finally {
		done();
	}
}
function recalcDropdowns(callback, silently, oldversion) {
	var countEqs = _underscore2.default.size(_PFConst2.default.dropdowns),
	    done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	}),
	    doneOne = _underscore2.default.after(countEqs, done);
	try {
		_underscore2.default.each(_PFConst2.default.dropdowns, function (writeField, readField) {
			try {
				PFUtilsAsync.setDropdownValue(readField, writeField, doneOne, silently);
			} catch (err) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFSheet.recalcDropdowns", err);
				doneOne();
			}
		});
	} catch (err2) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFSheet.recalcDropdowns OUTER wtf how did this happen?", err2);
	} finally {
		done();
	}
}
function migrate(oldversion, callback, errorCallback) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSheet.migrate");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    errorDone = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.warn("leaving migrate ERROR UPGRADE NOT FINISHED");
		if (typeof errorCallback === "function") {
			errorCallback();
		} else {
			done();
		}
	}),
	    doneOne;
	try {
		//don't need to check if oldversion > 0 since this is only called if it is.
		_exportsLoaderTASTheAaronSheet2.default.debug("At PFSheet.migrate from oldversion:" + oldversion);
		if (oldversion < 1.0) {
			doneOne = _underscore2.default.after(7, function () {
				_exportsLoaderTASTheAaronSheet2.default.info("we finished calling all the migrates");
				done();
			});
			PFMigrate.migrateConfigFlags(_exportsLoaderTASTheAaronSheet2.default.callback(function () {
				PFInventory.migrate(doneOne, oldversion);
				PFSkills.migrate(doneOne, oldversion);
				PFHealth.migrate(doneOne, oldversion);
				PFAttacks.migrate(doneOne, oldversion);
				PFAbility.migrate(doneOne, oldversion);
				PFFeatures.migrate(doneOne, oldversion);
				PFSpells.migrate(doneOne, oldversion);
			}), oldversion);
		} else if (oldversion < 1.17) {
			if (oldversion < 1.02) {
				PFAbility.migrate(null, oldversion);
				PFFeatures.migrate(null, oldversion);
			}
			if (oldversion < 1.05) {
				PFAttackOptions.resetOptions();
			}
			if (oldversion < 1.07) {
				PFInventory.migrate(null, oldversion);
			}
			if (oldversion < 1.10) {
				PFMigrate.migrateAbilityListFlags();
				PFFeatures.migrate(null, oldversion);
			}
			if (oldversion < 1.12) {
				PFAbility.migrate(null, oldversion);
			}
			if (oldversion < 1.17) {
				PFInventory.migrate(function () {
					PFInventory.resetCommandMacro();
				});
			}
		} else {
			if (oldversion < 1.18) {
				//future updates here. any above will recalc whole sheet after callback
				PFInitiative.recalculate(null, false, oldversion);
				PFHealth.recalculate(null, false, oldversion);
				PFMigrate.migrateSpellPointFlag(null, oldversion);
			}
			if (oldversion < 1.19) {
				PFAttackGrid.setTopMacros();
			}
			if (oldversion < 1.20) {
				PFHealth.recalculate();
			}
			if (oldversion < 1.40) {
				PFMigrate.migrateWhisperDropdowns();
				PFInventory.resetCommandMacro();
				PFAttackGrid.resetCommandMacro();
				PFAbility.resetCommandMacro();
				PFFeatures.resetCommandMacro();
				PFAttacks.recalculate();
				PFClassRaceGrid.setHitPoints();
			}
			if (oldversion < 1.43) {
				PFSpells.recalculate();
				PFSkills.resetCommandMacro();
			}
			if (oldversion < 1.5) {
				PFSpells.resetSpellsTotals(null, null, null, true);
				PFInventory.updateRepeatingItems();
				PFAttacks.migrateLinkedAttacks(null, oldversion);
			}
			if (oldversion < 1.53) {
				PFSkills.migrate(null, oldversion);
				PFSize.recalculate(function () {
					PFEncumbrance.migrate();
				});
			}
			if (oldversion < 1.54) {
				PFBuffs.recalculate();
			}
			if (oldversion < 1.55) {
				PFAttacks.recalculate();
				PFSkills.migrate();
			}
			if (oldversion < 1.56) {
				PFAttacks.updateRepeatingWeaponDamages();
			}
			if (oldversion < 1.57) {
				PFDefense.updateDefenses();
			}
			if (oldversion < 1.58) {
				PFAttacks.adjustAllDamageDiceAsync();
			}
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFSheet.migrate", err);
		errorDone();
	} finally {
		done();
	}
}
function recalculateParallelModules(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSheet.recalculateParallelModules");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    parallelRecalcFuncs = [PFSpellCasterClasses.recalculate, PFSaves.recalculate, PFFeatures.recalculate, PFPsionic.recalculate, PFSkills.recalculate, PFAbility.recalculate, PFInitiative.recalculate, PFAttacks.recalculate, PFHorror.recalculate],
	    numberModules = _underscore2.default.size(parallelRecalcFuncs),
	    doneOneModuleInner = _underscore2.default.after(numberModules, done),
	    curr = 0,
	    currstarted = 0,
	    doneOneModule = function doneOneModule() {
		curr++;
		_exportsLoaderTASTheAaronSheet2.default.info("PFSheet.recalculateParallelModules, finished " + curr + " modules");
		doneOneModuleInner();
	};

	_exportsLoaderTASTheAaronSheet2.default.debug("at recalculateParallelModules! there are " + numberModules + " modules");
	try {
		_underscore2.default.each(parallelRecalcFuncs, function (methodToCall) {
			try {
				currstarted++;
				_exportsLoaderTASTheAaronSheet2.default.info("starting " + currstarted + " parallel modules");
				methodToCall(doneOneModule, silently, oldversion);
			} catch (err) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFSheet.recalculateParallelModules", err);
				doneOneModule();
			}
		});
	} catch (err2) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFSheet.recalculateParallelModules OUTER error!", err2);
		done();
	}
}
function recalculateDefenseAndEncumbrance(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSheet.recalculateDefenseAndEncumbrance");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    callEncumbrance = function callEncumbrance() {
		PFEncumbrance.recalculate(done, silently, oldversion);
	},
	    doneBeforeEncumbrance = _underscore2.default.after(2, callEncumbrance);
	try {
		PFInventory.recalculate(doneBeforeEncumbrance, silently, oldversion);
		PFDefense.recalculate(doneBeforeEncumbrance, silently, oldversion);
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("pfsheet.recalculateDefenseAndEncumbrance", err);
		callEncumbrance();
	}
}
function recalculateCore(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFSheet.recalculateCore");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    sizeOnce = _underscore2.default.once(function () {
		PFSize.recalculate(done, silently, oldversion);
	}),
	    healthOnce = _underscore2.default.once(function () {
		PFHealth.recalculate(sizeOnce, silently, oldversion);
	}),
	    npcOnce = _underscore2.default.once(function () {
		PFNPC.recalculate(healthOnce, silently, oldversion);
	}),
	    mythicOnce = _underscore2.default.once(function () {
		PFMythic.recalculate(npcOnce, silently, oldversion);
	}),
	    expressionsOnce = _underscore2.default.once(function () {
		recalcExpressions(mythicOnce, silently, oldversion);
	}),
	    dropdownsOnce = _underscore2.default.once(function () {
		recalcDropdowns(expressionsOnce, silently, oldversion);
	}),
	    conditioncheckOnce = _underscore2.default.once(function () {
		PFChecks.applyConditions(dropdownsOnce, silently, oldversion);
	}),
	    classOnce = _underscore2.default.once(function () {
		PFClassRaceGrid.recalculate(conditioncheckOnce, silently, oldversion);
	}),
	    abilityScoresOnce = _underscore2.default.once(function () {
		PFAbilityScores.recalculate(classOnce, silently, oldversion);
	}),
	    abilityAffectingConditionsOnce = _underscore2.default.once(function () {
		PFConditions.recalculate(abilityScoresOnce, silently, oldversion);
	}),
	    buffsOnce = _underscore2.default.once(function () {
		PFBuffs.recalculate(abilityAffectingConditionsOnce, silently, oldversion);
	});

	PFMigrate.migrateConfigFlags(buffsOnce, oldversion);

	//TAS.debug("at recalculateCore!!!!");
}
/** recalculate - all pages in sheet!  
 *@param {number} oldversion the current version attribute
 *@param {function} callback when done if no errors
 *@param {function} errorCallback  call this if we get an error
 */
function recalculate(oldversion, callback, silently) {
	var done = function done() {
		_exportsLoaderTASTheAaronSheet2.default.info("leaving PFSheet.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	},
	    callParallel = _exportsLoaderTASTheAaronSheet2.default.callback(function callRecalculateParallelModules() {
		recalculateParallelModules(_exportsLoaderTASTheAaronSheet2.default.callback(done), silently, oldversion);
	}),
	    callEncumbrance = _exportsLoaderTASTheAaronSheet2.default.callback(function callRecalculateDefenseAndEncumbrance() {
		recalculateDefenseAndEncumbrance(_exportsLoaderTASTheAaronSheet2.default.callback(callParallel), silently, oldversion);
	});
	silently = true;
	recalculateCore(callEncumbrance, silently, oldversion);
}
/* checkForUpdate looks at current version of page in PFSheet_Version and compares to code PFConst.version
*  calls recalulateSheet if versions don't match or if recalculate button was pressed.*/
function checkForUpdate() {
	var done = function done() {
		setAttrs({ recalc1: 0, migrate1: 0, is_newsheet: 0 }, _PFConst2.default.silentParams);
	},
	    errorDone = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.warn("leaving checkForUpdate ERROR UPGRADE NOT FINISHED DO NOT RESET VERSION");
		setAttrs({ recalc1: 0, migrate1: 0 }, { silent: true });
	});
	getAttrs(['PFSheet_Version', 'migrate1', 'recalc1', 'is_newsheet', 'is_v1', 'hp', 'hp_max', 'npc-hd', 'npc-hd-num', 'race', 'class-0-name', 'npc-type', 'level'], function (v) {
		var setter = {},
		    setAny = 0,
		    migrateSheet = false,
		    newSheet = false,
		    recalc = false,
		    currVer = parseFloat(v.PFSheet_Version, 10) || 0,
		    setUpgradeFinished = function setUpgradeFinished() {
			setAttrs({ recalc1: 0, migrate1: 0, is_newsheet: 0,
				character_sheet: 'Pathinder_Neceros v' + String(_PFConst2.default.version),
				PFSheet_Version: String(_PFConst2.default.version.toFixed(2)) }, _PFConst2.default.silentParams, function () {
				if (currVer < 1.17) {
					recalculate(currVer, null, false);
				}
			});
		};
		_exportsLoaderTASTheAaronSheet2.default.notice("Attributes at version: " + currVer);
		if (parseInt(v["recalc1"], 10)) {
			//HIT RECALC
			recalc = true;
		}
		if (parseInt(v["migrate1"], 10)) {
			migrateSheet = true;
		}
		if (parseInt(v["is_newsheet"], 10) || currVer === 0 && (parseInt(v.is_v1, 10) || !(parseInt(v.hp, 10) || parseInt(v.hp_max, 10) || parseInt(v['npc-hd'], 10) || parseInt(v['npc-hd-num'], 10) || v.race || v['class-0-name'] || v['npc-type'] || parseInt(v['level'], 10)))) {
			//NEW SHEET:
			newSheet = true;
		}
		//force this on sheet open, not sure wtf is wrong
		PFSkills.migrate();
		if (currVer !== _PFConst2.default.version) {
			migrateSheet = true;
		}
		if (newSheet) {
			setupNewSheet(done);
		} else if (migrateSheet) {
			migrate(currVer, setUpgradeFinished, errorDone);
		} else if (recalc) {
			currVer = -1;
			recalculate(currVer, done, true);
		} else {
			done();
		}
	});
}
function registerEventHandlers() {
	on("sheet:opened", _exportsLoaderTASTheAaronSheet2.default.callback(function eventSheetOpened() {
		//eventInfo has undefined values for this event.
		checkForUpdate();
	}));
	on("change:recalc1 change:migrate1", _exportsLoaderTASTheAaronSheet2.default.callback(function eventRecaluateSheet(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			checkForUpdate();
		}
	}));
	on("change:expandall", function (eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			expandAll();
		}
	});
	//GENERIC DROPDOWNS
	_underscore2.default.each(_PFConst2.default.dropdowns, function (write, read) {
		on("change:" + read, _exportsLoaderTASTheAaronSheet2.default.callback(function eventGenericDropdowns(eventInfo) {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			PFUtilsAsync.setDropdownValue(read, write);
		}));
	});
	//GENERIC EQUATIONS
	_underscore2.default.each(_PFConst2.default.equationMacros, function (write, read) {
		on("change:" + read, _exportsLoaderTASTheAaronSheet2.default.callback(function eventGenericEquationMacro(eventInfo) {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			SWUtils.evaluateAndSetNumber(read, write);
		}));
	});
	on("change:repeating_weapon:source-item", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateAttackSourceItem(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			getAttrs([eventInfo.sourceAttribute], function (v) {
				var weaponId = SWUtils.getRowId(eventInfo.sourceAttribute),
				    sourceId = v[eventInfo.sourceAttribute];
				//TAS.debug("PFSheet new item id: " + sourceId + " this row weapon id: "+weaponId, v);
				if (sourceId) {
					sourceId = 'repeating_item_' + sourceId + '_create-attack-entry';
					PFInventory.createAttackEntryFromRow(sourceId, null, false, weaponId);
				}
			});
		}
	}));
	on("change:repeating_weapon:source-ability", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateAttackSourceAbility(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			getAttrs([eventInfo.sourceAttribute], function (v) {
				var weaponId = SWUtils.getRowId(eventInfo.sourceAttribute),
				    sourceId = v[eventInfo.sourceAttribute];
				if (sourceId) {
					PFAbility.createAttackEntryFromRow(sourceId, null, false, null, weaponId);
				}
			});
		}
	}));
	on("change:repeating_weapon:source-spell", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateAttackSourceSpell(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			getAttrs([eventInfo.sourceAttribute], function (v) {
				var weaponId = SWUtils.getRowId(eventInfo.sourceAttribute),
				    sourceId = v[eventInfo.sourceAttribute];
				if (sourceId) {
					PFSpells.createAttackEntryFromRow(sourceId, null, false, null, weaponId);
				}
			});
		}
	}));

	// PARSE CREATE NPC MONSTER
	on("change:npc_import_now", _exportsLoaderTASTheAaronSheet2.default.callback(function eventParseMonsterImport(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			getAttrs(['npc_import_now'], function (v) {
				if ((parseInt(v.npc_import_now, 10) || 0) === 1) {
					PFNPCParser.importFromCompendium(eventInfo, function () {
						//instead of just calling recalculate set recalc button and call checkforupdate
						//so users sees something is happening.
						setAttrs({ recalc1: 1 }, _PFConst2.default.silentParams, function () {
							checkForUpdate();
						});
					});
				}
			});
		}
	}));
	on("change:delete_repeating_spells change:delete_repeating_weapon change:delete_repeating_item change:delete_repeating_ability change:delete_repeating_mythic-feat change:delete_repeating_mythic-ability change:delete_repeating_buff change:delete_repeating_trait change:delete_repeating_racial-trait change:delete_repeating_feat change:delete_repeating_class-ability change:delete_repeating_npc-spell-like-abilities", _exportsLoaderTASTheAaronSheet2.default.callback(function eventDeleteOldList(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			getAttrs([eventInfo.sourceAttribute], function (v) {
				var section = "";
				if (parseInt(v[eventInfo.sourceAttribute], 10)) {
					section = eventInfo.sourceAttribute.replace('delete_repeating_', '');
					SWUtils.deleteRepeating(function () {
						var setter;
						setter = {};
						setter[eventInfo.sourceAttribute] = 0;
						setter[eventInfo.sourceAttribute + '_btn'] = 0;
						setAttrs(setter, { silent: true });
						if (/buff/i.test(eventInfo.sourceAttribute)) {
							PFBuffs.clearBuffTotals();
						}
					}, section);
				}
			});
		}
	}));
}
registerEventHandlers();

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.migrate = migrate;
exports.createTotalBuffEntry = createTotalBuffEntry;
exports.clearBuffTotals = clearBuffTotals;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFAbilityScores = __webpack_require__(11);

var PFAbilityScores = _interopRequireWildcard(_PFAbilityScores);

var _PFSaves = __webpack_require__(23);

var PFSaves = _interopRequireWildcard(_PFSaves);

var _PFAttackGrid = __webpack_require__(7);

var PFAttackGrid = _interopRequireWildcard(_PFAttackGrid);

var _PFAttacks = __webpack_require__(8);

var PFAttacks = _interopRequireWildcard(_PFAttacks);

var _PFDefense = __webpack_require__(13);

var PFDefense = _interopRequireWildcard(_PFDefense);

var _PFHealth = __webpack_require__(21);

var PFHealth = _interopRequireWildcard(_PFHealth);

var _PFChecks = __webpack_require__(19);

var PFChecks = _interopRequireWildcard(_PFChecks);

var _PFInitiative = __webpack_require__(22);

var PFInitiative = _interopRequireWildcard(_PFInitiative);

var _PFEncumbrance = __webpack_require__(20);

var PFEncumbrance = _interopRequireWildcard(_PFEncumbrance);

var _PFSize = __webpack_require__(15);

var PFSize = _interopRequireWildcard(_PFSize);

var _PFSkills = __webpack_require__(16);

var PFSkills = _interopRequireWildcard(_PFSkills);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//new  cmb, dmg_ranged, armor, shield, natural, flat-footed, speed, initiative, size
// added:init, speed, dmg_ranged, cmb
var buffColumns = ["Ranged", "Melee", "CMB", "DMG", "DMG_ranged", "AC", "Touch", "CMD", "armor", "shield", "natural", "flat-footed", "speed", "initiative", "size", "check_skills", "HP-temp", "Fort", "Will", "Ref", "Check", "CasterLevel", 'STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA', 'STR_skills', 'DEX_skills', 'CON_skills', 'INT_skills', 'WIS_skills', 'CHA_skills'],
    events = {
	// events pass in the column updated macro-text is "either", buffs are auto only
	buffTotalNonAbilityEvents: {
		"Fort": [PFSaves.updateSave],
		"Will": [PFSaves.updateSave],
		"Ref": [PFSaves.updateSave],
		"STR_skills": [PFSkills.recalculateAbilityBasedSkills],
		"DEX_skills": [PFSkills.recalculateAbilityBasedSkills],
		"CON_skills": [PFSkills.recalculateAbilityBasedSkills],
		"INT_skills": [PFSkills.recalculateAbilityBasedSkills],
		"WIS_skills": [PFSkills.recalculateAbilityBasedSkills],
		"CHA_skills": [PFSkills.recalculateAbilityBasedSkills],
		"Melee": [PFAttackGrid.updateAttackGrid],
		"Ranged": [PFAttackGrid.updateAttackGrid],
		"CMB": [PFAttackGrid.updateAttackGrid]
	},
	buffTotalAbilityEvents: {
		"STR": [PFAbilityScores.updateAbilityScore],
		"DEX": [PFAbilityScores.updateAbilityScore],
		"CON": [PFAbilityScores.updateAbilityScore],
		"INT": [PFAbilityScores.updateAbilityScore],
		"WIS": [PFAbilityScores.updateAbilityScore],
		"CHA": [PFAbilityScores.updateAbilityScore]
	},
	// events do NOT pass in column updated
	buffTotalEventsNoParam: {
		"DMG": [PFAttacks.updateRepeatingWeaponDamages],
		"DMG_ranged": [PFAttacks.updateRepeatingWeaponDamages],
		"AC": [PFDefense.updateDefenses],
		"Touch": [PFDefense.updateDefenses],
		"armor": [PFDefense.updateDefenses],
		"shield": [PFDefense.updateDefenses],
		"natural": [PFDefense.updateDefenses],
		"flat-footed": [PFDefense.updateDefenses],
		"CMD": [PFDefense.updateDefenses],
		"HP-temp": [PFHealth.updateTempMaxHP],
		"Check": [PFInitiative.updateInitiative],
		"check_skills": [PFSkills.recalculate],
		"initiative": [PFInitiative.updateInitiative],
		"speed": [PFEncumbrance.updateModifiedSpeed],
		"size": [PFSize.updateSizeAsync]
	}
};
//why did i make this? it just repeats the ability scores
//buffColumns.concat(PFAbilityScores.abilities),
/* this is so old no one will be using it*/
function migrate(outerCallback) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFBuffs.migrate");
		if (typeof outerCallback === "function") {
			outerCallback();
		}
	}),
	    migrateMeleeAndAbilityChecks = function migrateMeleeAndAbilityChecks(callback) {
		var done = _underscore2.default.once(function () {
			if (typeof callback === "function") {
				callback();
			}
		}),
		    migrated = function migrated() {
			setAttrs({ 'migrated_buffs_rangeddmg_abiilty': 1 }, _PFConst2.default.silentParams, done);
		};
		getAttrs(['migrated_buffs_rangeddmg_abiilty'], function (vout) {
			var wasmigrated = parseInt(vout.migrated_buffs_rangeddmg_abiilty, 10) || 0;
			if (!wasmigrated) {
				getSectionIDs('repeating_buff', function (ids) {
					var fields;
					if (_underscore2.default.size(ids)) {
						fields = SWUtils.cartesianAppend(['repeating_buff_'], ids, ['_buff-DMG_macro-text', '_buff-DMG', '_buff-DMG-show', '_buff-DMG_ranged_macro-text', '_buff-DMG_ranged', '_buff-Melee_macro-text', '_buff-Melee', '_buff-Melee-show', '_buff-CMB_macro-text', '_buff-CMB_ranged', '_buff-Check_macro-text', '_buff-Check', '_buff-Check-show', '_buff-check_skills_macro-text', '_buff-check_skills']);
						fields = fields.concat(['buff_Check-total', 'buff_check_skills-total', 'buff_Melee-total', 'buff_DMG-total', 'buff_DMG_ranged-total', 'buff-CMB-total']);
						getAttrs(fields, function (v) {
							var setter = {},
							    resetconditions = false,
							    tempInt = 0;
							try {
								_exportsLoaderTASTheAaronSheet2.default.debug("###########", "PFBuffs.migrate found ", v);
								ids.forEach(function (id) {
									var prefix = 'repeating_buff_' + id + '_buff-';
									_exportsLoaderTASTheAaronSheet2.default.debug("at id " + id);
									if (v[prefix + 'DMG_macro-text'] && !v[prefix + 'DMG_ranged_macro-text']) {
										setter[prefix + 'DMG_ranged_macro-text'] = v[prefix + 'DMG_macro-text'];
										setter[prefix + 'DMG_ranged'] = parseInt(v[prefix + 'DMG'], 10) || 0;
										if (parseInt(v[prefix + 'DMG-show'], 10)) {
											setter[prefix + 'DMG_ranged-show'] = 1;
										}
									}
									if (v[prefix + 'Check_macro-text'] && !v[prefix + 'check_skills_macro-text']) {
										setter[prefix + 'check_skills_macro-text'] = v[prefix + 'Check_macro-text'];
										setter[prefix + 'check_skills'] = parseInt(v[prefix + 'Check'], 10) || 0;
										resetconditions = true;
										if (parseInt(v[prefix + 'Check-show'], 10)) {
											setter[prefix + 'check_skills-show'] = 1;
										}
									}
									if (v[prefix + 'Melee_macro-text'] && !v[prefix + 'CMB_macro-text']) {
										setter[prefix + 'CMB_macro-text'] = v[prefix + 'Melee_macro-text'];
										setter[prefix + 'CMB'] = parseInt(v[prefix + 'Melee'], 10) || 0;
										resetconditions = true;
										if (parseInt(v[prefix + 'Melee-show'], 10)) {
											setter[prefix + 'CMB-show'] = 1;
										}
									}
								});
								tempInt = parseInt(v['buff_DMG-total'], 10) || 0;
								if (tempInt) {
									setter['buff_DMG_ranged-total'] = tempInt + parseInt(v['buff_DMG_ranged-total'], 10) || 0;
								}
								tempInt = parseInt(v['buff_Check-total'], 10) || 0;
								if (tempInt) {
									setter['buff_check_skills-total'] = tempInt + parseInt(v['buff_check_skills-total'], 10) || 0;
								}
								tempInt = parseInt(v['buff_Melee-total'], 10) || 0;
								if (tempInt) {
									setter['buff_CMB-total'] = tempInt + parseInt(v['buff_CMB-total'], 10) || 0;
								}
							} catch (err) {
								_exportsLoaderTASTheAaronSheet2.default.error("PFBuffs.migrateDmgAbility", err);
							} finally {
								if (_underscore2.default.size(setter)) {
									_exportsLoaderTASTheAaronSheet2.default.debug("###########", "PFBuffs migrate setting ", setter);
									setAttrs(setter, _PFConst2.default.silentParams, migrated);
									if (resetconditions) {
										PFChecks.applyConditions();
										PFInitiative.updateInitiative();
									}
								} else {
									migrated();
								}
							}
						});
					} else {
						migrated();
					}
				});
			} else {
				done();
				return;
			}
		});
	};
	migrateMeleeAndAbilityChecks(done);
	getAttrs(["migrated_buffs", "migrated_effects"], function (v) {
		var setter = {};
		try {
			if (parseInt(v.migrated_buffs, 10) !== 1) {
				setter.migrated_buffs = 1;
			}
			if (parseInt(v.migrated_effects, 10) !== 1) {
				setter.migrated_effects = 1;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFBuffs.migrate", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				setAttrs(setter, _PFConst2.default.silentParams);
			} else {
				done();
			}
		}
	});
}
/** createTotalBuffEntry - used by parseNPC
 * adds enabled buff for a new sheet where this is the only buff so sets total as well.
 * adds attributes to array passed in
 * @param {string} name name of buff row  for buff-name
 * @param {string} bufftype  -string from buffColumns
 * @param {string} buffmacro ?
 * @param {number} modamount - value for the buff
 * @param {map} newRowAttrs - object of {name:value} to pass to setAttrs
 * @returns {map} return newRowAttrs after adding maps to it.
 */
function createTotalBuffEntry(name, bufftype, buffmacro, modamount, newRowAttrs) {
	var newRowId = generateRowID();
	newRowAttrs = newRowAttrs || {};
	newRowAttrs["repeating_buff_" + newRowId + "_buff-name"] = name;
	newRowAttrs["repeating_buff_" + newRowId + "_buff-" + bufftype + "_macro-text"] = buffmacro;
	newRowAttrs["repeating_buff_" + newRowId + "_buff-" + bufftype] = modamount;
	newRowAttrs["repeating_buff_" + newRowId + "_buff-" + bufftype + "-show"] = "1";
	newRowAttrs["repeating_buff_" + newRowId + "_buff-enable_toggle"] = "1";
	newRowAttrs["buff_" + bufftype + "-total"] = modamount;
	return newRowAttrs;
}
function resetStatuspanel(callback) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	}),
	    fields;

	try {
		fields = SWUtils.cartesianAppend(["buff_"], buffColumns, ["-total", "_exists"]).concat(SWUtils.cartesianAppend(["buff_"], PFAbilityScores.abilities, ["-total_penalty", "_penalty_exists"])).concat(SWUtils.cartesianAppend(["buff_"], PFAbilityScores.abilities, ["_skills-total_penalty", "_skills_penalty_exists"]));
		getAttrs(fields, function (v) {
			var setter = {},
			    getExists = function getExists(pre, post) {
				var val, exists;
				post = post || '';
				val = parseInt(v[pre + "-total" + post], 10) || 0;
				exists = parseInt(v[pre + "_exists" + post], 10) || 0;
				if (val !== 0 && !exists) {
					return 1;
				} else if (val === 0 && exists) {
					return "";
				}
			};
			try {
				setter = _underscore2.default.reduce(buffColumns, function (memo, col) {
					var pre;
					try {
						pre = "buff_" + col;
						memo[pre + '_exists'] = getExists(pre, '');
					} catch (erri1) {} finally {
						return memo;
					}
				}, setter);
				setter = _underscore2.default.reduce(PFAbilityScores.abilities, function (memo, col) {
					var pre;
					try {
						pre = "buff_" + col;
						memo[pre + '_exists'] = getExists(pre, '_penalty');
						pre += '_skills';
						memo[pre + '_exists'] = getExists(pre, '_penalty');
					} catch (erri1) {} finally {
						return memo;
					}
				}, setter);
			} catch (err) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFBuffs.resetStatuspanel error inside calculate exists", err);
			} finally {
				if (_underscore2.default.size(setter) > 0) {
					setAttrs(setter, { silent: true }, done);
				} else {
					done();
				}
			}
		});
	} catch (errO) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFBuffs.resetStatuspanel error creating field array, abort:", errO);
		done();
	}
}
/* Sets 1 or 0 for buffexists in status panel - only called by updateBuffTotals. */

/** but keep since we're redoing buffs soon
 * Updates buff_<col>_exists checkbox if the val paramter has a nonzero value
 * also switches it off
 * @param {string} col column name of buff to check
 * @param {int} val value of the buff
 */
function toggleBuffStatusPanel(col, val) {
	var field = "buff_" + col + "_exists";
	getAttrs([field], function (v) {
		var setter = {};
		try {
			if (val && parseInt(v[field], 10) !== 1) {
				setter[field] = "1";
			} else if (!val && parseInt(v[field], 10) === 1) {
				setter[field] = "";
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFBuffs.toggleBuffStatusPanel", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				setAttrs(setter, { silent: true });
			}
		}
	});
}
function updateBuffTotals(col, callback, silently) {
	var tempstr = '',
	    done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFBuffs.updateBuffTotals for " + col);
		if (typeof callback === "function") {
			callback();
		}
	}),
	    isAbility = PFAbilityScores.abilities.indexOf(col) >= 0 && col.indexOf('skill') === -1;
	try {
		_exportsLoaderTASTheAaronSheet2.default.repeating('buff').attrs('buff_' + col + '-total', 'buff_' + col + '-total_penalty').fields('buff-' + col, 'buff-enable_toggle', 'buff-' + col + '-show').reduce(function (m, r) {
			try {
				var tempM = r.I['buff-' + col] * ((r.I['buff-enable_toggle'] || 0) & (r.I['buff-' + col + '-show'] || 0));
				tempM = tempM || 0;
				_exportsLoaderTASTheAaronSheet2.default.debug("adding " + tempM + " to m.mod:" + m.mod + " for buff " + col);
				if (tempM !== 0) {
					if (tempM >= 0) {
						m.mod += tempM;
					} else {
						m.pen += tempM;
					}
				}
			} catch (err) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFBuffs.updateBuffTotals error:" + col, err);
			} finally {
				return m;
			}
		}, {
			mod: 0,
			pen: 0
		}, function (m, r, a) {
			try {
				//TAS.debug('setting buff_' + col + '-total to '+ (m.mod||0));
				if (!isAbility) {
					m.mod += m.pen;
					m.pen = 0;
				}
				if (col === 'HP-temp' && m.mod < 0) {
					m.mod = 0;
				}
				a.I['buff_' + col + '-total'] = m.mod;
				toggleBuffStatusPanel(col, m.mod);
				if (isAbility) {
					a.I['buff_' + col + '-total_penalty'] = m.pen;
					toggleBuffStatusPanel(col + '_penalty', m.pen);
				}
				_exportsLoaderTASTheAaronSheet2.default.debug("updateBuffTotals setting ", m, r, a);
			} catch (errfinalset) {
				_exportsLoaderTASTheAaronSheet2.default.error("error setting buff_" + col + "-total", errfinalset);
			}
		}).execute(done);
	} catch (err2) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFBuffs.updateBuffTotals error:" + col, err2);
		done();
	}
}
function clearBuffTotals(callback, silently) {
	var done = function done() {
		if (typeof callback === "function") {
			callback();
		}
	},
	    fields;
	fields = SWUtils.cartesianAppend(['buff_'], buffColumns, ['-total', '_exists']);
	fields = fields.concat(SWUtils.cartesianAppend(['buff_'], PFAbilityScores.abilities, ['-total_penalty', '_penalty_exists']));
	_exportsLoaderTASTheAaronSheet2.default.debug("PFBuffs.clearBuffTotals getting fields:", fields);
	getAttrs(fields, function (v) {
		var setter = {},
		    params = {};
		_exportsLoaderTASTheAaronSheet2.default.debug("PFBuffs.clearBuffTotals we got back the following: ", v);
		setter = _underscore2.default.reduce(v, function (memo, val, attr) {
			if (/exists/.test(attr)) {
				if (parseInt(val, 10)) {
					memo[attr] = 0;
				}
			} else if (parseInt(val, 10) || typeof val === "undefined") {
				memo[attr] = 0;
			}
			return memo;
		}, {});
		if (_underscore2.default.size(setter)) {
			if (silently) {
				params = _PFConst2.default.silentParams;
			}
			_exportsLoaderTASTheAaronSheet2.default.debug("PFBuffs.clearBuffTotals, setting", setter);
			setAttrs(setter, params, done);
		} else {
			done();
		}
	});
}
function setBuff(id, col, callback, silently) {
	var done = function done() {
		if (typeof callback === "function") {
			callback();
		}
	},
	    idStr = SWUtils.getRepeatingIDStr(id),
	    prefix = "repeating_buff_" + idStr + "buff-" + col;
	if (col === 'size') {
		done();
		return;
	}
	SWUtils.evaluateAndSetNumber(prefix + "_macro-text", prefix, 0, function (a, b, c) {
		if (c) {
			updateBuffTotals(col, done, silently);
		} else {
			done();
		}
	}, true, done);
}
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		resetStatuspanel();
		_exportsLoaderTASTheAaronSheet2.default.debug("Leaving PFBuffs.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    numColumns = _underscore2.default.size(buffColumns),
	    columnDone = _underscore2.default.after(numColumns, done),
	    recalculateBuffColumn = function recalculateBuffColumn(ids, col) {
		var rowtotal = _underscore2.default.size(ids),
		    totalItUp = _underscore2.default.once(function () {
			updateBuffTotals(col, columnDone, silently);
		}),
		    rowDone;
		if (rowtotal <= 0) {
			totalItUp();
			return;
		}
		rowDone = _underscore2.default.after(rowtotal, function () {
			totalItUp();
		});
		try {
			if (col === 'size') {
				totalItUp();
				return;
			}
			_underscore2.default.each(ids, function (id) {
				try {
					getAttrs(['repeating_buff_' + id + '_buff-enable_toggle', 'repeating_buff_' + id + '_buff-' + col + '-show'], function (v) {
						if (parseInt(v['repeating_buff_' + id + '_buff-enable_toggle'], 10) && parseInt(v['repeating_buff_' + id + '_buff-' + col + '-show'], 10)) {
							//setBuff(id, col, rowDone, silently);
							SWUtils.evaluateAndSetNumber('repeating_buff_' + id + '_buff-' + col + "_macro-text", 'repeating_buff_' + id + '_buff-' + col, 0, rowDone, true);
						} else {
							rowDone();
						}
					});
				} catch (err) {
					_exportsLoaderTASTheAaronSheet2.default.error("PFBuffs.recalculate_recalculateBuffColumn:" + col + ", rowid" + id, err);
					rowDone();
				}
			});
		} catch (err2) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFBuffs.recalculate_recalculateBuffColumn OUTER error:" + col, err2);
			totalItUp();
		}
	},
	    recalculateAll = function recalculateAll() {
		getSectionIDs("repeating_buff", function (ids) {
			//TAS.debug("pfbuffsrecalculate there are " + _.size(ids) + " rows and " + numColumns + " columns");
			try {
				if (_underscore2.default.size(ids) > 0) {
					_underscore2.default.each(buffColumns, function (col) {
						recalculateBuffColumn(ids, col);
					});
				} else {
					clearBuffTotals(done);
				}
			} catch (err) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFBuffs.recalculate.recalculateAll", err);
				//what to do? just quit
				done();
			}
		});
	};
	migrate(recalculateAll);
}
function registerEventHandlers() {
	//BUFFS
	_underscore2.default.each(buffColumns, function (col) {
		//Evaluate macro text upon change
		var prefix = "change:repeating_buff:buff-" + col;
		if (col !== 'size') {
			on(prefix + "_macro-text", _exportsLoaderTASTheAaronSheet2.default.callback(function eventBuffMacroText(eventInfo) {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " for column " + col + ", event: " + eventInfo.sourceType);
				setBuff(null, col);
			}));
		}
		on(prefix + "-show", _exportsLoaderTASTheAaronSheet2.default.callback(function PFBuffs_updateBuffRowShowBuff(eventInfo) {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
				getAttrs(['repeating_buff_buff-' + col], function (v) {
					if (parseInt(v['repeating_buff_buff-' + col], 10)) {
						updateBuffTotals(col);
					}
				});
			}
		}));
	});
	//size is special users modify it via dropdown
	on("change:repeating_buff:buff-size", _exportsLoaderTASTheAaronSheet2.default.callback(function PFBuffs_updateBuffSize(eventInfo) {
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			updateBuffTotals('size');
		}
	}));
	on("remove:repeating_buff", _exportsLoaderTASTheAaronSheet2.default.callback(function PFBuffs_removeBuffRow(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			_underscore2.default.each(buffColumns, function (col) {
				updateBuffTotals(col);
			});
		}
	}));
	on("change:repeating_buff:buff-enable_toggle", _exportsLoaderTASTheAaronSheet2.default.callback(function PFBuffs_enableBuffRow(eventInfo) {
		var fields;
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			fields = SWUtils.cartesianAppend(['repeating_buff_buff-'], buffColumns, ['-show', '']);
			getAttrs(fields, function (v) {
				_underscore2.default.each(buffColumns, function (col) {
					if (parseInt(v['repeating_buff_buff-' + col + '-show'], 10) && parseInt(v['repeating_buff_buff-' + col], 10)) {
						updateBuffTotals(col);
					}
				});
			});
		}
	}));
	//generic easy buff total updates
	_underscore2.default.each(events.buffTotalNonAbilityEvents, function (functions, col) {
		var eventToWatch = "change:buff_" + col + "-total";
		_underscore2.default.each(functions, function (methodToCall) {
			on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function event_updateBuffNonAbilityEvents(eventInfo) {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
				if (eventInfo.sourceType === "sheetworker") {
					methodToCall(col, eventInfo);
				}
			}));
		});
	});
	_underscore2.default.each(events.buffTotalAbilityEvents, function (functions, col) {
		var eventToWatch = "change:buff_" + col + "-total change:buff_" + col + "-total_penalty";
		_underscore2.default.each(functions, function (methodToCall) {
			on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function event_updateBuffAbilityEvents(eventInfo) {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
				if (eventInfo.sourceType === "sheetworker") {
					methodToCall(col, eventInfo);
				}
			}));
		});
	});
	_underscore2.default.each(events.buffTotalEventsNoParam, function (functions, col) {
		var eventToWatch = "change:buff_" + col + "-total";
		_underscore2.default.each(functions, function (methodToCall) {
			on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventBuffTotalNoParam(eventInfo) {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
				if (eventInfo.sourceType === "sheetworker") {
					methodToCall(null, false, eventInfo);
				}
			}));
		});
	});
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFBuffs module loaded          ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.classRows = exports.raceColumns = exports.classColumns = undefined;
exports.setMulticlassed = setMulticlassed;
exports.setHitPoints = setHitPoints;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFSpells = __webpack_require__(17);

var PFSpells = _interopRequireWildcard(_PFSpells);

var _PFSpellCasterClasses = __webpack_require__(24);

var PFSpellCasterClasses = _interopRequireWildcard(_PFSpellCasterClasses);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var classColumns = exports.classColumns = ["skill", "fcskill", "fcalt", "bab", "Fort", "Ref", "Will", "level"],
    raceColumns = exports.raceColumns = ['skill', 'bab', 'Fort', 'Ref', 'Will', 'hd-num'],
    classRows = exports.classRows = ["0", "1", "2", "3", "4", "5"];
var events = {
    basehp: "change:auto_calc_hp change:autohp_percent change:maxhp_lvl1",
    racialhp: "change:npc-hd-num change:npc-hd change:npc-hp",
    perClassRowhp: "change:class-REPLACE-level change:class-REPLACE-hd change:class-REPLACE-hp change:class-REPLACE-fchp"
};

function setMulticlassed() {
    var fields = ['multiclassed', 'class-0-level', 'class-1-level', 'class-2-level', 'class-3-level', 'class-4-level', 'class-5-level', 'npc-hd-num'];
    //TAS.debug("at PFClassRaceGrid.setMulticlassed");
    getAttrs(fields, function (v) {
        var isMulti = parseInt(v.multiclassed, 10) || 0,
            totalWLevels;
        totalWLevels = Math.min(1, parseInt(v['class-0-level'], 10) || 0) + Math.min(1, parseInt(v['class-1-level'], 10) || 0) + Math.min(1, parseInt(v['class-2-level'], 10) || 0) + Math.min(1, parseInt(v['class-3-level'], 10) || 0) + Math.min(1, parseInt(v['class-4-level'], 10) || 0) + Math.min(1, parseInt(v['class-5-level'], 10) || 0) + Math.min(1, parseInt(v['npc-hd-num'], 10) || 0);
        //TAS.debug("PFClassRaceGrid.setMulticlassed, "+ totalWLevels +" rows have levels");
        if (totalWLevels > 1) {
            if (!isMulti) {
                setAttrs({ multiclassed: 1 });
            }
        } else if (isMulti) {
            setAttrs({ multiclassed: 0 });
        }
    });
}
/** PFClassRaceGrid.updateClassInformation Updates totals at bottom of Class Information grid
 *@param {string} col end of name of attribute that references column, must be in classColumns or raceColumns 
 *@param {function} callback optional call when finished updating
 *@param {bool} silently if true then call setAttrs with PFConst.silentParams
 */
function updateClassInformation(col, callback, silently, eventInfo) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    },
        updateClassInformationInner = function updateClassInformationInner(col, callback, silently) {
        var getFields = [],
            totalColName,
            col0Name,
            col1Name,
            col2Name,
            col3Name,
            col4Name,
            col5Name,
            col0NameTwo,
            col1NameTwo,
            col2NameTwo,
            col3NameTwo,
            col4NameTwo,
            col5NameTwo;

        if (col === "fchp") {
            col = "hp";
        } else if (col === "hd-num") {
            col = "level";
        }

        col0Name = "class-0-" + col;
        col1Name = "class-1-" + col;
        col2Name = "class-2-" + col;
        col3Name = "class-3-" + col;
        col4Name = "class-4-" + col;
        col5Name = "class-5-" + col;

        totalColName = col === "bab" || col === "level" ? col : "total-" + col;
        getFields = [totalColName, col0Name, col1Name, col2Name, col3Name, col4Name, col5Name];
        if (col !== "skill") {
            //add npc values
            switch (col) {
                case 'bab':
                case 'Fort':
                case 'Will':
                case 'Ref':
                    getFields = getFields.concat(["npc-" + col]);
                    break;
                case 'level':
                    getFields = getFields.concat(["npc-hd-num"]);
                    break;
            }
            //TAS.debug(getFields);
            SWUtils.updateRowTotal(getFields, 0, [], 0, done, silently);
        } else {
            col0NameTwo = "class-0-level";
            col1NameTwo = "class-1-level";
            col2NameTwo = "class-2-level";
            col3NameTwo = "class-3-level";
            col4NameTwo = "class-4-level";
            col5NameTwo = "class-5-level";

            getFields = getFields.concat([col0NameTwo, col1NameTwo, col2NameTwo, col3NameTwo, col4NameTwo, col5NameTwo, "npc-skill", 'npc-hd-num']);
            //TAS.debug(getFields);
            getAttrs(getFields, function (v) {
                var setter = {},
                    currTot = 0,
                    params = {},
                    tot = 0;
                tot = Math.floor((parseFloat(v[col0Name], 10) || 0) * (parseInt(v[col0NameTwo], 10) || 0) + (parseFloat(v[col1Name], 10) || 0) * (parseInt(v[col1NameTwo], 10) || 0) + (parseFloat(v[col2Name], 10) || 0) * (parseInt(v[col2NameTwo], 10) || 0) + (parseFloat(v[col3Name], 10) || 0) * (parseInt(v[col3NameTwo], 10) || 0) + (parseFloat(v[col4Name], 10) || 0) * (parseInt(v[col4NameTwo], 10) || 0) + (parseFloat(v[col5Name], 10) || 0) * (parseInt(v[col5NameTwo], 10) || 0) + (parseFloat(v["npc-skill"], 10) || 0) * (parseInt(v['npc-hd-num'], 10) || 0));
                currTot = parseInt(v[totalColName], 10);
                if (isNaN(currTot) || tot !== currTot) {
                    setter[totalColName] = tot;
                    if (silently) {
                        params = _PFConst2.default.silentParams;
                    }
                    setAttrs(setter, params, done);
                } else {
                    done();
                }
            });
        }
    };
    //TAS.debug("at PFClassRaceGrid.updateClassInformation: " + col);
    //no sum for hd 
    if (!col || col === "hd" || col === "hp") {
        _exportsLoaderTASTheAaronSheet2.default.warn("at updateClassInformation called with bad column:" + col);
        done();
        return;
    }
    if (/^npc/i.test(col)) {
        col = col.slice(4);
    }
    updateClassInformationInner(col, done, silently);
}

function setHitPoints(callback, silently, eventInfo) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            _exportsLoaderTASTheAaronSheet2.default.debug("Leaving updateClassHpGrid");
            callback();
        }
    }),
        fields = ["auto_calc_hp", "autohp_percent", "maxhp_lvl1", "is_npc", "set_pfs", "total-hp", "NPC-HP", "npc-hd-num", "npc-hd", "class-0-hp", "class-0-level", "class-0-hd", "class-0-fchp", "class-1-hp", "class-1-level", "class-1-hd", "class-1-fchp", "class-2-hp", "class-2-level", "class-2-hd", "class-2-fchp", "class-3-hp", "class-3-level", "class-3-hd", "class-3-fchp", "class-4-hp", "class-4-level", "class-4-hd", "class-4-fchp", "class-5-hp", "class-5-level", "class-5-hd", "class-5-fchp"];
    getAttrs(fields, function (v) {
        var auto = 0,
            maxFirst = 0,
            mult = 1,
            isPFS = 0,
            setter = {},
            isNPC = 0,
            loudSetter = {},
            currrowhp = 0,
            rowhp = 0,
            level = 0,
            hd = 0,
            totalhp = 0,
            rowUpdated = -1,
            matches;
        try {
            //TAS.debug("at autocalc hp",v);
            auto = parseInt(v.auto_calc_hp, 10) || 0;
            if (eventInfo && eventInfo.sourceAttribute) {
                matches = eventInfo.sourceAttribute.match(/(\d)/);
                if (matches && matches[1]) {
                    rowUpdated = parseInt(matches[1], 10) || 0;
                } else if (/NPC/i.test(eventInfo.sourceAttribute)) {
                    rowUpdated = 6;
                }
            }
            if (auto) {
                isPFS = parseInt(v.set_pfs, 10) || 0;
                isNPC = parseInt(v.is_npc, 10) || 0;
                mult = PFUtils.getAutoHPPercentMultiplier(v.autohp_percent);
                maxFirst = parseInt(v.maxhp_lvl1, 10) || 0;
                if (maxFirst) {
                    if (rowUpdated === 6) {
                        rowUpdated = -1;
                    }
                }
            }
            //TAS.debug("at autocalc hp, rowupdated is:" + rowUpdated);
            level = parseInt(v['npc-hd-num'], 10) || 0;
            hd = parseInt(v['npc-hd'], 10);
            currrowhp = parseInt(v['NPC-HP'], 10) || 0;
            if (isNaN(hd) || !auto) {
                totalhp += currrowhp;
            } else if (level > 0 && hd > 0) {
                if (rowUpdated === 6 || rowUpdated === -1) {
                    //first do NPC.
                    rowhp = PFUtils.getAvgHP(level, hd, mult, maxFirst, false); //monster type hd uses regular rules even for PFS animal companions
                    totalhp += rowhp;
                    //TAS.debug("adding: "+rowhp);
                    if (rowhp !== currrowhp) {
                        setter['NPC-HP'] = rowhp;
                    }
                } else {
                    totalhp += currrowhp;
                }
                if (maxFirst) {
                    maxFirst = 0;
                }
                //TAS.debug("adding "+currrowhp);
            } else if (hd === 0) {
                if (currrowhp !== 0) {
                    setter['NPC-HP'] = 0;
                }
            }

            _underscore2.default.each(classRows, function (rowindex) {
                var fchp = 0,
                    row = parseInt(rowindex, 10);
                rowhp = 0;
                level = parseInt(v["class-" + rowindex + "-level"], 10) || 0;
                hd = parseInt(v["class-" + rowindex + "-hd"], 10);
                currrowhp = parseInt(v["class-" + rowindex + "-hp"], 10) || 0;
                fchp = parseInt(v["class-" + rowindex + "-fchp"], 10) || 0;
                if (isNaN(hd) || !auto) {
                    totalhp += currrowhp + fchp;
                } else if (level > 0 && hd > 0) {
                    if (rowUpdated === -1 || rowUpdated === row) {
                        rowhp = PFUtils.getAvgHP(level, hd, mult, maxFirst, isPFS);
                        totalhp += rowhp + fchp;
                        if (rowhp !== currrowhp) {
                            setter["class-" + rowindex + "-hp"] = rowhp;
                        }
                    } else {
                        totalhp += currrowhp + fchp;
                    }
                    if (maxFirst) {
                        maxFirst = 0;
                    }
                } else if (hd === 0) {
                    if (currrowhp !== 0) {
                        setter["class-" + rowindex + "-hp"] = 0;
                    }
                }
            });
            if (totalhp !== parseInt(v['total-hp'], 10)) {
                loudSetter["total-hp"] = totalhp;
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFClassRaceGrid.setHitPoints", err);
        } finally {
            if (_underscore2.default.size(loudSetter) > 0) {
                setAttrs(loudSetter);
            }
            if (_underscore2.default.size(setter) > 0) {
                setAttrs(setter, _PFConst2.default.silentParams, done);
            } else {
                done();
            }
        }
    });
}
function migrate(callback, oldversion) {
    if (typeof callback === "function") {
        callback();
    }
}
function recalculate(callback, silently, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFClassRaceGrid.recalculate");
        if (typeof callback === "function") {
            callback();
        }
    }),
        numcols = classColumns.length,
        columnDone = _underscore2.default.after(numcols, function () {
        setHitPoints(done, silently);
    });
    _underscore2.default.each(classColumns, function (col) {
        updateClassInformation(col, columnDone, silently);
    });
    setMulticlassed();
}
function registerEventHandlers() {
    var tempString = "";
    _underscore2.default.each(classColumns, function (col) {
        var eventsToWatch = _underscore2.default.map(classRows, function (row) {
            return "change:class-" + row + "-" + col;
        }).join(" ");
        on(eventsToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventTotalClassInformation(eventInfo) {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                updateClassInformation(col, null, null, eventInfo);
            }
        }));
        if (col === "level") {
            on(eventsToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventTotalClassInformationLevel(eventInfo) {
                _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                    updateClassInformation("skill", null, null, eventInfo);
                    setMulticlassed();
                }
            }));
        }
    });
    _underscore2.default.each(raceColumns, function (col) {
        on("change:npc-" + col, _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateRacialRow(eventInfo) {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api" || eventInfo.sourceType === "sheetworker" && eventInfo.sourceAttribute.slice(-2) === 'hp') {
                if (col === 'hd-num') {
                    updateClassInformation('level', null, null, eventInfo);
                    updateClassInformation("skill", null, null, eventInfo);
                    setMulticlassed();
                } else {
                    updateClassInformation(col, null, null, eventInfo);
                }
            }
        }));
    });
    _underscore2.default.each(classRows, function (row) {
        tempString = events.perClassRowhp.replace(/REPLACE/g, row);
        on(tempString, _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateClassHitPoints(eventInfo) {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                setHitPoints(null, null, eventInfo);
                //can we move this to spells? or keep here
                //or do we even need to do it, isn't roll20 handling?
                if (/level/i.test(eventInfo.sourceAttribute)) {
                    PFSpellCasterClasses.updateCasterFromClassLevel(parseInt(row, 10), eventInfo);
                }
            }
        }));
    });
    on(events.racialhp, _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateRacialHitPoints(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            setHitPoints(null, null, eventInfo);
            if (eventInfo.sourceAttribute === "npc-hd-num") {
                PFSpellCasterClasses.updateCasterFromClassLevel(6, eventInfo);
            }
        }
    }));
    on(events.basehp, _exportsLoaderTASTheAaronSheet2.default.callback(function eventHPAutoCalcSwitches(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            setHitPoints();
        }
    }));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFClassRaceGrid module loaded  ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = {
	/* Pathfinder RULE constants for parsing */
	unarmedAttacksRegExp: /unarmed|strike|punch|palm|flurry|blow|touch/i,
	combatManeuversRegExp: /bull\s*rush|trip|disarm|dirty\s*trick|drag|grapple|overrun|reposition|steal|sunder|trip/i,
	primaryNaturalAttacksRegExp: /bite|claw|gore|slam|sting|talon/i,
	importantFeatRegExp: /Weapon Fine|^Run$|Enduran|Defensive Combat Train|Agile Maneuv|Arcane Arm|Combat Cast|Critical Focus|Skill Focus|Critical|Intimidating Prow/i,
	spAttackAttacks: /blooddrain|touch|energydrain|bleed|burn|constrict|trample|engulf|heat|powerfulcharge|swallowwhole|constrict/i,
	spAttackAttacksPreProcess: /rake|rend|web/i,
	abilitySrch: /str|dex|con|int|wis|cha/i,
	cmbMonsterSrch: /tongue|pull|drag|grab|push/i,
	cmbPlusStrsrch: /swallowwhole|engulf|constrict|swallow/i,
	casterDefaultAbility: {
		sorcerer: 'cha',
		wizard: 'int',
		cleric: 'wis',
		bard: 'cha',
		druid: 'wis',
		paladin: 'cha',
		ranger: 'wis',
		oracle: 'cha',
		witch: 'int',
		alchemist: 'int',
		summoner: 'cha',
		inquisitor: 'wis',
		magus: 'int'
	},
	creatureTypeClassSkills: {
		aberration: ['Acrobatics', 'Climb', 'Escape-Artist', 'Fly', 'Intimidate', 'Knowledge', 'Perception', 'Spellcraft', 'Stealth', 'Survival', 'Swim'],
		animal: ['Acrobatics', 'Climb', 'Fly', 'Perception', 'Stealth', 'Swim'],
		dragon: ['Appraise', 'Bluff', 'Climb', 'Craft', 'Diplomacy', 'Fly', 'Heal', 'Intimidate', 'Linguistics', 'Knowledge', 'Perception', 'Sense-Motive', 'Spellcraft', 'Stealth', 'Survival', 'Swim', 'Use-Magic-Device'],
		fey: ['Appraise', 'Bluff', 'Climb', 'Craft', 'Diplomacy', 'Disguise', 'Escape-Artist', 'Fly', 'Knowledge-Geography', 'Knowledge-Local', 'Knowledge-Nature', 'Perception', 'Perform', 'Sense-Motive', 'Sleight-of-Hand', 'Stealth', 'Swim', 'Use-Magic-Device'],
		monstrous: ['Climb', 'Craft', 'Fly', 'Intimidate', 'Perception', 'Ride', 'Stealth', 'Survival', 'Swim'],
		humanoid: ['Climb', 'Craft', 'Handle-Animal', 'Heal', 'Profession', 'Ride', 'Survival'],
		magicalbeast: ['Acrobatics', 'Climb', 'Fly', 'Perception', 'Steatlh', 'Swim'],
		outsider: ['Bluff', 'Craft', 'Knowledge-Planes', 'Perception', 'Sense-Motive', 'Stealth'],
		plant: ['Perception', 'Stealth'],
		undead: ['Climb', 'Disguise', 'Fly', 'Intimidate', 'Knowledge-Arcana', 'Knowledge-Religion', 'Perception', 'Sense-Motive', 'Spellcraft', 'Stealth']
	},
	creatureSubtypeClassSkills: {
		air: ['Fly'],
		giant: ['Intimidate', 'Perception'],
		goblinoid: ['Stealth'],
		inevitable: ['Acrobatics', 'Diplomacy', 'Intimidate', 'Survival'],
		water: ['Swim'],
		robot: ['Climb', 'Disable-Device', 'Fly', 'Knowledge', 'Linguistics', 'Perception', 'Sense-Motive']
	},
	specialAttackDCAbilityBase: {
		'breathweapon': 'CON',
		'burn': 'CON',
		'curse': 'CHA',
		'disease': 'CON',
		'distraction': 'CON',
		'emotionaura': 'CHA',
		'energydrain': 'CHA',
		'entrap': 'CON',
		'fear': 'CHA',
		'fearaura': 'CHA',
		'fearcone': 'CHA',
		'fearray': 'CHA',
		'frightfulpresence': 'CHA',
		'gaze': 'CHA',
		'mentalstaticaura': 'CHA',
		'paralysis': 'CON',
		'poison': 'CON',
		'stench': 'CON',
		'trample': 'STR',
		'web': 'CON',
		'whirlwind': 'STR'
	},
	monsterRulesPlusAttacks: ['grab', 'trip', 'engulf', 'swallow whole'],
	naturalAttackRegExp: /arm|bite|claw|foreclaw|gore|hoof|kick|leg|pincer|quill|root|slam|slap|snake\s*bite|spike|spine|splinter|sting|tail|tail\s*slap|talon|tendril|tentacle|thorn|tongue|vine|wing|buffet/i,
	skillBonusFeatRegExp: /Acrobatic|Uncanny Alertness|Alertness|Animal Affinity|Athletic|Breadth of Experience|Brewmaster|Deceitful|Deft Hands|Deny the Reaper|Forgotten Past|Innocent Blood|Monkey Moves|Monkey Style|Monument Builder|No Name|Persuasive|Scavenger.s Eye|Sea Legs|Self.Sufficient|Sharp Senses|Stealthy|Sure and Fleet|Voice of the Sibyl/i,
	lessImportantCombatFeatRegExp: /Power Attack|Double Slice|Greater Weapon of the Chosen|Spell Focus|Toughness/i,
	monsterRules: /spells|damage reduction/i
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.migrateMap = exports.featureLists = undefined;
exports.resetTopCommandMacro = resetTopCommandMacro;
exports.resetCommandMacro = resetCommandMacro;
exports.convertNameToLevel = convertNameToLevel;
exports.getAbilities = getAbilities;
exports.copyToAbilities = copyToAbilities;
exports.setNewDefaults = setNewDefaults;
exports.migrateRepeatingMacros = migrateRepeatingMacros;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFMacros = __webpack_require__(10);

var PFMacros = _interopRequireWildcard(_PFMacros);

var _PFMenus = __webpack_require__(14);

var PFMenus = _interopRequireWildcard(_PFMenus);

var _PFAbility = __webpack_require__(18);

var PFAbility = _interopRequireWildcard(_PFAbility);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var featureLists = exports.featureLists = ["class-ability", "feat", "racial-trait", "trait", "mythic-ability", "mythic-feat", 'npc-spell-like-abilities'],
    migrateMap = exports.migrateMap = {
	'feat': { 'copyAttrs': ['name', 'short-description', 'used', 'used_max', 'showinmenu', 'description', 'max-calculation', 'ability_type'],
		'LU': ['_name', '_short-description', '_used', '_used_max', '_showinmenu', '_description', '_macro-text', '_npc-macro-text', '_max-calculation', '_ability_type'],
		'classDefault': '0',
		'hasNPCMacro': true,
		'ruleCategory': 'feats' },
	'racial-trait': { 'copyAttrs': ['name', 'short-description', 'used', 'used_max', 'showinmenu', 'description', 'max-calculation', 'ability_type'],
		'LU': ['_name', '_short-description', '_used', '_used_max', '_showinmenu', '_description', '_macro-text', '_npc-macro-text', '_max-calculation', '_ability_type'],
		'hasNPCMacro': true,
		'classDefault': '@{level}',
		'ruleCategory': 'racial-traits' },
	'trait': { 'copyAttrs': ['name', 'short-description', 'used', 'used_max', 'showinmenu', 'description', 'max-calculation', 'ability_type'],
		'LU': ['_name', '_short-description', '_used', '_used_max', '_showinmenu', '_description', '_macro-text', '_max-calculation', '_ability_type'],
		'classDefault': '@{level}',
		'ruleCategory': 'traits' },
	'class-ability': { 'copyAttrs': ['name', 'short-description', 'used', 'used_max', 'showinmenu', 'description', 'max-calculation'],
		'LU': ['_name', '_short-description', '_used', '_used_max', '_showinmenu', '_description', '_macro-text', '_max-calculation', '_class-number'],
		'ruleCategory': 'class-features',
		'convertClass': true },
	'npc-spell-like-abilities': { 'copyAttrs': ['name', 'short-description', 'used', 'used_max', 'showinmenu', 'description', 'max-calculation', 'duration', 'save', 'range'],
		'LU': ['_name', '_short-description', '_used', '_used_max', '_showinmenu', '_description', '_macro-text', '_npc-macro-text', '_max-calculation', '_level', '_range', '_duration', '_save', '_sr'],
		'hasNPCMacro': false,
		'classDefault': '@{level}',
		'ruleCategory': 'spell-like-abilities' }
};
var migrateButtonMap = {
	merge_traits_now: 'trait',
	merge_race_traits_now: 'racial-trait',
	merge_feats_now: 'feat',
	merge_class_features_now: 'class-ability',
	merge_slas_now: 'npc-spell-like-abilities',
	delete_traits_now: 'trait',
	delete_race_traits_now: 'racial-trait',
	delete_feats_now: 'feat',
	delete_class_features_now: 'class-ability',
	delete_slas_now: 'npc-spell-like-abilities'
},
    baseCommandMacro = "/w \"@{character_name}\" &{template:pf_block} @{toggle_attack_accessible} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_generic}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=^{all-abilities}}} ",
    otherCommandMacros = {
	'class-ability': " [^{original-class-features-list}](~@{character_id}|class-ability_button)",
	'mythic': " [^{mythic-abilities}](~@{character_id}|mythic-ability_button) [^{mythic-feats}](~@{character_id}|mythic-feat_button)",
	'feat': " [^{original-feats-list}](~@{character_id}|REPLACENPCfeat_button)",
	'racial-trait': " [^{original-racial-traits-list}](~@{character_id}|REPLACENPCracial-trait_button)",
	'trait': " [^{original-traits-list}](~@{character_id}|trait_button)",
	'npc-spell-like-abilities': " [^{original-spell-like-abilities-list}](~@{character_id}|npc-spell-like-abilities_button)"
},
    defaultMacroMap = {
	'feat': 'default',
	'trait': 'default',
	'racial-trait': 'default',
	'class-ability': 'class-ability',
	'mythic-ability': 'mythic-ability',
	'mythic-feat': 'default'
},
    defaultMacros = {
	'default': {
		defaultRepeatingMacro: "&{template:pf_generic} @{toggle_accessible_flag} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_block}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=@{name}}} {{description=@{short-description}}}",
		defaultRepeatingMacroMap: {
			'&{template:': { 'current': 'pf_generic}', 'old': ['pf_block}'] },
			'@{toggle_accessible_flag}': { 'current': '@{toggle_accessible_flag}' },
			'@{toggle_rounded_flag}': { 'current': '@{toggle_rounded_flag}' },
			'{{color=': { 'current': '@{rolltemplate_color}}}' },
			'{{header_image=': { 'current': '@{header_image-pf_block}}}' },
			'{{character_name=': { 'current': '@{character_name}}}' },
			'{{character_id=': { 'current': '@{character_id}}}' },
			'{{subtitle}}': { 'current': '{{subtitle}}' },
			'{{name=': { 'current': '@{name}}}' },
			'{{description=': { 'current': '@{short-description}}}', 'old': [' @{short-description}}}'] } },
		defaultDeletedArray: null
	},
	'class-ability': {
		defaultRepeatingMacro: "&{template:pf_block} @{toggle_accessible_flag} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_block}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{class=**^{class}**: @{class-number}}} {{name=@{name}}} {{description=@{short-description}}}",
		defaultRepeatingMacroMap: {
			'&{template:': { 'current': 'pf_generic}', 'old': ['pf_block}'] },
			'@{toggle_accessible_flag}': { 'current': '@{toggle_accessible_flag}' },
			'@{toggle_rounded_flag}': { 'current': '@{toggle_rounded_flag}' },
			'{{color=': { 'current': '@{rolltemplate_color}}}' },
			'{{header_image=': { 'current': '@{header_image-pf_generic}}}' },
			'{{character_name=': { 'current': '@{character_name}}}' },
			'{{character_id=': { 'current': '@{character_id}}}' },
			'{{subtitle=': { 'current': '{{subtitle}}', 'old': ['^{@{rule_category}}}}', 'Class Ability}}'] },
			'{{class=': { 'current': '**^{class}**: @{class-number}}}', 'old': ['**Class**: @{class-number}}}'], replacements: [{ 'from': 'Class', 'to': 'class' }] },
			'{{name=': { 'current': '@{name}}}' },
			'{{description=': { 'current': '@{short-description}}}', 'old': [' @{short-description}}}'] } },
		defaultDeletedArray: ['{{Class=**Class**: @{class-number}}}', '{{subtitle=^{@{rule_category}}}}']
	},
	'mythic-ability': {
		defaultRepeatingMacro: "&{template:pf_block} @{toggle_accessible_flag} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_block}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{class=**^{path}**: @{mythic-number}}} {{name=@{name}}} {{description=@{short-description}}}",
		defaultRepeatingMacroMap: {
			'&{template:': { 'current': 'pf_generic}', 'old': ['pf_block}'] },
			'@{toggle_accessible_flag}': { 'current': '@{toggle_accessible_flag}' },
			'@{toggle_rounded_flag}': { 'current': '@{toggle_rounded_flag}' },
			'{{color=': { 'current': '@{rolltemplate_color}}}' },
			'{{header_image=': { 'current': '@{header_image-pf_block}}}' },
			'{{character_name=': { 'current': '@{character_name}}}' },
			'{{character_id=': { 'current': '@{character_id}}}' },
			'{{subtitle=': { 'current': '{{subtitle}}' },
			'{{class=': { 'current': '**^{path}**: @{mythic-number}}}', 'old': ['**Path**: @{mythic-number}}}'], replacements: [{ 'from': 'Path', 'to': 'path' }] },
			'{{name=': { 'current': '@{name}}}' },
			'{{description=': { 'current': '@{short-description}}}', 'old': [' @{short-description}}}'] } },
		defaultDeletedArray: ['{{subtitle}}', '{{Class=**Class**: @{class-number}}}']
	},
	'spell-like-ability': {
		defaultRepeatingMacro: '&{template:pf_generic} @{toggle_accessible_flag} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_generic}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=@{name}}} {{^{level}=[[@{level}]]}} {{^{range}=@{range}}} {{^{duration}=@{duration}}} {{^{save}=@{save}, ^{difficulty-class-abbrv} [[@{savedc}]]}} {{^{spell-resistance-abbrv}=@{abil-sr}}} {{description=@{short-description}}}',
		defaultRepeatingMacroMap: {
			'&{template:': { 'current': 'pf_generic}' },
			'@{toggle_accessible_flag}': { 'current': '@{toggle_accessible_flag}' },
			'@{toggle_rounded_flag}': { 'current': '@{toggle_rounded_flag}' },
			'{{color=': { 'current': '@{rolltemplate_color}}}' },
			'{{header_image=': { 'current': '@{header_image-pf_block}}}' },
			'{{character_name=': { 'current': '@{character_name}}}' },
			'{{character_id=': { 'current': '@{character_id}}}' },
			'{{name=': { 'current': '@{name}}}' },
			'{{subtitle=': { 'current': '{{subtitle}}', 'old': ['^{@{rule_category}}}}', 'Class Ability}}'] },
			'{{^{level}=': { 'current': '@{level}}}', 'old': ['[[@{spell_level}]]}}'] },
			'{{^{range}=': { 'current': '@{range}}}', 'old': ['^{@{range_pick}} [[@{range_numeric}]]}}'] },
			'{{^{duration}=': { 'current': '@{duration}}}' },
			'{{^{save}=': { 'current': '@{save}}}', 'old': ['@{save}, ^{difficulty-class-abbrv} [[@{savedc}]]}}'] },
			'{{^{spell-resistance-abbrv}=': { 'current': '@{sr}}}', 'old': ['^{@{abil-sr}}}}'] },
			'{{description=': { 'current': '@{short-description}}}', 'old': [' @{short-description}}}'] } },
		defaultDeletedArray: ['{{Level=@{level}}}', '{{Range=@{range}}}', '{{Duration=@{duration}}}', '{{Save=@{save}}}', '{{SR=@{sr}}}', '{{^{frequency}=@{used}/@{used|max} ^{@{frequency}} @{rounds_between}}}', '{{^{frequency}=@{used}/@{used|max} ^{@{frequency}}}}', '{{subtitle=^{@{rule_category}}}}']
	}
},
    events = {
	commandMacroFields: ["name", "used", "used_max", "showinmenu"]
};

/** resetTopCommandMacro sets orig_ability_header_macro  (macro to plug into pf_block, read by PFAbility.resetCommandMacro)
 *@param {function} callback call when done	
 */
function resetTopCommandMacro(callback) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFFeatures.resetTopCommandMacro");
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["is_npc", "NPC-orig_ability_header_macro", "orig_ability_header_macro", "mythic-adventures-show", "use_traits", "use_racial_traits", "use_feats", "use_class_features", "use_spell-like-abilities"], function (v) {
		var isMythic = 0,
		    usesTraits = 0,
		    usesRacialTraits = 0,
		    hasMythicMacro = 0,
		    usesFeats = 0,
		    usesClass = 0,
		    usesSLAs = 0,
		    newMacro = "",
		    isNPC = 0,
		    prefix = "",
		    setter = {};
		try {
			isNPC = parseInt(v.is_npc, 10) || 0;
			prefix = isNPC ? "NPC-" : "";
			isMythic = parseInt(v["mythic-adventures-show"], 10) || 0;
			usesFeats = parseInt(v["use_feats"], 10) || 0;
			usesClass = parseInt(v["use_class_features"], 10) || 0;
			usesTraits = parseInt(v.use_traits, 10) || 0;
			usesRacialTraits = parseInt(v.use_racial_traits, 10) || 0;
			usesSLAs = parseInt(v["use_spell-like-abilities"], 10) || 0;

			newMacro = (usesClass ? otherCommandMacros['class-ability'] : "") + (usesFeats ? otherCommandMacros['feat'].replace(/REPLACENPC/g, prefix) : "") + (usesSLAs ? otherCommandMacros['npc-spell-like-abilities'] : "") + (usesTraits ? otherCommandMacros['trait'] : "") + (usesRacialTraits ? otherCommandMacros['racial-trait'].replace(/REPLACENPC/g, prefix) : "") + (isMythic ? otherCommandMacros['mythic'] : "");
			if (newMacro) {
				//no space in front needed for this one
				newMacro = "{{row01=^{original-abilities-menus}}} {{row02=" + newMacro + "}}";
			}
			if (newMacro !== v[prefix + 'orig_ability_header_macro']) {
				setter[prefix + 'orig_ability_header_macro'] = newMacro;
			}
			if (isNPC) {
				newMacro = (usesClass ? otherCommandMacros['class-ability'] : "") + (usesFeats ? otherCommandMacros['feat'].replace(/REPLACENPC/g, '') : "") + (usesSLAs ? otherCommandMacros['npc-spell-like-abilities'] : "") + (usesTraits ? otherCommandMacros['trait'] : "") + (usesRacialTraits ? otherCommandMacros['racial-trait'].replace(/REPLACENPC/g, '') : "") + (isMythic ? otherCommandMacros['mythic'] : "");
				if (newMacro) {
					//no space in front needed for this one
					newMacro = "{{row01=^{original-abilities-menus}}} {{row02=" + newMacro + "}}";
				}
				if (newMacro !== v.orig_ability_header_macro) {
					setter['orig_ability_header_macro'] = newMacro;
				}
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFFeatures.resetTopCommandMacro", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				setAttrs(setter, _PFConst2.default.silentParams, done);
			} else {
				done();
			}
		}
	});
}
/** resets the chat menu macro for all repeating lists in abilities tab
 *@param {function} callback call when done
 */
function resetCommandMacro(callback) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFFeatures.resetCommandMacro");
		if (typeof callback === "function") {
			callback();
		}
	});

	getAttrs(["mythic-adventures-show", "use_traits", "use_racial_traits", "use_class_features", "use_feats", "use_spell-like-abilities"], function (v) {
		var featureList = [],
		    doneWithOneButton,
		    isMythic = 0,
		    usesTraits = 0,
		    usesRacialTraits = 0,
		    usesFeats = 0,
		    usesClass = 0,
		    usesSLAs = 0,
		    newMacro = "",
		    numberLists = 0,
		    setter = {};
		try {
			isMythic = parseInt(v["mythic-adventures-show"], 10) || 0;
			usesFeats = parseInt(v["use_feats"], 10) || 0;
			usesClass = parseInt(v["use_class_features"], 10) || 0;
			usesTraits = parseInt(v.use_traits, 10) || 0;
			usesRacialTraits = parseInt(v.use_racial_traits, 10) || 0;
			usesSLAs = parseInt(v["use_spell-like-abilities"], 10) || 0;
			//TAS.debug("at PFFeatures.resetCommandMacro",v);
			if (usesFeats) {
				featureList.push('feat');
				numberLists += 2;
			}
			if (usesTraits) {
				featureList.push('trait');
				numberLists++;
			}
			if (usesRacialTraits) {
				featureList.push('racial-trait');
				numberLists += 2;
			}
			if (isMythic) {
				featureList = featureList.concat(['mythic-ability', 'mythic-feat']);
				numberLists += 2;
			}
			if (usesClass) {
				featureList.push('class-ability');
				numberLists++;
			}
			if (usesSLAs) {
				featureList.push('npc-spell-like-abilities');
				numberLists++;
			}
			if (numberLists > 0) {
				doneWithOneButton = _underscore2.default.after(numberLists, done);
				_underscore2.default.each(featureList, function (section) {
					if (section !== 'npc-spell-like-abilities') {
						PFMenus.resetOneCommandMacro(section, false, doneWithOneButton);
					}
					if (section === 'racial-trait' || section === 'feat' || section === 'npc-spell-like-abilities') {
						PFMenus.resetOneCommandMacro(section, true, doneWithOneButton);
					}
				});
			} else {
				done();
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFFeatures.resetCommandMacro", err);
			done();
		} finally {
			resetTopCommandMacro();
		}
	});
}
/** recalculateRepeatingMaxUsed - Parses the macro text "...max-calculation" in the repeating items
 * (such as class-abilities, feats, traits, racial-traits)
 * and sets the used|max value.
 * Loops through all rows in the given repeating section.
 * @param {string} section= the name of the section after the word "repeating_"
 * @param {function} callback when done
 * @param {boolean} silently if T then call setAttrs with {silent:true}
 */
function recalculateRepeatingMaxUsed(section, callback, silently) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getSectionIDs("repeating_" + section, function (ids) {
		var totrows = _underscore2.default.size(ids),
		    rowdone = _underscore2.default.after(totrows, done);
		if (totrows > 0) {
			_underscore2.default.each(ids, function (id, index) {
				var prefix = "repeating_" + section + "_" + id;
				SWUtils.evaluateAndSetNumber(prefix + "_max-calculation", prefix + "_used_max", 0, rowdone, silently);
			});
		} else {
			done();
		}
	});
}
function convertNameToLevel(name) {
	var classnum;
	if (/\d/.test(name)) {
		classnum = parseInt(name.match(/\d/)[0], 10) || 0;
		return '@{class-' + classnum + '-level}';
	} else if (/race/i.test(name)) {
		return '@{level}';
	} else {
		return '';
	}
}
/** Converts the 4 "old" feature lists into array of objecs for repeating_ability
 * 
 * @param {function([{}])} callback 
 * @param {function} errorcallback 
 * @param {string} section 
 */
function getAbilities(callback, errorcallback, section) {
	var done = _underscore2.default.once(function (param) {
		if (typeof callback === "function") {
			callback(param);
		}
	}),
	    notDone = _underscore2.default.once(function () {
		if (typeof errorcallback === "function") {
			errorcallback();
		} else {
			done();
		}
	});
	_exportsLoaderTASTheAaronSheet2.default.debug("at PFFeatures.getAbilities " + section);
	if (!section) {
		notDone();return;
	}
	getSectionIDs('repeating_' + section, function (ids) {
		var fields,
		    isSLA = 0;
		try {
			if (section === "npc-spell-like-abilities") {
				isSLA = 1;
			}
			if (_underscore2.default.size(ids)) {
				fields = SWUtils.cartesianAppend(['repeating_' + section + '_'], ids, migrateMap[section].LU);
				fields = fields.concat(["is_npc", "race", "class-0-name", "class-1-name", "class-2-name", "class-3-name", "class-4-name", "class-5-name"]);
				if (section === "npc-spell-like-abilities") {
					fields = fields.concat(["spellclass-0-level-total", "spellclass-1-level-total", "spellclass-2-level-total", "spellclass-0", "spellclass-1", "spellclass-2", "level", "npc-hd-num", "class-0-level", "class-1-level", "class-2-level", "class-3-level", "class-4-level", "class-5-level"]);
				}
				getAttrs(fields, function (v) {
					var abilities,
					    defaultClass = '',
					    isNPC = 0,
					    macrotextAttr = 'macro-text',
					    tempInt;
					try {
						isNPC = parseInt(v.is_npc, 10) || 0;
						if (migrateMap[section].hasNPCMacro && isNPC) {
							macrotextAttr = 'npc-macro-text';
						}
						defaultClass = migrateMap[section].classDefault || '';
						abilities = _underscore2.default.map(ids, function (id) {
							var prefix, obj;
							try {
								prefix = 'repeating_' + section + '_' + id + '_';
								obj = _underscore2.default.reduce(migrateMap[section].copyAttrs, function (m, attr) {
									m[attr] = v[prefix + attr] || '';
									return m;
								}, {});
								obj['CL-basis'] = defaultClass || convertNameToLevel(v[prefix + 'class-number']);
								if (obj['CL-basis']) {
									if (obj['CL-basis'] === "@{level}") {
										obj["class-name"] = v['race'];
									} else if (v[prefix + 'class-number']) {
										_exportsLoaderTASTheAaronSheet2.default.debug("setting class-name to " + v[prefix + 'class-number'] + " value is " + v[v[prefix + 'class-number']]);
										obj["class-name"] = v[v[prefix + 'class-number']];
									} else {
										obj["class-name"] = "";
									}
								} else {
									obj["class-name"] = "";
								}
								if (isSLA) {
									obj["abil-sr"] = v[prefix + 'sr'] || '';
									if (v[prefix + 'level']) {
										tempInt = parseInt(v[prefix + 'level'], 10);
										if (!isNaN(tempInt)) {
											obj['spell_level-misc'] = tempInt;
											obj['spell_level-misc-mod'] = tempInt;
											obj['spell_level-basis'] = '0';
										}
									}
									if (v[prefix + 'range']) {
										tempInt = parseInt(v[prefix + 'range'], 10);
										obj['range_pick'] = 'number';
										if (!isNaN(tempInt)) {
											obj['range_numeric'] = tempInt;
										}
									}
									if (v[prefix + 'used']) {
										tempInt = parseInt(v[prefix + 'used'], 10);
										if (!isNaN(tempInt)) {
											obj['used_max'] = tempInt;
											obj['max-calculation'] = tempInt;
										}
									}
								}
								obj['macro-text'] = v[prefix + macrotextAttr] || '';
								obj['rule_category'] = migrateMap[section].ruleCategory;

								return obj;
							} catch (errorinner) {
								_exportsLoaderTASTheAaronSheet2.default.error("PFFeatures.getAbilities errorinner on " + id, errorinner);
							}
						});
					} catch (errmid) {
						_exportsLoaderTASTheAaronSheet2.default.error("PFFeatures.getAbilities errmid", errmid);
					} finally {
						if (_underscore2.default.size(abilities)) {
							done(abilities);
						} else {
							_exportsLoaderTASTheAaronSheet2.default.warn("PFFeatures.getAbilities none generated for " + section + " even though there are ids");
							notDone();
						}
					}
				});
			} else {
				done([]);
				return;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFFeatures.copyFeatsToAbilities", err);
			notDone();
		}
	});
}
function copyToAbilities(callback, section, eventInfo) {
	var done = _underscore2.default.once(function (param) {
		var setter;
		if (eventInfo && /merge/i.test(eventInfo.sourceAttribute)) {
			setter = {};
			setter[eventInfo.sourceAttribute] = 0;
			setAttrs(setter, _PFConst2.default.silentParams);
		}
		if (typeof callback === "function") {
			callback(param);
		}
	}),
	    merged = _underscore2.default.once(function () {
		PFAbility.recalculate(function () {
			done();
			PFMenus.resetOneCommandMacro(section, false);
			PFMenus.resetOneCommandMacro(section, true);
		}, true, 0);
	});
	_exportsLoaderTASTheAaronSheet2.default.debug("at PFFeatures.copyToAbilities:" + section);
	getAbilities(function (list) {
		_exportsLoaderTASTheAaronSheet2.default.debug("PFFeatures.copyToAbilities returned from get Abilities list is: ", list);
		if (list && _underscore2.default.size(list) > 0) {
			_exportsLoaderTASTheAaronSheet2.default.debug("now calling PFAbilitycopytoAbilities");
			PFAbility.copyToAbilities(merged, list);
		} else {
			done();
		}
	}, function () {
		_exportsLoaderTASTheAaronSheet2.default.error("PFFeatures ################# error trying to migrate " + section);
		done();
	}, section);
}
function setNewDefaults(callback, section) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFFeatures.setNewDefaults");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    sectionToDefaultRuleCategoryMap = {
		'feat': 'feats',
		'trait': 'traits',
		'racial-trait': 'racial-traits',
		'mythic-ability': 'mythic-abilities',
		'mythic-feat': 'mythic-feats',
		'class-ability': 'class-features',
		'npc-spell-like-abilities': 'spell-like-abilities'
	},
	    defaultabilitytype,
	    defaultrulecategory,
	    defaultshow;
	defaultshow = section === 'class-abilities' || section === 'npc-spell-like-abilities' ? '1' : '0';
	defaultabilitytype = section === 'npc-spell-like-abilities' ? 'Sp' : 'not-applicable';
	defaultrulecategory = sectionToDefaultRuleCategoryMap[section] || '';
	getSectionIDs('repeating_' + section, function (ids) {
		var setter = {};
		try {
			setter = _underscore2.default.reduce(ids, function (m, id) {
				var prefix = 'repeating_' + section + '_' + id + '_';
				try {
					m[prefix + 'showinmenu'] = defaultshow;
					m[prefix + 'ability_type'] = defaultabilitytype;
					m[prefix + 'rule_category'] = defaultrulecategory;
				} catch (errin) {
					_exportsLoaderTASTheAaronSheet2.default.error("PFFeatures.setNewDefaults error " + section + " id " + id, errin);
				} finally {
					return m;
				}
			}, {});
			setter['migrated_featurelists_defaults'] = 1;
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFFeatures.setNewDefaults error setting defaults for " + section, err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				setAttrs(setter, _PFConst2.default.silentParams, done);
			} else {
				done();
			}
		}
	});
}
function migrateRepeatingMacros(callback) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFFeatures.migrateRepeatingMacros");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    doneOne = _underscore2.default.after(_underscore2.default.size(featureLists), function () {
		setAttrs({ 'migrated_feature_macrosv109': 1 }, _PFConst2.default.silentParams, done);
	});
	_underscore2.default.each(featureLists, function (section) {
		var defaultName = '',
		    defaultMacro = '';
		try {
			defaultName = defaultMacroMap[section] || 'default';
			defaultMacro = defaultMacros[defaultName];
			if (!defaultMacro) {
				_exportsLoaderTASTheAaronSheet2.default.error("cannot find default macro for section " + section);
				doneOne();
				return;
			}
			PFMacros.migrateRepeatingMacros(doneOne, section, 'macro-text', defaultMacro.defaultRepeatingMacro, defaultMacro.defaultRepeatingMacroMap, defaultMacro.defaultDeletedArray, '@{PC-Whisper}');
			if (section === 'feat' || section === 'racial-trait') {
				PFMacros.migrateRepeatingMacros(null, section, 'npc-macro-text', defaultMacro.defaultRepeatingMacro, defaultMacro.defaultRepeatingMacroMap, defaultMacro.defaultDeletedArray, '@{NPC-Whisper}');
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFFeatures.migrateRepeatingMacros error setting up " + section, err);
			doneOne();
		}
	});
}
function migrate(callback, oldversion) {
	var done = function done() {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFFeatures.migrate");
		if (typeof callback === "function") {
			callback();
		}
	},
	    afterNewDefaults = function afterNewDefaults() {
		getAttrs(['migrated_feature_macrosv109'], function (v) {
			if (!parseInt(v.migrated_feature_macrosv109, 10)) {
				migrateRepeatingMacros(done);
			} else {
				done();
			}
		});
	},
	    numLists = _underscore2.default.size(featureLists),
	    doneOne = _underscore2.default.after(numLists, afterNewDefaults);
	//TAS.debug"at PFFeatures.migrate");
	getAttrs(['migrated_featurelists_defaults'], function (vm) {
		var featuremigrated = 0,
		    abilitymigrated = 0;
		featuremigrated = parseInt(vm['migrated_featurelists_defaults'], 10) || 0;
		//so current beta is not screwed up:
		if (!featuremigrated) {
			_underscore2.default.each(featureLists, function (section) {
				setNewDefaults(doneOne, section);
			});
		} else {
			afterNewDefaults();
		}
	});
}
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.info("leaving PFFeatures.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    numLists,
	    doneWithList,
	    calculateMaxUses,
	    callRecalcSLAs;
	try {
		//TAS.debug("at PFFeatures.recalculate");
		numLists = _underscore2.default.size(_PFConst2.default.repeatingMaxUseSections);
		doneWithList = _underscore2.default.after(numLists, function () {
			resetCommandMacro(done);
		});
		calculateMaxUses = function calculateMaxUses() {
			_underscore2.default.each(_PFConst2.default.repeatingMaxUseSections, function (section) {
				recalculateRepeatingMaxUsed(section, _exportsLoaderTASTheAaronSheet2.default.callback(doneWithList), silently);
			});
		};
		migrate(_exportsLoaderTASTheAaronSheet2.default.callback(calculateMaxUses), oldversion);
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("PFFeatures.recalculate, ", err);
		done();
	}
}
function registerEventHandlers() {
	var tempstr = "";

	on("change:merge_traits_now change:merge_race_traits_now change:merge_feats_now change:merge_class_features_now change:merge_slas_now", _exportsLoaderTASTheAaronSheet2.default.callback(function eventMergeOldList(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			getAttrs([eventInfo.sourceAttribute], function (v) {
				if (parseInt(v[eventInfo.sourceAttribute], 10)) {
					copyToAbilities(null, migrateButtonMap[eventInfo.sourceAttribute], eventInfo);
				}
			});
		}
	}));
	//GENERIC REPEATING LISTS USED MAX
	_underscore2.default.each(_PFConst2.default.repeatingMaxUseSections, function (section) {
		var maxEvent = "change:repeating_" + section + ":max-calculation";
		on(maxEvent, _exportsLoaderTASTheAaronSheet2.default.callback(function eventRepeatingMaxUseSections(eventInfo) {
			_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
			SWUtils.evaluateAndSetNumber("repeating_" + section + "_max-calculation", "repeating_" + section + "_used_max");
		}));
	});
	on("change:mythic-adventures-show change:use_traits change:use_racial_traits change:use_class_features change:use_feats change:use_spell-like-abilities", _exportsLoaderTASTheAaronSheet2.default.callback(function eventEnableMythicConfig(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			resetTopCommandMacro(null, eventInfo);
		}
	}));
	_underscore2.default.each(featureLists, function (section) {
		var macroEvent = "remove:repeating_" + section + " ",
		    singleEvent = "change:repeating_" + section + ":";
		macroEvent = _underscore2.default.reduce(events.commandMacroFields, function (m, a) {
			m += singleEvent + a + " ";
			return m;
		}, macroEvent);
		on(macroEvent, _exportsLoaderTASTheAaronSheet2.default.callback(function eventRepeatingCommandMacroUpdate(eventInfo) {
			var attr;
			attr = SWUtils.getAttributeName(eventInfo.sourceAttribute);
			if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api" || eventInfo.sourceType === "sheetworker" && attr === 'used_max') {
				attr = 'repeating_' + section + '_showinmenu';
				getAttrs([attr, 'is_npc'], function (v) {
					var isNPC = parseInt(v.is_npc, 10) || 0;
					if (parseInt(v[attr], 10) === 1) {
						PFMenus.resetOneCommandMacro(section, isNPC);
					}
				});
			}
		}));
	});
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFFeatures module loaded       ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.migrateRepeatingMacros = migrateRepeatingMacros;
exports.resetCommandMacro = resetCommandMacro;
exports.updateRepeatingItems = updateRepeatingItems;
exports.createAttackEntryFromRow = createAttackEntryFromRow;
exports.updateAssociatedAttack = updateAssociatedAttack;
exports.getEquipmentTypeFromName = getEquipmentTypeFromName;
exports.importFromCompendium = importFromCompendium;
exports.setNewDefaults = setNewDefaults;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFMacros = __webpack_require__(10);

var PFMacros = _interopRequireWildcard(_PFMacros);

var _PFMenus = __webpack_require__(14);

var PFMenus = _interopRequireWildcard(_PFMenus);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

var _PFDefense = __webpack_require__(13);

var PFDefense = _interopRequireWildcard(_PFDefense);

var _PFAttackOptions = __webpack_require__(12);

var PFAttackOptions = _interopRequireWildcard(_PFAttackOptions);

var _PFAttackGrid = __webpack_require__(7);

var PFAttackGrid = _interopRequireWildcard(_PFAttackGrid);

var _PFAttacks = __webpack_require__(8);

var PFAttacks = _interopRequireWildcard(_PFAttacks);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var wornEquipBaseRowsOld = ["Belt", "Body", "Chest", "Eyes", "Feet", "Hands", "Head", "Headband", "Neck", "Ring1", "Ring2", "Shoulders", "Wrist"],
    wornEquipBaseRowsNew = wornEquipBaseRowsOld.concat(["Armor3", "Shield3"]),
    wornEquipmentRowsNew = _underscore2.default.map(wornEquipBaseRowsNew, function (row) {
    return 'worn-' + row;
}),
    wornEquipmentRowRollsNew = _underscore2.default.map(wornEquipBaseRowsNew, function (row) {
    return 'worn-' + row + '-roll';
}),
    locationNames = ["Armor", "Belt", "Body", "Chest", "Eyes", "Feet", "Hands", "Head", "Headband", "Neck", "Ring1", "Ring2", "Shield", "Shoulders", "Wrist"],
    wornEquipmentRowsPlusCarried = ["Carried", "NotCarried"].concat(locationNames),
    locationMap = { 'Carried': 0, 'NotCarried': 1, 'Armor': 2, 'Belt': 3, 'Body': 4, 'Chest': 5, 'Eyes': 6, 'Feet': 7, 'Hands': 8,
    'Head': 9, 'Headband': 10, 'Neck': 11, 'Ring1': 12, 'Ring2': 13, 'Shield': 14, 'Shoulders': 15, 'Wrist': 16 },
    equipMap = { 'noEquipType': 0, 'Weapon': 1, 'Armor': 2, 'Ammo': 3, 'Consumables': 4, 'OtherMagic': 5, 'Gear': 6, 'Other': 7, 'Charged': 8, 'Other2': 9 },
    groupMapForMenu = { 0: '', 1: 'weapons', 2: 'armor-shield', 3: 'ammunition', 4: 'consumables', 5: 'other-magic-items', 6: 'gear-tool', 7: 'other-items', 8: 'charged-magics', 9: 'other-items-2' },
    wornEquipmentColumns = ["charges", "weight", "hp", "hp_max", "value"],
    wornLocTab = -1,
    totaledFields = { 'value': 1, 'hp': 1, 'weight': 1 },
    commonLinkedAttributes = ["attack-type", "range", "masterwork", "crit-target", "crit-multiplier", "damage-dice-num", "damage-die", "damage", "precision_dmg_macro", "precision_dmg_type", "critical_dmg_macro", "critical_dmg_type"],
    defaultRepeatingMacro = '&{template:pf_block} @{toggle_accessible_flag} @{toggle_rounded_flag} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_block-item}}} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=@{name}}} {{hasuses=@{has_uses}}} {{qty=@{qty}}} {{qtymax=@{qty_max}}} {{shortdesc=@{short-description}}} {{description=@{description}}}',
    defaultRepeatingMacroMap = {
    '&{template:': { 'current': 'pf_block}' },
    '@{toggle_rounded_flag}': { 'current': '@{toggle_rounded_flag}' },
    '@{toggle_accessible_flag}': { 'current': '@{toggle_accessible_flag}' },
    '{{color=': { 'current': '@{rolltemplate_color}}}' },
    '{{header_image=': { 'current': '@{header_image-pf_block-item}}}', old: ['header_image-pf_block}}}'] },
    '{{name=': { 'current': '@{name}}}' },
    '{{character_name=': { 'current': '@{character_name}}}' },
    '{{character_id=': { 'current': '@{character_id}}}' },
    '{{subtitle}}': { 'current': '{{subtitle}}' },
    '{{hasuses=': { 'current': '@{has_uses}}}' },
    '{{qty=': { 'current': '@{qty}}}' },
    '{{qty_max=': { 'current': '@{qty_max}}}' },
    '{{shortdesc=': { 'current': '@{short-description}}}' },
    '{{description=': { 'current': '@{description}}}', old: ['@{short-description}}}'] }
},
    defaultDeletedMacroAttrs = [];

function migrateRepeatingMacros(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.resetCommandMacro: ");
        if (typeof callback === "function") {
            callback();
        }
    }),
        migrated = function migrated() {
        setAttrs({ 'migrated_item_macrosv1': 1 }, _PFConst2.default.silentParams, done);
    };
    getAttrs(['migrated_item_macrosv1'], function (v) {
        if (!parseInt(v.migrated_item_macros, 10)) {
            PFMacros.migrateRepeatingMacros(migrated, 'item', 'macro-text', defaultRepeatingMacro, defaultRepeatingMacroMap, defaultDeletedMacroAttrs);
        } else {
            done();
        }
    });
}
/** resetCommandMacro sets command button macro with all rows from one ability list.
 * calls PFMenus.getRepeatingCommandMacro
 * sets the returned string to macro with attribute name: section+"_buttons_macro"
 *@param {function} callback  when done
 */
function resetCommandMacro(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.resetCommandMacro: ");
        if (typeof callback === "function") {
            callback();
        }
    }),
        doneOne = _underscore2.default.after(2, done);
    PFMenus.resetOneCommandMacro('item', true, doneOne, '', groupMapForMenu);
    PFMenus.resetOneCommandMacro('item', false, doneOne, '', groupMapForMenu);
}
/** Gets the worn item grid row name corresponding to location number in dropdown
 *@param {int} location a value from repeating_item_$X_location
 *@returns {string} name of "worn-space" to set
 */
function getWornItemNameField(location) {
    var wornSlot = "";
    if (location > 1 && wornEquipmentRowsPlusCarried[location]) {
        //TAS.debug("getWornItemNameField at location:" + wornEquipmentRowsPlusCarried[location]);
        if (location !== locationMap.Armor && location !== locationMap.Shield) {
            wornSlot = "worn-" + wornEquipmentRowsPlusCarried[location];
        } else if (location === locationMap.Armor) {
            wornSlot = "armor3";
        } else if (location === locationMap.Shield) {
            wornSlot = "shield3";
        }
    }
    return wornSlot;
}
/** updateRepeatingItems totals columns 
 *@param {function} callback to call when done
 *@param {bool} silently if true send PFConst.silentParams to setAttrs
 */
function updateRepeatingItems(callback, silently, attrToUpdate) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    try {
        if (!attrToUpdate) {
            attrToUpdate = totaledFields;
        }
        //TAS.debug("at updateRepeatingItems");
        _exportsLoaderTASTheAaronSheet2.default.repeating('item').attrs('item_total_weight', 'item-total-hp', 'item-total-hp_max', 'item-total-value').fields('item-weight', 'qty', 'qty_max', 'location', 'item-hp', 'item-hp_max', 'value').reduce(function (m, r) {
            try {
                //TAS.debug("in weight add row, variables: weight: "+r.F['item-weight']+", qty:"+r.I.qty+", max:"+r.I.qty_max +", loc:"+ r.I.location);
                if (r.I.qty > 0) {
                    if (r.I.qty_max === 0 || r.I.qty_max === 1) {
                        if (attrToUpdate.weight && r.I.location !== locationMap.NotCarried) {
                            m['item-weight'] += r.F['item-weight'] * r.I.qty;
                        }
                        if (attrToUpdate.value) {
                            m.value += r.I.value * r.I.qty;
                        }
                        if (attrToUpdate.hp) {
                            m['item-hp'] += r.I['item-hp'] * r.I.qty;
                            m['item-hp_max'] += r.I['item-hp_max'] * r.I.qty;
                        }
                    } else {
                        if (attrToUpdate.weight && r.I.location !== locationMap.NotCarried) {
                            m['item-weight'] += r.F['item-weight'];
                        }
                        if (attrToUpdate.value) {
                            m.value += r.I.value;
                        }
                        if (attrToUpdate.hp) {
                            m['item-hp'] += r.I['item-hp'];
                            m['item-hp_max'] += r.I['item-hp_max'];
                        }
                    }
                }
            } catch (errinner) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateRepeatingItems inner error", errinner);
            } finally {
                return m;
            }
        }, {
            'item-weight': 0,
            'item-hp': 0,
            'item-hp_max': 0,
            'value': 0
        }, function (m, r, a) {
            if (attrToUpdate.weight) {
                a.S['item_total_weight'] = m['item-weight'];
            }
            if (attrToUpdate.hp) {
                a.S['item-total-hp'] = m['item-hp'];
                a.S['item-total-hp_max'] = m['item-hp_max'];
            }
            if (attrToUpdate.value) {
                a.S['item-total-value'] = m.value;
            }
        }).execute(done);
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateRepeatingItems", err);
        done();
    }
}
/** updateCarriedCurrency  totals weight for carried currency 
 *@param {function} callback to call when done
 *@param {bool} silently if true send PFConst.silentParams to setAttrs
 */
function updateCarriedCurrency(callback, silently) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    };
    getAttrs(["CP", "SP", "GP", "PP", "carried-currency"], function (v) {
        var curr = parseInt(v["carried-currency"], 10) || 0,
            params = {},
            carried = 0;
        try {
            carried = ((parseInt(v["CP"], 10) || 0) + (parseInt(v["SP"], 10) || 0) + (parseInt(v["GP"], 10) || 0) + (parseInt(v["PP"], 10) || 0)) / 50;
            //TAS.debug("curr=" + curr + ", carried=" + carried);
            if (curr !== carried) {
                if (silently) {
                    params = _PFConst2.default.silentParams;
                }
                setAttrs({
                    "carried-currency": carried
                }, params, done);
            } else {
                done();
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateCarriedCurrency", err);
            done();
        }
    });
}
/** updateCarriedTotal- updates the total for carried weight
 *@param {function} callback to call when done
 *@param {bool} silently if true send PFConst.silentParams to setAttrs
 */
function updateCarriedTotal(callback, silently) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    };
    getAttrs(["carried-currency", "item_total_weight", "carried-misc", "carried-total"], function (v) {
        var curr,
            carried,
            params = {};
        try {
            curr = parseFloat(v["carried-total"], 10) || 0;
            carried = ((parseFloat(v["carried-currency"], 10) || 0) * 100 + (parseFloat(v["item_total_weight"], 10) || 0) * 100 + (parseFloat(v["carried-misc"], 10) || 0) * 100) / 100; // Fix bad javascript math
            //TAS.debug("curr=" + curr + ", carried=" + carried);
            if (curr !== carried) {
                setAttrs({
                    "carried-total": carried
                }, params, done);
            } else {
                done();
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateCarriedTotal", err);
            done();
        }
    });
}
/** Got rid of the Worn Equipment section, so migrate any values to the Equipment as repeating entries.
 * Worn Armor & Worn Shield are now disabled and controlled by the Equipment section in the Inventory tab.
 *@param {function} callback to call when done
 *@param {bool} silently if true send PFConst.silentParams to setAttrs
 */
function migrateWornEquipment(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.migrateWornEquipment");
        if (typeof callback === "function") {
            callback();
        }
    }),
        doneMigrating = _underscore2.default.once(function () {
        setAttrs({ "migrated_worn_equipment": "1" }, {}, done);
    }),
        copyWornEquipmentToNewItem = function copyWornEquipmentToNewItem(row, callback) {
        var done = _underscore2.default.once(function () {
            _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.copyWornEquipmentToNewItem for " + row);
            if (typeof callback === "function") {
                callback();
            }
        }),
            attribList = ["worn-" + row];
        attribList.push("worn-" + row + "-description");
        attribList.push("worn-" + row + "-hardness");
        _underscore2.default.each(wornEquipmentColumns, function (col) {
            attribList.push("worn-" + row + "-" + col);
        });
        getAttrs(attribList, function (v) {
            var newRowId = '',
                newRowAttrs = {},
                weightRowAttrs = {},
                attrib = "",
                newLocation = 0,
                newEquipType = equipMap.noEquipType;
            // Migrate the worn equipment entry to equipment if the name is populated
            try {
                _exportsLoaderTASTheAaronSheet2.default.debug("PFInventory.copyWornEquipmentToNewItem checking " + row + " it is:" + v["worn-" + row]);
                if (v["worn-" + row]) {
                    newRowId = generateRowID();
                    /* Assign defined worn equipment values to new repeating_item entry */
                    newRowAttrs["repeating_item_" + newRowId + "_name"] = v["worn-" + row];
                    newRowAttrs["repeating_item_" + newRowId + "_row_id"] = newRowId;
                    attrib = v["worn-" + row + "-description"];
                    if (attrib) {
                        newRowAttrs["repeating_item_" + newRowId + "_short-description"] = attrib;
                    }
                    attrib = v["worn-" + row + "-charges"];
                    if (attrib) {
                        newRowAttrs["repeating_item_" + newRowId + "_qty"] = attrib;
                        newRowAttrs["repeating_item_" + newRowId + "_qty_max"] = v["worn-" + row + "-charges_max"] || 50;
                    } else {
                        weightRowAttrs["repeating_item_" + newRowId + "_qty"] = 1;
                        weightRowAttrs["repeating_item_" + newRowId + "_qty_max"] = 1;
                    }
                    attrib = v["worn-" + row + "-weight"];
                    if (attrib) {
                        weightRowAttrs["repeating_item_" + newRowId + "_item-weight"] = attrib;
                    }
                    attrib = v["worn-" + row + "-hardness"];
                    if (attrib) {
                        weightRowAttrs["repeating_item_" + newRowId + "_hardness"] = attrib;
                    }
                    attrib = v["worn-" + row + "-hp"];
                    if (attrib) {
                        weightRowAttrs["repeating_item_" + newRowId + "_item-hp"] = attrib;
                    }
                    attrib = v["worn-" + row + "-hp_max"];
                    if (attrib) {
                        newRowAttrs["repeating_item_" + newRowId + "_item-hp_max"] = attrib;
                    }
                    attrib = v["worn-" + row + "-value"];
                    if (attrib) {
                        weightRowAttrs["repeating_item_" + newRowId + "_value"] = attrib;
                    }
                    newRowAttrs["worn-" + row + "-roll"] = "@{repeating_item_" + newRowId + "_macro-text}";
                    // Location
                    newLocation = locationMap[row];
                    //wornEquipmentRowsPlusCarried.indexOf(row);
                    newRowAttrs["repeating_item_" + newRowId + "_location"] = newLocation;
                    newRowAttrs["repeating_item_" + newRowId + "_old_location"] = newLocation;
                    if (newLocation > locationMap.NotCarried) {
                        newRowAttrs["repeating_item_" + newRowId + "_loctype-tab"] = locationMap.Carried;
                    } else {
                        newRowAttrs["repeating_item_" + newRowId + "_loctype-tab"] = newLocation;
                    }

                    newEquipType = equipMap.OtherMagic;
                    newRowAttrs["repeating_item_" + newRowId + "_equip-type"] = newEquipType;
                    newRowAttrs["repeating_item_" + newRowId + "_equiptype-tab"] = newEquipType;
                }
            } catch (err) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.copyWornEquipmentToNewItem", err);
            } finally {
                //TAS.debug("PFInventory.migrateWornEquipment.copyWornEquipmentToNewItem setting:",newRowAttrs);
                if (_underscore2.default.size(newRowAttrs) > 0) {
                    setAttrs(newRowAttrs, _PFConst2.default.silentParams, done);
                } else {
                    done();
                }
                //weight, hardness, qty are set non silently to trigger recalc
                if (_underscore2.default.size(weightRowAttrs) > 0) {
                    setAttrs(weightRowAttrs);
                }
            }
        });
    },

    // Migrate the armor & worn shield entries to equipment if the name is populated
    //item: value from PFDefense.defenseArmorShieldRowsOld
    copyWornDefenseToNewItem = function copyWornDefenseToNewItem(item, wornAlreadySet, callback) {
        var done = _underscore2.default.once(function (wasSetToWorn) {
            _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.copyWornDefenseToNewItem did we set worn for " + item + "?: " + wasSetToWorn);
            if (typeof callback === "function") {
                callback(wasSetToWorn);
            }
        }),
            attribList = [item, item + "-type"],
            defenseName = "",
            isArmor = 0,
            isShield = 0;

        //armor or shield?
        if (/armor/i.test(item)) {
            isArmor = 1;
        } else if (/shield/i.test(item)) {
            isShield = 1;
        } else {
            done(0);
            return;
        }
        // Search for pre-existing matching entry in equipment
        getAttrs([item], function (vi) {
            //TAS.debug("vi[item]=" + vi[item]);
            if (!vi[item]) {
                done(0);
                return;
            }
            defenseName = vi[item];
            getSectionIDs("repeating_item", function (ids) {
                //TAS.debug("ids=" + ids);
                var fields = [];
                fields = _underscore2.default.map(ids, function (id) {
                    return "repeating_item_" + id + "_name";
                });
                _underscore2.default.each(PFDefense.defenseArmorShieldColumns, function (column) {
                    attribList.push(item + "-" + column);
                });
                attribList = attribList.concat(fields);
                //TAS.debug("copyWornDefenseToNewItem attribList=" + attribList);
                getAttrs(attribList, function (v) {
                    var prefix,
                        matchingField,
                        newRowId = '',
                        newRowAttrs = {},
                        locationAttrs = {},
                        maxDex = 0,
                        attrib = "",
                        isNewRow = true,
                        markedEquipped = 0,
                        isWorn = 0;
                    try {
                        //TAS.debug("PFInventory.copyWornDefenseToNewItem item:"+item+" was already set="+wornAlreadySet,v);
                        markedEquipped = parseInt(v[item + "-equipped"], 10) || 0;
                        maxDex = parseInt(v[item + "-max-dex"], 10);
                        if (isNaN(maxDex)) {
                            maxDex = 99;
                        }
                        matchingField = _underscore2.default.find(fields, function (field) {
                            return defenseName === v[field];
                        });
                        //TAS.debug("matchingField=" + matchingField);
                        if (matchingField) {
                            isNewRow = false;
                            newRowId = SWUtils.getRowId(matchingField);
                        } else {
                            newRowId = generateRowID();
                        }
                        newRowAttrs["repeating_item_" + newRowId + "_equip-type"] = equipMap.Armor;
                        newRowAttrs["repeating_item_" + newRowId + "_equiptype-tab"] = equipMap.Armor;
                        /* Assign defined worn equipment values to new repeating_item entry */
                        if (isNewRow) {
                            newRowAttrs["repeating_item_" + newRowId + "_name"] = defenseName;
                        }
                        newRowAttrs["repeating_item_" + newRowId + "_qty"] = 1;
                        newRowAttrs["repeating_item_" + newRowId + "_qty_max"] = 1;
                        if (!wornAlreadySet && markedEquipped === 1) {
                            isWorn = 1;
                            if (isArmor) {
                                if (isNewRow) {
                                    newRowAttrs["repeating_item_" + newRowId + "_location"] = locationMap.Armor;
                                    newRowAttrs["repeating_item_" + newRowId + "_old_location"] = locationMap.Armor;
                                } else {
                                    locationAttrs["repeating_item_" + newRowId + "_location"] = locationMap.Armor;
                                }
                                newRowAttrs["repeating_item_" + newRowId + "_loctype-tab"] = locationMap.Carried;
                                newRowAttrs["armor3-roll"] = "@{repeating_item_" + newRowId + "_macro-text}";
                                newRowAttrs["armor3"] = v[item];
                            } else {
                                if (isNewRow) {
                                    newRowAttrs["repeating_item_" + newRowId + "_location"] = locationMap.Shield;
                                    newRowAttrs["repeating_item_" + newRowId + "_old_location"] = locationMap.Shield;
                                } else {
                                    locationAttrs["repeating_item_" + newRowId + "_location"] = locationMap.Shield;
                                }
                                newRowAttrs["repeating_item_" + newRowId + "_loctype-tab"] = locationMap.Carried;
                                newRowAttrs["shield3-roll"] = "@{repeating_item_" + newRowId + "_macro-text}";
                                newRowAttrs["shield3"] = v[item];
                            }
                            //set to blank
                            if (maxDex > 50) {
                                newRowAttrs[item + "-max-dex"] = "-";
                            }
                        } else {
                            //do not need to put in locationAttrs since we set it something last time we came through for other row
                            newRowAttrs["repeating_item_" + newRowId + "_location"] = locationMap.NotCarried; // not Carried
                            newRowAttrs["repeating_item_" + newRowId + "_old_location"] = locationMap.NotCarried;
                            newRowAttrs["repeating_item_" + newRowId + "_loctype-tab"] = locationMap.NotCarried;

                            //ensure it is not marked equipped
                            if (markedEquipped) {
                                newRowAttrs[item + "-equipped"] = 0;
                            }
                            // Leave the entry there. The player can manage the entry from inventory and equip it on Defenses tab
                        }
                        //do not set type, max-dex, or equipped, but do all other columns:
                        _underscore2.default.each(["acbonus", "enhance", "acp", "spell-fail", "proficiency"], function (col) {
                            attrib = v[item + "-" + col];
                            if (attrib) {
                                newRowAttrs["repeating_item_" + newRowId + "_item-" + col] = attrib;
                            }
                        });

                        if (maxDex > 50) {
                            newRowAttrs["repeating_item_" + newRowId + "_item-max-dex"] = "-";
                        } else {
                            newRowAttrs["repeating_item_" + newRowId + "_item-max-dex"] = maxDex;
                        }

                        attrib = v[item + "-type"];
                        if (attrib) {
                            newRowAttrs["repeating_item_" + newRowId + "_item-defense-type"] = attrib;
                        }
                    } catch (err) {
                        _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.copyWornDefenseToNewItem", err);
                    } finally {
                        if (_underscore2.default.size(newRowAttrs) > 0) {
                            //TAS.debug("PFInventory.copyWornDefenseToNewItem item:"+item+",setting:",newRowAttrs);
                            setAttrs(newRowAttrs, _PFConst2.default.silentParams, function () {
                                if (_underscore2.default.size(locationAttrs) > 0) {
                                    setAttrs(locationAttrs, {}, function () {
                                        done(isWorn);
                                    });
                                } else {
                                    done(isWorn);
                                }
                            });
                        } else {
                            done(false);
                        }
                    }
                });
            });
        });
    };
    //TAS.debug("############","at PFInventory.migrateWornEquipment");
    getAttrs(["migrated_worn_equipment"], function (v) {
        var foundWornArmor = false,
            foundWornShield = false,
            doneAll = _underscore2.default.after(2, function () {
            //TAS.debug("#### PFInventory.migrateWornEquipment.doneAll 2");
            doneMigrating();
        }),
            migrateDefenses = function migrateDefenses() {
            _exportsLoaderTASTheAaronSheet2.default.debug("checking armor3");
            copyWornDefenseToNewItem('armor3', foundWornArmor, function (wasSet) {
                foundWornArmor = foundWornArmor || wasSet;
                _exportsLoaderTASTheAaronSheet2.default.debug("checking armor2, found=" + foundWornArmor);
                copyWornDefenseToNewItem('armor2', foundWornArmor, function (wasSet) {
                    foundWornArmor = foundWornArmor || wasSet;
                    _exportsLoaderTASTheAaronSheet2.default.debug("checking armor0, found=" + foundWornArmor);
                    copyWornDefenseToNewItem('armor', foundWornArmor, doneAll);
                });
            });
            _exportsLoaderTASTheAaronSheet2.default.debug("checking shield3");
            copyWornDefenseToNewItem('shield3', foundWornShield, function (wasSet) {
                foundWornShield = foundWornShield || wasSet;
                _exportsLoaderTASTheAaronSheet2.default.debug("checking shield2, found=" + foundWornShield);
                copyWornDefenseToNewItem('shield2', foundWornShield, function (wasSet) {
                    foundWornShield = foundWornShield || wasSet;
                    _exportsLoaderTASTheAaronSheet2.default.debug("checking shield0, found=" + foundWornShield);
                    copyWornDefenseToNewItem('shield', foundWornShield, doneAll);
                });
            });
        },
            doneWornRows = _underscore2.default.after(_underscore2.default.size(wornEquipBaseRowsOld), function () {
            var wornRows, fieldsToClear, setter;
            try {
                wornRows = _underscore2.default.map(wornEquipBaseRowsOld, function (field) {
                    return 'worn-' + field + '-';
                });
                fieldsToClear = SWUtils.cartesianAppend(wornRows, ['charges', 'weight', 'hp', 'hp_max', 'value', 'description', 'hardness']);
                setter = _underscore2.default.reduce(fieldsToClear, function (m, f) {
                    m[f] = '';return m;
                }, {});
                setAttrs(setter, _PFConst2.default.silentParams, migrateDefenses);
            } catch (err) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.migrateWornEquipment.doneWornRows err:", err);
                migrateDefenses();
            }
        });
        try {
            //TAS.debug("PFInventory.migrateWornEquipment flag is ",v," and there are "+_.size(wornEquipBaseRowsOld)+" rows of worn equip");
            if (parseInt(v["migrated_worn_equipment"], 10) === 1) {
                //TAS.debug("##########","ALREADY MIGRATED WORN EQUIPMENT");
                done();
                return;
            }
            //do worn equipment rows before armor, because sometimes they have armor in a slot.
            _underscore2.default.each(wornEquipBaseRowsOld, function (row) {
                copyWornEquipmentToNewItem(row, doneWornRows);
            });
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.migrateWornEquipment", err);
            migrateDefenses();
        }
    });
}
/** set old location to the new location, and unset other items set to this location, also updates loctype-tab
 *@param {string} id id of row updated, or null
 *@param {function} callback to call when done
 *@param {boolean} silently if true call setAttrs with {silent:true}
 *@param {object} eventInfo USED - from event, to get id from sourceAttribute
 */
function updateEquipmentLocation(id, callback, silently, eventInfo) {
    var done = _underscore2.default.once(function () {
        //TAS.debug("leaving PFInventory.updateEquipmentLocation for id "+id);
        if (typeof callback === "function") {
            callback();
        }
    }),

    /* unsetOtherItems makes sure any other row than id is not in location */
    unsetOtherItems = function unsetOtherItems(location, id) {
        if (!id || location < 2 || !location) {
            done();
            return;
        }
        /*
        * The player has now changed the location to a worn slot, so check for other repeating items that have the same
        * slot and set them to 'carried'.
        */
        getSectionIDs("repeating_item", function (idarray) {
            // get the repeating set
            var attribs = [];
            if (_underscore2.default.size(idarray) <= 1) {
                done();
                return;
            }
            _underscore2.default.each(idarray, function (currentID, i) {
                // loop through the set
                if (currentID !== id) {
                    attribs.push("repeating_item_" + currentID + "_location");
                }
            });
            getAttrs(attribs, function (w) {
                var setter = {};
                _underscore2.default.each(idarray, function (currentID, i) {
                    // loop through the set
                    if ((parseInt(w["repeating_item_" + currentID + "_location"], 10) || 0) === location) {
                        setter["repeating_item_" + currentID + "_location"] = 0;
                        setter["repeating_item_" + currentID + "_old_location"] = 0;
                    }
                });
                if (_underscore2.default.size(setter) > 0) {
                    setAttrs(setter, { silent: true }, done);
                } else {
                    done();
                }
            });
        });
    },
        idStr = SWUtils.getRepeatingIDStr(id),
        item_entry = 'repeating_item_' + idStr,
        realItemID = id || (eventInfo ? SWUtils.getRowId(eventInfo.sourceAttribute) || "" : ""),
        prefix = 'repeating_item_' + realItemID + "_",
        locationField = prefix + "location",
        locationTabField = prefix + "loctype-tab",
        nameField = prefix + "name",
        oldLocationField = prefix + "old_location",
        rollField = prefix + "macro-text";
    try {
        //TAS.debug("updateEquipmentLocation: called for ID "+ realItemID);
        //sample source: repeating_item_-kbkc95wvqw1n4rbgs1c_location
        // note that the source is always lowercase, but the actual ID is both cases
        //check value of 'location' to see if it is being worn; if not check to see if the player is removing it from 'worn'
        //TAS.debug("updateEquipmentLocation source=" + source);
        getAttrs([locationField, oldLocationField, nameField, locationTabField], function (v) {
            var location = 0,
                oldlocation = 0,
                wornItemAttrs = {},
                wornSlot = "",
                itemName = "";
            //TAS.debug("updateEquipmentLocation: ", v);
            try {
                location = parseInt(v[locationField], 10);
                if (isNaN(location)) {
                    _exportsLoaderTASTheAaronSheet2.default.debug("why is location not set!?");
                    location = locationMap.NotCarried;
                    wornItemAttrs[locationField] = location;
                }
                if (location > locationMap.NotCarried) {
                    wornItemAttrs[locationTabField] = locationMap.Carried;
                } else {
                    wornItemAttrs[locationTabField] = location;
                }

                oldlocation = parseInt(v[oldLocationField], 10);
                if (isNaN(oldlocation)) {
                    oldlocation = location;
                }
                wornItemAttrs[oldLocationField] = location;
                if (location === locationMap.Carried && oldlocation !== locationMap.NotCarried && oldlocation !== location) {
                    wornSlot = getWornItemNameField(oldlocation);
                    if (wornSlot) {
                        wornItemAttrs[wornSlot] = "";
                        wornItemAttrs[wornSlot + "-roll"] = "";
                    }
                } else if (location > locationMap.NotCarried) {
                    wornSlot = getWornItemNameField(location);
                    if (wornSlot) {
                        itemName = v[nameField] || "";
                        if (itemName) {
                            wornItemAttrs[wornSlot] = itemName;
                        } else {
                            wornItemAttrs[wornSlot] = "Row " + realItemID;
                        }
                        wornItemAttrs[wornSlot + "-roll"] = "@{" + rollField + "}";
                    }
                    if (oldlocation > 1 && oldlocation !== location) {
                        wornSlot = getWornItemNameField(oldlocation);
                        if (wornSlot) {
                            wornItemAttrs[wornSlot] = "";
                            wornItemAttrs[wornSlot + "-roll"] = "";
                        }
                    }
                }
            } catch (err2) {
                _exportsLoaderTASTheAaronSheet2.default.error("updateEquipmentLocation update location error:", err2);
            } finally {
                if (_underscore2.default.size(wornItemAttrs) > 0) {
                    //TAS.debug("updateEquipmentLocation, setting slot ", wornItemAttrs);
                    setAttrs(wornItemAttrs, _PFConst2.default.silentParams, function () {
                        if (location > locationMap.NotCarried) {
                            unsetOtherItems(location, realItemID);
                        }
                        done();
                    });
                } else {
                    done();
                }
            }
        });
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateEquipmentLocation", err);
        done();
    }
}
/** replace the values on the Defenses tab in disabled fields with this row's values
 * from the equipment. Some fields like Armor Bonus, ACP, and Max Dex are not available in the equipment, so they
 * will need to be edited manually after making this change.
 *@param {int} location the value of location attribute in repeating_item
 *@param {string} sourceAttribute eventInfo sourceAttribute of change user made that called this
 *@param {function} callback call when done
 */
function updateWornArmorAndShield(location, sourceAttribute, callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.updateWornArmorAndShield");
        if (typeof callback === "function") {
            callback();
        }
    }),
        defenseItem = "",
        attribUpdated = "",
        itemFullPrefix = "",
        attribList = [],
        id = "",
        item_entry = "",
        itemFields = ["item-acbonus", "item-acenhance", "item-max-dex", "item-acp", "item-spell-fail", "item-defense-type", "item-proficiency", "name", "set-as-armor", "set-as-shield", "location", "old_location", "equip-type", "acenhance"];
    try {
        attribUpdated = SWUtils.getAttributeName(sourceAttribute);
        id = SWUtils.getRowId(sourceAttribute);
        item_entry = "repeating_item_" + id + "_";
        if (item_entry.slice(-1) !== "_") {
            item_entry += "_";
        }
        itemFullPrefix = item_entry + "item-";
        defenseItem = location === locationMap.Armor ? "armor3" : "shield3";
        //TAS.debug"at update worn armor, defenseItem=" + defenseItem);
        attribList = _underscore2.default.map(itemFields, function (attr) {
            return item_entry + attr;
        });
        attribList = _underscore2.default.reduce(PFDefense.defenseArmorShieldColumns, function (memo, col) {
            memo.push(defenseItem + "-" + col);
            return memo;
        }, attribList);
        attribList.push(defenseItem);
        //TAS.debug("PFInventory.updateWornArmorAndShield fields ", attribList);
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateWornArmorAndShield error before getattrs", err);
        done();
        return;
    }
    //TAS.debug("attribList=" + attribList);
    getAttrs(attribList, function (w) {
        var i = 0,
            setter = {},
            silentSetter = {},
            equipType = 0,
            actualLocation = 0,
            attrib = "";
        try {
            //if we are setting new, or updating an item in the location, or updating an item in a diffrent location
            //so we can set a new ring of shield, but not update it. but we can update armor and shields.
            if (attribUpdated === 'set-as-armor' || attribUpdated === 'set-as-shield' || location === locationMap.Armor || location === locationMap.Shield) {
                //TAS.debug("updateWornArmorAndShield ", w);
                for (i = 0; i < PFDefense.defenseArmorShieldColumns.length; i++) {
                    if (PFDefense.defenseArmorShieldColumns[i] !== "max-dex" && PFDefense.defenseArmorShieldColumns[i] !== "equipped" && PFDefense.defenseArmorShieldColumns[i] !== "type" && PFDefense.defenseArmorShieldColumns[i] !== "enhance") {
                        attrib = parseInt(w[itemFullPrefix + PFDefense.defenseArmorShieldColumns[i]], 10) || 0;
                        if (parseInt(w[defenseItem + "-" + PFDefense.defenseArmorShieldColumns[i]], 10) !== attrib) {
                            setter[defenseItem + "-" + PFDefense.defenseArmorShieldColumns[i]] = attrib;
                        }
                    }
                }
                attrib = w[item_entry + "name"];
                if (attrib) {
                    if (w[defenseItem] !== attrib) {
                        setter[defenseItem] = attrib;
                    }
                } else {
                    setter[defenseItem] = "";
                }
                attrib = w[itemFullPrefix + "acenhance"];
                if (attrib) {
                    setter[defenseItem + "-enhance"] = attrib;
                }
                attrib = w[itemFullPrefix + "defense-type"];
                if (attrib) {
                    if (defenseItem === "shield3" && attrib === "Medium") {
                        //invalid choice, prob meant heavy shield
                        attrib = "Heavy";
                    } else if (defenseItem === "armor3" && attrib === "Tower Shield") {
                        //invalid
                        attrib = "Heavy";
                    }
                    if (w[defenseItem + "-type"] !== attrib) {
                        setter[defenseItem + "-type"] = attrib;
                    }
                }
                attrib = parseInt(w[itemFullPrefix + "max-dex"], 10);
                if (w[itemFullPrefix + "max-dex"] === "-" || isNaN(attrib)) {
                    setter[defenseItem + "-max-dex"] = "-";
                } else {
                    setter[defenseItem + "-max-dex"] = attrib;
                }
                if (w[defenseItem + "-equipped"] !== "1") {
                    setter[defenseItem + "-equipped"] = 1;
                }
                //reset the buttons silently so we don't loop.
                attrib = parseInt(w[item_entry + "set-as-armor"], 10);
                if (attrib) {
                    silentSetter[item_entry + "set-as-armor"] = "0";
                }
                attrib = parseInt(w[item_entry + "set-as-shield"], 10);
                if (attrib) {
                    silentSetter[item_entry + "set-as-shield"] = "0";
                }
                //if we hit "set as armor or shield" on a peice of armor / shield equipment, make sure to slot it.
                //do it silently so we don't loop 
                equipType = parseInt(w[item_entry + "equip-type"], 10);
                actualLocation = parseInt(w[item_entry + "location"], 10);
                if (!isNaN(equipType) && actualLocation !== locationMap.Armor && actualLocation !== locationMap.Shield && equipType === equipMap.Armor && (attribUpdated === 'set-as-armor' || attribUpdated === 'set-as-shield')) {
                    silentSetter[item_entry + "old_location"] = actualLocation;
                    silentSetter[item_entry + "location"] = location;
                }
            } else {
                _exportsLoaderTASTheAaronSheet2.default.warning("no reason to update armor or shield for " + sourceAttribute + " in location " + wornEquipmentRowsPlusCarried[location]);
            }
        } catch (errinner) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateWornArmorAndShield INNER error", errinner);
        } finally {
            if (_underscore2.default.size(silentSetter) > 0) {
                setAttrs(silentSetter, _PFConst2.default.silentParams, function () {
                    if (actualLocation !== location) {
                        updateEquipmentLocation(id, null, true, null);
                    }
                });
            }
            if (_underscore2.default.size(setter) > 0) {
                //TAS.debug("updating defenses tab for " + defenseItem, setter);
                setAttrs(setter, {}, done);
            } else {
                done();
            }
        }
    });
}
/**  calls updateEquipmentLocation for all items
can be refactored to be faster to do all at once
 */
function updateLocations(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("Leaving PFInventory.updateLocations");
        if (typeof callback === "function") {
            callback();
        }
    });
    getSectionIDs('repeating_item', function (ids) {
        var total = 0,
            doneOne;
        try {
            if (!(ids && _underscore2.default.size(ids))) {
                done();
                return;
            }
            total = _underscore2.default.size(ids);
            _exportsLoaderTASTheAaronSheet2.default.debug("PFInventory.updateLocations there are " + total + " rows in items");
            doneOne = _underscore2.default.after(total, done);
            _underscore2.default.each(ids, function (id) {
                updateEquipmentLocation(id, doneOne, null, null);
            });
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateLocations", err);
            done();
        }
    });
}
/** Triggered from a button in repeating_items, it will create a repeating attack entry from the item entry
 * @param {string} source the eventItem.sourceAttribute
 * @param {string} weaponId if the row already exists, overwrite all fields but 'name'
 */
function createAttackEntryFromRow(source, callback, silently, weaponId) {
    var done = _underscore2.default.once(function () {
        //TAS.debug("leaving PFInventory.createAttackEntryFromRow");
        if (typeof callback === "function") {
            callback();
        }
    }),
        attribList = [],
        itemId = SWUtils.getRowId(source),
        idStr = SWUtils.getRepeatingIDStr(itemId),
        item_entry = 'repeating_item_' + idStr;

    _exportsLoaderTASTheAaronSheet2.default.debug("PFInventory.createAttackEntryFromRow: item_entry=" + item_entry + " , weapon:" + weaponId);
    attribList.push(item_entry + "name");
    commonLinkedAttributes.forEach(function (attr) {
        attribList.push(item_entry + "item-" + attr);
    });
    attribList.push(item_entry + "item-wpenhance");
    attribList.push(item_entry + "item-dmg-type");
    attribList.push(item_entry + "default_size");
    //TAS.debug("attribList=" + attribList);
    getAttrs(attribList, function (v) {
        var newRowId,
            setter = {},

        // silentSetter={},
        enhance = 0,
            prof = 0,
            params = silently ? PFUtils.silentParams : {};
        try {
            //TAS.debug("weaponId is :"+weaponId);
            if (!weaponId) {
                newRowId = generateRowID();
            } else {
                newRowId = weaponId;
            }
            _exportsLoaderTASTheAaronSheet2.default.debug("the new row id is: " + newRowId);
            //TAS.debug("v[" + item_entry + "name]=" + v[item_entry + "name"]);
            if (v[item_entry + "name"]) {
                if (!weaponId) {
                    setter["repeating_weapon_" + newRowId + "_name"] = v[item_entry + "name"];
                }
                setter["repeating_weapon_" + newRowId + "_source-item-name"] = v[item_entry + "name"];
            }
            commonLinkedAttributes.forEach(function (attr) {
                //TAS.debug("v[" + item_entry + "item-" + attr + "]=" + v[item_entry + "item-" + attr]);
                if (v[item_entry + "item-" + attr]) {
                    setter["repeating_weapon_" + newRowId + "_" + attr] = v[item_entry + "item-" + attr];
                }
            });
            if (/melee/i.test(v[item_entry + "item-attack_type"])) {
                setter["repeating_weapon_" + newRowId + "_damage-ability"] = "@{STR-mod}";
            }
            enhance = parseInt(v[item_entry + "item-wpenhance"], 10) || 0;
            if (enhance) {
                setter["repeating_weapon_" + newRowId + "_enhance"] = enhance;
            }
            //TAS.debug("v[" + item_entry + "item-defense-type]=" + v[item_entry + "item-defense-type"]);
            if (v[item_entry + "item-dmg-type"]) {
                setter["repeating_weapon_" + newRowId + "_type"] = v[item_entry + "item-dmg-type"];
            }
            //TAS.debug("v[" + item_entry + "item-proficiency]=" + v[item_entry + "item-proficiency"]);
            prof = parseInt(v[item_entry + "item-proficiency"], 10) || 0;
            if (prof !== 0) {
                prof = -4;
                setter["repeating_weapon_" + newRowId + "_proficiency"] = prof;
            }
            if (v[item_entry + "default_size"]) {
                setter["repeating_weapon_" + newRowId + "_default_size"] = v[item_entry + "default_size"];
            }
            setter["repeating_weapon_" + newRowId + "_default_damage-dice-num"] = v[item_entry + "damage-dice-num"] || 0;
            setter["repeating_weapon_" + newRowId + "_default_damage-die"] = v[item_entry + "damage-die"] || 0;
            setter["repeating_weapon_" + newRowId + "_source-item"] = itemId;
            setter["repeating_weapon_" + newRowId + '_link_type'] = PFAttacks.linkedAttackType.equipment;
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.createAttackEntryFromRow", err);
        } finally {
            if (_underscore2.default.size(setter) > 0) {
                setter[item_entry + "create-attack-entry"] = 0;
                _exportsLoaderTASTheAaronSheet2.default.debug("PFInventory.createAttackEntryFromRow creating new attack", setter);
                setAttrs(setter, params, function () {
                    //can do these in parallel
                    PFAttackOptions.resetOption(newRowId);
                    PFAttackGrid.resetCommandMacro();
                    done();
                });
                //if (_.size(silentSetter)){
                //    setAttrs(silentSetter,PFConst.silentParams);
                //}
            } else {
                setter[item_entry + "create-attack-entry"] = 0;
                setAttrs(setter, _PFConst2.default.silentParams, done);
            }
        }
    });
}
function updateAssociatedAttack(source, callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.updateAssociatedAttack");
        if (typeof callback === "function") {
            callback();
        }
    }),
        attrib = "",
        weaponAttrib = "",
        sourceVal = "",
        itemId = "",
        sectionName = "",
        fields = [],
        setter = {},
        attribList = [];
    try {
        if (!source) {
            done();
            return;
        }
        itemId = SWUtils.getRowId(source);
        attrib = SWUtils.getAttributeName(source);
        //TAS.debug("attrib=" + attrib);
        if (source.indexOf("repeating_weapon_") === 0) {
            // source is an attack, so pull all data from the source (item/spell/spell-like ability) to update the attack
            // attrib will be source-item, source-spell, or source-ability
            _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateAssociatedAttack, called on weapon event, no longer supported!");
            done();
            return;
        }
        // source is an item, so update all linked attacks with the changed attribute
        weaponAttrib = attrib.replace("item-", "");
        if (attrib === 'name') {
            weaponAttrib = 'source-item-name';
        } else if (attrib === 'item-dmg-type') {
            weaponAttrib = 'type';
        } else if (attrib === 'wpenhance') {
            weaponAttrib = 'enhance';
        }
    } catch (outererror1) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateAssociatedAttack outer1", outererror1);
        done();
        return;
    }
    getAttrs([source], function (srcv) {
        var sourceAttr = '';
        sourceVal = srcv[source];
        if (typeof sourceVal === "undefined") {
            sourceVal = "";
        }
        //TAS.debug"sourceVal=" + sourceVal);
        if (attrib === "proficiency") {
            sourceVal = parseInt(sourceVal, 10) || 0;
            if (sourceVal !== 0) {
                sourceVal = -4;
            }
        }
        sourceVal = String(sourceVal);
        //TAS.debug("itemId=" + itemId, "attrib=" + attrib, "weaponAttrib=" + weaponAttrib);
        getSectionIDs("repeating_weapon", function (idarray) {
            // get the repeating set
            fields = _underscore2.default.reduce(idarray, function (memo, currentID) {
                memo = memo.concat(["repeating_weapon_" + currentID + "_source-item", "repeating_weapon_" + currentID + "_" + weaponAttrib]);
                return memo;
            }, []);
            //TAS.debug("processing currentID=" + currentID);
            getAttrs(fields, function (w) {
                setter = {}; // start with a blank in this loop
                try {
                    //TAS.debug"PFInventory.updateAssociatedAttack ", w);
                    _underscore2.default.each(idarray, function (currentID) {
                        // loop through the set
                        var targetVal = "",
                            wField = ""; // start with blank in this loop
                        //TAS.debug("source=" + source, "v[repeating_weapon_" + currentID + "_source-item]=" + v["repeating_weapon_" + currentID + "_source-item"]);
                        //TAS.debug("itemId=" + itemId)
                        //TAS.debug"comparing " + itemId + " with " + w["repeating_weapon_" + currentID + "_source-item"]);
                        if (itemId === w["repeating_weapon_" + currentID + "_source-item"]) {
                            wField = "repeating_weapon_" + currentID + "_" + weaponAttrib;
                            targetVal = w[wField];
                            if (attrib === "proficiency") {
                                targetVal = parseInt(targetVal, 10) || 0;
                            }
                            targetVal = String(targetVal);
                            if (targetVal !== sourceVal) {
                                setter[wField] = sourceVal;
                                if (sourceAttr === 'damage-die' || sourceAttr === 'damage-dice-num') {
                                    setter["repeating_weapon_" + currentID + "_default_" + sourceAttr] = sourceVal;
                                }
                            }
                        }
                    });
                } catch (innererror) {
                    _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateAssociatedAttack inner1", innererror);
                } finally {
                    if (_underscore2.default.size(setter) > 0) {
                        //TAS.debug"updating attack", setter);
                        setAttrs(setter);
                    }
                }
            });
        });
    });
}
/** Determines the equipment type from looking at the name. 
 * DOES NOT WORK for armor or weapons, this is for after you have already determined it is not an armor or weapon type.
 *@param {string} name the name field 
 */
function getEquipmentTypeFromName(name) {
    var tempstr,
        currType = equipMap.noEquipType,
        matches;
    if (!name) {
        return currType;
    }
    tempstr = name.toLowerCase();
    matches = tempstr.match(/(?:\bwand\b|\bring\b|\brod\b|plate|sword|shield|mail|spear|potion|spellbook|smokestick|incense|scroll|alchemist|antitoxin|antidote|elixir|staff|acid|\boil\b|water|component pouch|arrow|bolt|bullet|sunrod|flask|ration|armor spike|kit|saddle|tool|spike|pole|ladder|lantern|candle|torch|rope|chain|crowbar|\bnet\b|\bram\b|tanglefoot|tinder|flint|vial)/i);
    if (matches) {
        switch (matches[0]) {
            case 'sword':
            case 'spear':
            case 'armor spike':
            case 'net':
                currType = equipMap.Weapon;
                break;
            case 'mail':
            case 'plate':
            case 'shield':
                currType = equipMap.Armor;
                break;
            case 'vial':
            case 'flint':
            case 'kit':
            case 'tool':
            case 'spike':
            case 'crowbar':
            case 'ram':
            case 'lantern':
            case 'candle':
            case 'torch':
            case 'rope':
            case 'chain':
            case 'saddle':
            case 'spyglass':
            case 'spellbook':
            case 'tinder':
            case 'component pouch':
                currType = equipMap.Gear;
                break;
            case 'ring':
                currType = equipMap.OtherMagic;
                break;
            case 'rod':
            case 'wand':
            case 'staff':
                currType = equipMap.Charged;
                break;
            case 'tanglefoot':
            case 'incense':
            case 'smokestick':
            case 'sunrod':
            case 'ration':
            case 'water':
            case 'alchemist':
            case 'oil':
            case 'flask':
            case 'acid':
            case 'potion':
            case 'elixir':
            case 'scroll':
            case 'antitoxin':
            case 'antidote':
                currType = equipMap.Consumables;
                break;
            case 'arrow':
            case 'bolt':
            case 'bullet':
            case 'stone':
                currType = equipMap.Ammo;
                break;
        }
    }
    return currType;
}
function importFromCompendium(eventInfo) {
    var id = SWUtils.getRowId(eventInfo.sourceAttribute),
        prefix = 'repeating_item_' + id + '_',
        itemprefix = prefix + 'item-',
        fields = ['default_char_size', 'equipment_tab', itemprefix + 'category_compendium', itemprefix + 'value_compendium', itemprefix + 'range_compendium', itemprefix + 'critical_compendium', itemprefix + 'smalldamage_compendium', itemprefix + 'meddamage_compendium', itemprefix + 'specialtype_compendium', itemprefix + 'speed20_compendium', itemprefix + 'speed30_compendium', itemprefix + 'weight_compendium', itemprefix + 'spell-fail_compendium', itemprefix + 'acbonus_compendium', itemprefix + 'acp_compendium', itemprefix + 'dmg-type', prefix + 'description', itemprefix + 'max-dex', prefix + 'name'];
    //TAS.debug('at importFromCompendium getting fields', fields);
    getAttrs(fields, function (v) {
        var setter = {},
            size = 0,
            tempInt = 0,
            temp,
            name,
            matches,
            attr = '',
            tempstr = '',
            isWeapon = 0,
            isArmor = 0,
            isOther = 0,
            currTab = 99,
            currType = equipMap.noEquipType,
            speed30 = 0,
            speed20 = 0;
        try {
            //TAS.debug("importFromCompendium values are",v);
            if (v[itemprefix + 'category_compendium'] !== 'Items') {
                _exportsLoaderTASTheAaronSheet2.default.warn("compendium item is " + v['repeating_item_item-category_compendium'] + ', INVALID');
                return;
            }
            setter[prefix + 'row_id'] = id;
            name = v[prefix + 'name'];
            PFUtils.getCompendiumIntSet(itemprefix, 'range', v, setter);
            PFUtils.getCompendiumFunctionSet(itemprefix, 'value', PFUtils.getCostInGP, v, setter);
            PFUtils.getCompendiumIntSet(itemprefix, 'spell-fail', v, setter);
            PFUtils.getCompendiumIntSet(itemprefix, 'acbonus', v, setter);
            PFUtils.getCompendiumIntSet(itemprefix, 'acp', v, setter);
            if (v[itemprefix + 'acbonus_compendium']) {
                isArmor = 1;
            }

            speed30 = parseInt(v[itemprefix + 'speed20_compendium'], 10) || 0;
            speed20 = parseInt(v[itemprefix + 'speed30_compendium'], 10) || 0;

            if (v[itemprefix + 'max-dex']) {
                temp = v[itemprefix + 'max-dex'];
                temp = temp.replace(/\u2013|\u2014|-|\\u2013|\\u2014/, '-');
                if (temp !== v[itemprefix + 'max-dex']) {
                    setter[itemprefix + 'max-dex'] = temp;
                }
            }
            if (v[itemprefix + 'specialtype_compendium']) {
                temp = v[itemprefix + 'specialtype_compendium'];
                temp = temp.replace(/\u2013|\u2014|-|\\u2013|\\u2014/, '');
                if (temp) {
                    if (v[itemprefix + 'item-dmg-type']) {
                        temp = v[itemprefix + 'item-dmg-type'] + ' ' + v[itemprefix + 'specialtype_compendium'];
                    } else {
                        temp = v[itemprefix + 'specialtype_compendium'];
                    }
                    setter[itemprefix + 'item-dmg-type'] = temp;
                }
            }
            if (v[itemprefix + 'critical_compendium']) {
                isWeapon = 1;
                temp = PFUtils.getCritFromString(v[itemprefix + 'critical_compendium']);
                if (temp) {
                    if (temp.crit !== 20) {
                        setter[itemprefix + 'crit-target'] = temp.crit;
                    }
                    if (temp.critmult !== 2) {
                        setter[itemprefix + 'crit-multiplier'] = temp.critmult;
                    }
                }
            }
            size = parseInt(v['default_char_size'], 10) || 0;
            tempstr = 'meddamage_compendium';
            tempInt = 0;
            if (size >= 1) {
                tempInt = 1;
                tempstr = 'smalldamage_compendium';
            }
            if (size !== 0) {
                //set  default size of item to small or medium, not other, let user do that for now
                setter[prefix + 'default_size'] = tempInt;
            }
            PFUtils.getCompendiumIntSet(itemprefix, 'weight', v, setter);
            //small size, weight is 1/2
            if (size >= 1) {
                tempInt = parseInt(setter[itemprefix + 'weight'], 10) || 0;
                if (tempInt) {
                    tempInt = tempInt / 2 * 100 / 100;
                    setter[itemprefix + 'weight'] = tempInt;
                }
            }
            if (v[itemprefix + tempstr]) {
                isWeapon = 1;
                temp = PFUtils.getDiceDieFromString(v[itemprefix + tempstr]);
                if (temp) {
                    if (temp.dice && temp.die) {
                        setter[itemprefix + 'damage-dice-num'] = temp.dice;
                        setter[itemprefix + 'damage-die'] = temp.die;
                    }
                    if (temp.plus) {
                        setter[itemprefix + 'damage'] = temp.plus;
                    }
                }
            }

            if (isWeapon) {
                currType = equipMap.Weapon;
                if (v[itemprefix + 'range_compendium'] && parseInt(v[itemprefix + 'range_compendium'], 10) > 0) {
                    setter[itemprefix + 'attack-type'] = '@{attk-ranged}';
                } else {
                    setter[itemprefix + 'attack-type'] = '@{attk-melee}';
                }
            } else if (isArmor) {
                currType = equipMap.Armor;
                //set encumbrance 
                //mUST LOOK AT name string and determine armor, then set heavy, medium, or light.
                //for shields it is easy
                //we can probably look at the change in speed to determine this.
                if (name) {
                    if (/tower/i.test(name)) {
                        tempstr = "Tower Shield";
                    } else if (speed30 === 30 && speed20 === 20) {
                        tempstr = "Light";
                    } else if (/heavy|stone|full|half.plate|splint|banded|iron|tatami|kusari/i.test(tempstr)) {
                        tempstr = "Heavy";
                    } else if (/medium|mountain|chainmail|breastplate|scale|kikko|steel|horn|mirror|hide|maru|armored coat/i.test(tempstr)) {
                        tempstr = "Medium";
                    } else {
                        tempstr = "Light";
                    }
                    setter[itemprefix + "defense-type"] = tempstr;
                }
            } else {
                currType = getEquipmentTypeFromName(name);
            }
            if (currType < 0) {
                currType = equipMap.Other;
            } else if (currType === equipMap.Weapon) {
                setter[prefix + 'weapon-attributes-show'] = 1;
            } else if (currType === equipMap.Armor) {
                setter[prefix + 'armor-attributes-show'] = 1;
            }
            //it just ignores it! why!? so don't change tab cause it won't be on the new tab.
            if (currType) {
                setter['equipment_tab'] = currType;
                setter[prefix + 'equip-type'] = currType;
                setter[prefix + 'equiptype-tab'] = currType;
            }
            setter[prefix + 'qty'] = 1;
            setter[prefix + 'qty_max'] = 1;
            //default to carried or not carried?
            setter[prefix + 'location'] = locationMap.Carried;
            setter[prefix + 'old_location'] = locationMap.Carried;
            setter[prefix + 'loctype-tab'] = locationMap.Carried;

            setter[itemprefix + 'category_compendium'] = "";
            setter[itemprefix + 'value_compendium'] = "";
            setter[itemprefix + 'range_compendium'] = "";
            setter[itemprefix + 'critical_compendium'] = "";
            setter[itemprefix + 'smalldamage_compendium'] = "";
            setter[itemprefix + 'meddamage_compendium'] = "";
            setter[itemprefix + 'specialtype_compendium'] = "";
            setter[itemprefix + 'speed20_compendium'] = "";
            setter[itemprefix + 'speed30_compendium'] = "";
            setter[itemprefix + 'weight_compendium'] = "";
            setter[itemprefix + 'spell-fail_compendium'] = "";
            setter[itemprefix + 'acbonus_compendium'] = "";
            setter[itemprefix + 'acp_compendium'] = "";
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("importFromCompendium", err);
        } finally {
            //TAS.debug"importFromCompendium setting",setter);
            if (_underscore2.default.size(setter) > 0) {
                setAttrs(setter, _PFConst2.default.silentParams, updateRepeatingItems);
            }
        }
    });
}
function updateUses(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.updateUses");
        if (typeof callback === "function") {
            callback();
        }
    });
    //TAS.debug("at PFInventory.updateUses");
    getSectionIDs('repeating_item', function (ids) {
        var fields = [];
        if (!ids || !_underscore2.default.size(ids)) {
            done();
            return;
        }
        fields = _underscore2.default.reduce(ids, function (m, id) {
            m.push('repeating_item_' + id + '_has_uses');
            m.push('repeating_item_' + id + '_qty_max');
            return m;
        }, []);
        //_.flatten(fields);
        getAttrs(fields, function (v) {
            var setter = {};
            try {
                setter = _underscore2.default.reduce(ids, function (m, id) {
                    var prefix = 'repeating_item_' + id + '_',
                        maxQty = 0;
                    try {
                        maxQty = parseInt(v[prefix + 'qty_max'], 10) || 0;
                        if (maxQty > 1) {
                            m[prefix + 'has_uses'] = 'true';
                        } else {
                            m[prefix + 'has_uses'] = '';
                        }
                    } catch (errin) {
                        _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateUses error repeating_item  id " + id, errin);
                    } finally {
                        return m;
                    }
                }, {});
            } catch (err) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.updateUses error setting defaults ", err);
            } finally {
                if (_underscore2.default.size(setter) > 0) {
                    setAttrs(setter, _PFConst2.default.silentParams, done);
                } else {
                    done();
                }
            }
        });
    });
}
/**
 * @param {function} callback 
 */
function deleteOrphanWornRows(callback) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.deleteOrphanWornRows");
        if (typeof callback === "function") {
            callback();
        }
    });
    getSectionIDs('repeating_item', function (ids) {
        if (!(ids && _underscore2.default.size(ids) > 0)) {
            done();
            return;
        }
        getAttrs(wornEquipmentRowRollsNew, function (v) {
            var notFoundList = [],
                lowerIDs = [],
                setter = {};
            try {
                lowerIDs = _underscore2.default.map(ids, function (id) {
                    return id.toLowerCase();
                });
                notFoundList = _underscore2.default.chain(v).omit(function (val, key) {
                    if (!val) {
                        return true;
                    }return false;
                }).mapObject(function (val) {
                    return SWUtils.getRowId(val).toLowerCase();
                }).omit(function (val, key) {
                    return _underscore2.default.contains(lowerIDs, val);
                }).value();
                if (_underscore2.default.size(notFoundList) > 0) {
                    setter = _underscore2.default.reduce(notFoundList, function (m, v, key) {
                        var nameAttr = key.slice(-5);
                        m[nameAttr] = '';
                        m[key] = '';
                        return m;
                    }, {});
                    setAttrs(setter, _PFConst2.default.params, done);
                } else {
                    done();
                }
            } catch (err) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.deleteOrphanWornRows", err);
                done();
            }
        });
    });
}
function deleteWornRow(source) {
    source = source.toLowerCase();
    getAttrs(wornEquipmentRowRollsNew, function (v) {
        var match = '',
            row = '',
            setter = {};
        try {
            match = _underscore2.default.findKey(v, function (val) {
                if (!val) {
                    return false;
                }
                if (val.toLowerCase().indexOf(source) >= 0) {
                    return true;
                }
                return false;
            });
            if (match) {
                row = match.slice(0, -5);
                setter[match] = '';
                setter[row] = '';
                setAttrs(setter, _PFConst2.default.silent);
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.event delete item for attribute: " + source, err);
        }
    });
}
function setNewDefaults(callback, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.setNewDefaults");
        if (typeof callback === "function") {
            callback();
        }
    });
    _exportsLoaderTASTheAaronSheet2.default.debug("at PFInventory.setNewDefaults");
    getAttrs(['migrated_itemlist_defaults'], function (vout) {
        try {
            //TAS.debug("PFInventory.setNewDefaults ",v);
            if (parseInt(vout.migrated_itemlist_defaults, 10) === 1) {
                done();
                return;
            }
            getSectionIDs('repeating_item', function (ids) {
                var fields = [];
                try {
                    if (!ids || !_underscore2.default.size(ids)) {
                        done();
                        return;
                    }
                    fields = _underscore2.default.map(ids, function (id) {
                        return ['repeating_item_' + id + '_name', 'repeating_item_' + id + '_location', 'repeating_item_' + id + '_qty_max', 'repeating_item_' + id + '_equip-type'];
                    });
                    fields = _underscore2.default.flatten(fields);
                } catch (miderror) {
                    _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.setNewDefaults miderror", miderror);
                    done();
                    return;
                }
                //TAS.debug("PFInventory.setNewDefaults fields:",fields);
                getAttrs(fields, function (v) {
                    var setter = {},
                        currEquip = 0;
                    try {
                        //TAS.debug("PFInventory.setNewDefaults fields ",v);
                        setter = _underscore2.default.reduce(ids, function (m, id) {
                            var prefix = 'repeating_item_' + id + '_',
                                maxQty = 0,
                                nameField = prefix + 'name',
                                currLoc = 0,
                                guess = 0;
                            try {
                                currLoc = parseInt(v[prefix + 'location'], 10);
                                if (isNaN(currLoc)) {
                                    //default is carried
                                    currLoc = locationMap.Carried;
                                    m[prefix + 'location'] = currLoc;
                                }
                                m[prefix + 'oldlocation'] = currLoc;
                                if (currLoc > locationMap.NotCarried) {
                                    m[prefix + 'loctype-tab'] = locationMap.Carried;
                                } else {
                                    m[prefix + 'loctype-tab'] = currLoc;
                                }
                                maxQty = parseInt(v[prefix + 'qty_max'], 10);
                                if (isNaN(maxQty)) {
                                    maxQty = 0;
                                    m[prefix + '_qty_max'] = maxQty;
                                }
                                if (maxQty > 1) {
                                    m[prefix + 'has_uses'] = 'true';
                                } else {
                                    m[prefix + 'has_uses'] = '';
                                }
                                currEquip = parseInt(v['repeating_item_' + id + '_equip-type'], 10);
                                if (!currEquip) {
                                    if (v[nameField]) {
                                        guess = getEquipmentTypeFromName(v[nameField]);
                                    }
                                    if (guess) {
                                        m[prefix + 'equip-type'] = guess;
                                        m[prefix + 'equiptype-tab'] = guess;
                                    } else {
                                        m[prefix + 'equip-type'] = equipMap.noEquipType;
                                        m[prefix + 'equiptype-tab'] = equipMap.noEquipType;
                                    }
                                } else {
                                    m[prefix + 'equiptype-tab'] = currEquip;
                                }
                                m[prefix + 'showinmenu'] = 0;
                            } catch (errin) {
                                _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.setNewDefaults error repeating_item  id " + id, errin);
                            } finally {
                                return m;
                            }
                        }, {});
                        setter['migrated_itemlist_defaults'] = 1;
                    } catch (err) {
                        _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.setNewDefaults error setting defaults ", err);
                    } finally {
                        if (_underscore2.default.size(setter) > 0) {
                            _exportsLoaderTASTheAaronSheet2.default.debug("PFInventory.setNewDefaults setting", setter);
                            setAttrs(setter, _PFConst2.default.silentParams, done);
                        } else {
                            done();
                        }
                    }
                });
            });
        } catch (outererr) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.setNewDefaults outererr", outererr);
            done();
        }
    });
}
function migrate(callback, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.migrate");
        if (typeof callback === "function") {
            callback();
        }
    });
    _exportsLoaderTASTheAaronSheet2.default.debug("At PFInventory.migrate");
    PFMigrate.migrateRepeatingItemAttributes(_exportsLoaderTASTheAaronSheet2.default.callback(function callPFInventorySetNewDefaults() {
        setNewDefaults(_exportsLoaderTASTheAaronSheet2.default.callback(function callPFInventoryMigrateWornEquipment() {
            migrateWornEquipment(done);
            migrateRepeatingMacros();
        }));
    }));
}
function recalculate(callback, silently, oldversion) {
    var done = _underscore2.default.once(function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("leaving PFInventory.recalculate");
        if (typeof callback === "function") {
            callback();
        }
    }),
        setTotals = _underscore2.default.after(2, function () {
        _exportsLoaderTASTheAaronSheet2.default.debug("PFInventory.recalculate at setTotals");
        updateLocations(_exportsLoaderTASTheAaronSheet2.default.callback(updateUses));
        resetCommandMacro();
        deleteOrphanWornRows();
        updateCarriedTotal(done);
    });
    try {
        _exportsLoaderTASTheAaronSheet2.default.debug("at PFInventory.recalculate");
        migrate(function () {
            updateCarriedCurrency(setTotals, silently);
            updateRepeatingItems(setTotals, silently);
        });
    } catch (err) {
        _exportsLoaderTASTheAaronSheet2.default.error("PFInventory.recalculate", err);
        done();
    }
}
function registerEventHandlers() {
    var tempstr = "";
    on('change:repeating_item:item-category_compendium', _exportsLoaderTASTheAaronSheet2.default.callback(function EventItemCompendium(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            importFromCompendium(eventInfo);
        }
    }));
    on('change:repeating_item:location', _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateItemLocation(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            updateEquipmentLocation(null, null, null, eventInfo);
            getAttrs(['repeating_item_location', 'repeating_item_old_location'], function (v) {
                var newLoc = parseInt(v.repeating_item_location, 10),
                    oldLoc = parseInt(v.repeating_item_old_location, 10);
                if (newLoc !== locationMap.NotCarried || oldLoc !== locationMap.NotCarried && oldLoc !== newLoc) {
                    updateRepeatingItems(null, false, { 'weight': 1 });
                }
            });
        }
    }));
    on('change:repeating_item:qty_max', _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateItemMaxQty(eventInfo) {
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            updateRepeatingItems();
            getAttrs(['repeating_item_qty_max'], function (v) {
                if (parseInt(v['repeating_item_qty_max'], 10) > 1) {
                    setAttrs({ 'repeating_item_has_uses': 'true' }, _PFConst2.default.silentParams);
                } else {
                    setAttrs({ 'repeating_item_has_uses': '' }, _PFConst2.default.silentParams);
                }
            });
        }
    }));
    on('change:repeating_item:qty', _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateItemTotalQty(eventInfo) {
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            getAttrs(['repeating_item_qty_max'], function (v) {
                var qtymax = parseInt(v.repeating_item_qty_max, 10) || 0;
                if (qtymax === 0 || qtymax === 1) {
                    updateRepeatingItems();
                }
            });
        }
    }));
    //hp total removed
    //on('change:repeating_item:item-hp change:repeating_item:item-hp_max', TAS.callback(function eventUpdateItemTotalHp(eventInfo) {
    //    TAS.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
    //    if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
    //        updateRepeatingItems(null,true,{'hp':1});
    //    }
    //}));
    on('change:repeating_item:value', _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateItemTotalValue(eventInfo) {
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            updateRepeatingItems(null, true, { 'value': 1 });
        }
    }));
    on('change:repeating_item:item-weight', _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateItemTotalWeight(eventInfo) {
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
            getAttrs(['repeating_item_location'], function (v) {
                if (parseInt(v.repeating_item_location, 10) !== locationMap.NotCarried) {
                    updateRepeatingItems(null, false, { 'weight': 1 });
                }
            });
        }
    }));

    on('remove:repeating_item', _exportsLoaderTASTheAaronSheet2.default.callback(function eventRemoveItem(eventInfo) {
        var source = '',
            setter = {},
            itemId = '';
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            updateRepeatingItems();
            deleteWornRow(eventInfo.sourceAttribute);
        }
        PFAttacks.removeLinkedAttack(null, PFAttacks.linkedAttackType.equipment, SWUtils.getRowId(eventInfo.sourceAttribute));
    }));
    on('change:CP change:SP change:GP change:PP', _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateCarriedCurrency(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        updateCarriedCurrency();
    }));
    on('change:carried-currency change:item_total_weight change:carried-misc', _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateCarriedTotal(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        updateCarriedTotal();
    }));
    //change item worn in shield or armor location
    on('change:repeating_item:location change:repeating_item:item-defense-type change:repeating_item:item-acbonus change:repeating_item:item-max-dex change:repeating_item:item-acp change:repeating_item:item-spell-fail change:repeating_item:item-proficiency change:repeating_item:acenhance', _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateWornArmorAndShield(eventInfo) {
        var location = 0;
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event" + eventInfo.sourceType);
        getAttrs(["repeating_item_location"], function (v) {
            var location = parseInt(v["repeating_item_location"], 10) || 0;
            if (location === locationMap.Armor || location === locationMap.Shield) {
                updateWornArmorAndShield(location, eventInfo.sourceAttribute);
            }
        });
    }));
    _underscore2.default.each(commonLinkedAttributes, function (fieldToWatch) {
        var eventToWatch = "change:repeating_item:item-" + fieldToWatch;
        on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventupdateAssociatedAttackLoop(eventInfo) {
            _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event" + eventInfo.sourceType);
            if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                updateAssociatedAttack(eventInfo.sourceAttribute);
            }
        }));
    });
    on('change:repeating_item:name change:repeating_item:item-dmg-type change:repeating_item:item-proficiency change:repeating_item:default_size change:repeating_item:wpenhance', _exportsLoaderTASTheAaronSheet2.default.callback(function eventupdateAssociatedAttack(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event" + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            updateAssociatedAttack(eventInfo.sourceAttribute);
        }
    }));
    on("change:repeating_item:create-attack-entry", _exportsLoaderTASTheAaronSheet2.default.callback(function eventcreateAttackEntryFromRow(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            createAttackEntryFromRow(eventInfo.sourceAttribute);
        }
    }));
    on("change:repeating_item:set-as-armor", _exportsLoaderTASTheAaronSheet2.default.callback(function eventcreateArmorEntryFromRow(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            updateWornArmorAndShield(locationMap.Armor, eventInfo.sourceAttribute, null);
        }
    }));
    on("change:repeating_item:set-as-shield", _exportsLoaderTASTheAaronSheet2.default.callback(function eventcreateShieldEntryFromRow(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            updateWornArmorAndShield(locationMap.Shield, eventInfo.sourceAttribute, null);
        }
    }));
    on("change:repeating_item:showinmenu change:repeating_item:equip-type change:repeating_item:name", _exportsLoaderTASTheAaronSheet2.default.callback(function eventShowItemInMenu(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            resetCommandMacro();
        }
    }));
    on("change:repeating_item:equip-type", _exportsLoaderTASTheAaronSheet2.default.callback(function eventItemEquipTypeChange(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            getAttrs(['repeating_item_equip-type', 'repeating_item_equiptype-tab'], function (v) {
                var newtype = parseInt(v['repeating_item_equip-type'], 10) || 0,
                    oldtype = parseInt(v['repeating_item_equiptype-tab'], 10) || 0;
                //TAS.debug("################","At change:repeating_item:equip-type updating equiptype:"+newtype+", currtab:"+oldtype,v);
                if (newtype !== oldtype) {
                    setAttrs({ 'repeating_item_equiptype-tab': newtype }, _PFConst2.default.silentParams);
                }
            });
        }
    }));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFInventory module loaded      ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.parseNum = parseNum;
exports.bonusSpellSlots = bonusSpellSlots;
exports.buildList = buildList;
exports.getSizeMod = getSizeMod;
exports.arrayify = arrayify;
exports.importInit = importInit;
exports.importAbilityScores = importAbilityScores;
exports.importSaves = importSaves;
exports.getOrMakeRowID = getOrMakeRowID;
exports.getOrMakeItemRowID = getOrMakeItemRowID;
exports.getOrMakeSpellRowID = getOrMakeSpellRowID;
exports.getOrMakeClassRowID = getOrMakeClassRowID;
exports.importFeats = importFeats;
exports.nameIsShield = nameIsShield;
exports.importItems = importItems;
exports.importTraits = importTraits;
exports.importSLAs = importSLAs;
exports.importFeatures = importFeatures;
exports.importClasses = importClasses;
exports.importSpellClasses = importSpellClasses;
exports.importSpells = importSpells;
exports.calcHitDice = calcHitDice;
exports.buildArchetypeArray = buildArchetypeArray;
exports.getClassSource = getClassSource;
exports.importSkills = importSkills;
exports.importPenalties = importPenalties;
exports.importAC = importAC;
exports.importCharacter = importCharacter;
exports.registerEventHandlers = registerEventHandlers;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFLog = __webpack_require__(0);

var _PFSheet = __webpack_require__(25);

var PFSheet = _interopRequireWildcard(_PFSheet);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parseNum(num) {
	if (_underscore2.default.isUndefined(num) || num === "") return 0;
	return parseInt(num) || 0;
}

function bonusSpellSlots(abilMod, spellLevel) {
	return Math.max(0, Math.floor((abilMod + 4 - spellLevel) / 4));
}

function buildList(objArray, propName) {
	return _underscore2.default.map(objArray, function (item) {
		return item[propName];
	}).join(", ");
}

function getSizeMod(size) {
	switch (size.toLowerCase()) {
		case "colossal":
			return -8;
			break;
		case "gargantuan":
			return -4;
			break;
		case "huge":
			return -2;
			break;
		case "large":
			return -1;
			break;
		case "small":
			return 1;
			break;
		case "tiny":
			return 2;
			break;
		case "diminutive":
			return 4;
			break;
		case "fine":
			return 8;
			break;
		default:
			return 0;
	}
}

// Make sure "stuff" is an array
function arrayify(stuff) {
	if (_underscore2.default.isUndefined(stuff)) return [];
	if (Array.isArray(stuff)) return stuff;
	return new Array(stuff);
}

function importInit(attrs, initObj) {
	attrs["init-misc"] = parseNum(initObj._total) - parseNum(initObj._attrtext);
	attrs["init-ability"] = "@{" + initObj._attrname.substr(0, 3).toUpperCase() + "-mod}";
	attrs["init_notes"] = initObj.situationalmodifiers._text;
}

function importAbilityScores(attrs, attributes) {
	attributes.forEach(function (abScore) {
		var abName = abScore._name.substr(0, 3).toUpperCase();
		var base = parseNum(abScore.attrvalue._base);
		var modifier = parseNum(abScore.attrvalue._modified) - base; // Modifier is the total difference between what HL is reporting as the character's base ability score and the final modified ability score
		attrs[abName + "-base"] = base;
		// If the modifier is positive, assume it's an enhancement bonus; otherwise, assume it's a penalty
		if (modifier > 0) attrs[abName + "-enhance"] = modifier;else attrs[abName + "-penalty"] = modifier;
	});
}

function importSaves(attrs, saves) {
	// Since the XML doesn't break this down by class, add it all to class 0
	var i = 0;
	var saveNotes = saves.allsaves.situationalmodifiers._text;
	for (i = 0; i < saves.save.length; i++) {
		var save = saves.save[i];
		var abbr = save._abbr;

		attrs["class-0-" + abbr] = parseNum(save._base);
		attrs[abbr + "-resist"] = parseNum(save._fromresist);
		attrs[abbr + "-misc"] = parseNum(save._save) - parseNum(save._base) - parseNum(save._fromresist) - parseNum(save._fromattr);

		if (save.situationalmodifiers._text !== "" && saveNotes.indexOf(save.situationalmodifiers._text) === -1) saveNotes = saveNotes + "\n**" + abbr + ":** " + save.situationalmodifiers._text;
	}
	attrs["Save-notes"] = saveNotes.trim();
}

// Find an existing repeatable item with the same name, or generate new row ID
function getOrMakeRowID(featIDList, name) {
	var attrNames = Object.values(featIDList);
	var rows = Object.keys(featIDList);

	var attrMatch = _underscore2.default.find(attrNames, function (currentAttrName) {
		var attrName = currentAttrName;
		// Eliminate anything in parentheses, dice expressions, and "x#" (we use that to indicate we've taken a feat more than once) before comparing names
		attrName = attrName.replace(/ x[0-9]+$/, "").trim();

		if (attrName === name) {
			var ID = rows[_underscore2.default.indexOf(attrNames, currentAttrName)];
			if (!_underscore2.default.isUndefined(ID)) return true;
		}
		return false;
	});
	if (!_underscore2.default.isUndefined(attrMatch)) return rows[_underscore2.default.indexOf(attrNames, attrMatch)];
	return generateRowID();
}

// Find an existing repeatable item with the same name, or generate new row ID; extra processing for items
function getOrMakeItemRowID(featIDList, name) {
	var attrNames = Object.values(featIDList);
	var rows = Object.keys(featIDList);

	var compareName = name.replace(/\(.*\)/, "").replace(/\+\d+/, "").toLowerCase().replace("masterwork", "").trim();
	var attrMatch = _underscore2.default.find(attrNames, function (currentAttrName) {
		var attrName = currentAttrName;
		// Eliminate anything in parentheses, dice expressions, and "x#" (we use that to indicate we've taken a feat more than once) before comparing names
		attrName = attrName.replace(/\(.*\)/, "").replace(/\+\d+/, "").toLowerCase().replace("masterwork", "").trim();

		if (attrName === compareName) {
			var ID = rows[_underscore2.default.indexOf(attrNames, currentAttrName)];
			if (!_underscore2.default.isUndefined(ID)) return true;
		}
		return false;
	});
	if (!_underscore2.default.isUndefined(attrMatch)) return rows[_underscore2.default.indexOf(attrNames, attrMatch)];
	return generateRowID();
}

// Find an existing repeatable item with the same name and spellclass, or generate new row ID
function getOrMakeSpellRowID(featIDList, name, spellclass) {
	var attrMatch = _underscore2.default.find(featIDList, function (currentFeat) {
		if (currentFeat.name === name && currentFeat.spellclass === spellclass) return true;
		return false;
	});
	if (!_underscore2.default.isUndefined(attrMatch)) return attrMatch.rowID;
	return generateRowID();
}

function getOrMakeClassRowID(featIDList, name) {
	var attrObjs = Object.values(featIDList);
	var rows = Object.keys(featIDList);

	var attrMatch = _underscore2.default.find(attrObjs, function (currentAttrObj) {
		var attrName = currentAttrObj.name;
		// Eliminate anything in parentheses, dice expressions, and "x#" (we use that to indicate we've taken a feat more than once) before comparing names
		name = name.replace(/\(.+\)/g, "").replace(/\d+d\d+(\+\d*)*/g, "").replace(/\+\d+/g, "").trim();
		attrName = attrName.replace(/\(.+\)/g, "").replace(/\d+d\d+(\+\d*)*/g, "").replace(/\+\d+/g, "").trim();

		if (attrName === name) return true;
		return false;
	});
	if (!_underscore2.default.isUndefined(attrMatch)) return attrMatch.rowID;
	return generateRowID();
}

function importFeats(attrs, feats, featIDList, resources) {
	var repeatPrefix = "repeating_ability";
	var skipList = [];
	var featNames = _underscore2.default.map(feats, function (feat) {
		return feat._name;
	});
	_underscore2.default.each(feats, function (feat) {
		// Early exit if we already dealt with another copy of this feat
		if (_underscore2.default.contains(skipList, feat._name)) return;

		// Count the number of times the feat is listed, so we can indicate that in the feat name
		var taken = _underscore2.default.filter(featNames, function (featName) {
			return featName === feat._name;
		}).length;

		var row = getOrMakeRowID(featIDList, feat._name);
		if (!_underscore2.default.isUndefined(featIDList[row])) delete featIDList[row];

		if (taken > 1) attrs[repeatPrefix + "_" + row + "_name"] = feat._name + " x" + taken;else attrs[repeatPrefix + "_" + row + "_name"] = feat._name;
		attrs[repeatPrefix + "_" + row + "_description"] = feat.description;
		attrs[repeatPrefix + "_" + row + "_rule_category"] = "feats";
		skipList.push(feat._name);
		if (_underscore2.default.contains(Object.keys(resources), feat._name)) attrs[repeatPrefix + "_" + row + "_max-calculation"] = resources[feat._name]._max;
	});
}

// Hero Lab stores armor and shields identically, so so assume anything with "shield" or "klar" in the name is a shield
function nameIsShield(name) {
	if (name.toLowerCase().indexOf("shield") !== -1 || name.toLowerCase().indexOf("klar") !== -1) return true;
	return false;
}

function importItems(items, resources, armorPenalties, armor, weapons) {
	var repeatPrefix = "repeating_item";
	getSectionIDs(repeatPrefix, function (idarray) {
		var itemNameAttrs = _underscore2.default.union(_underscore2.default.map(idarray, function (id) {
			return repeatPrefix + "_" + id + "_name";
		}), ["shield3-acp", "shield3-spell-fail"]);
		getAttrs(itemNameAttrs, function (names) {

			// Pull out the shield attributes before we build the ID list
			var shieldACP = parseNum(names["shield3-acp"]);
			var shieldASF = parseNum(names["shield3-spell-fail"]);
			if (!_underscore2.default.isUndefined(names["shield3-acp"])) delete names["shield3-acp"];
			if (!_underscore2.default.isUndefined(names["shield3-spell-fail"])) delete names["shield3-spell-fail"];

			var itemIDList = _underscore2.default.object(_underscore2.default.map(names, function (name, attr) {
				return [attr.substring(repeatPrefix.length + 1, attr.indexOf("_name")), name];
			}));
			var itemsList = [];
			var attrs = {};
			var armorNames = _underscore2.default.map(armor, function (obj) {
				return obj._name;
			});
			var weaponNames = _underscore2.default.map(weapons, function (obj) {
				return obj._name;
			});

			// List of words that indicate an item is masterwork
			var masterworkWords = ["mithral", "adamantine", "angelskin", "darkleaf", "darkwood", "dragonhide", "eel", "fire-forged", "frost-forged", "greenwood", "paueliel"];
			_underscore2.default.each(items, function (item) {
				var row = getOrMakeItemRowID(itemIDList, item._name);
				if (!_underscore2.default.isUndefined(itemIDList[row])) delete itemIDList[row];
				itemsList.push(item._name);

				repeatPrefix = "repeating_item_" + row;
				attrs[repeatPrefix + "_name"] = item._name;
				attrs[repeatPrefix + "_item-weight"] = item.weight._value;
				attrs[repeatPrefix + "_value"] = parseFloat(item.cost._value) / parseInt(item._quantity);
				attrs[repeatPrefix + "_description"] = item.description;

				if (_underscore2.default.contains(Object.keys(resources), item._name) && item._quantity === "1" && resources[item._name]._max !== "1") {
					attrs[repeatPrefix + "_qty"] = resources[item._name]._left;
					attrs[repeatPrefix + "_qty_max"] = resources[item._name]._max;
				} else attrs[repeatPrefix + "_qty"] = item._quantity;

				if (!_underscore2.default.isUndefined(item.itempower)) _underscore2.default.each(arrayify(item.itempower), function (itemPower) {
					itemsList.push(itemPower._name);
				});

				// check if this is a weapon
				var weaponCompareName = item._name;
				// If this is a shield (but not a klar), the attack name will be "Heavy/light shield bash"
				if (item._name.toLowerCase().indexOf("shield") !== -1) {
					var attackName;
					if (item._name.toLowerCase().indexOf("heavy" !== -1)) attackName = "heavy shield bash";else attackName = "light shield bash";
					weaponCompareName = _underscore2.default.find(weaponNames, function (name) {
						if (name.toLowerCase().indexOf(attackName) !== -1) return true;return false;
					}) || item._name;
				}
				if (_underscore2.default.contains(weaponNames, weaponCompareName)) {
					var weaponObj = weapons[_underscore2.default.indexOf(weaponNames, weaponCompareName)];
					attrs[repeatPrefix + "_item-wpenhance"] = parseNum(weaponObj._name.match(/\+\d+/));

					if (!_underscore2.default.isUndefined(weaponObj._typetext)) attrs[repeatPrefix + "_item-dmg-type"] = weaponObj._typetext;

					// Check to see if item name includes any words that indicate this is a masterwork item
					if (weaponCompareName.toLowerCase().indexOf("masterwork") !== -1 || _underscore2.default.intersection(masterworkWords, item._name.toLowerCase().split(" ")).length > 0) attrs[repeatPrefix + "_item-masterwork"] = 1;

					if (!_underscore2.default.isUndefined(weaponObj._damage)) {
						var weaponDice = weaponObj._damage.match(/\d+d\d+/);
						if (weaponDice.length > 0) {
							attrs[repeatPrefix + "_item-damage-dice-num"] = parseNum(weaponDice[0].split("d")[0]);
							attrs[repeatPrefix + "_item-damage-die"] = parseNum(weaponDice[0].split("d")[1]);
						}
					}

					if (!_underscore2.default.isUndefined(weaponObj._crit)) {
						var critArray = weaponObj._crit.split("/");
						if (critArray.length > 1) attrs[repeatPrefix + "_item-crit-target"] = parseNum(critArray[0].match(/\d+/)[0]);else attrs[repeatPrefix + "_item-crit-target"] = 20;
						attrs[repeatPrefix + "_item-crit-multiplier"] = parseNum(critArray[critArray.length - 1].replace(/\D/g, ""));
					}

					if (!_underscore2.default.isUndefined(weaponObj.rangedattack) && !_underscore2.default.isUndefined(weaponObj.rangedattack._rangeincvalue)) attrs[repeatPrefix + "_item-range"] = parseNum(weaponObj.rangedattack._rangeincvalue);
				}

				// check if this is armor
				// If this is a klar, the armor name will be different
				var armorCompareName = item._name;
				if (item._name.toLowerCase().indexOf("klar") !== -1) {
					armorCompareName = _underscore2.default.find(armorNames, function (name) {
						if (name.toLowerCase().indexOf("klar") !== -1) return true;return false;
					}) || item._name;
				}
				if (_underscore2.default.contains(armorNames, armorCompareName)) {
					var armorObj = armor[_underscore2.default.indexOf(armorNames, armorCompareName)];

					// Item is a shield
					if (nameIsShield(item._name)) {
						var enhancement = parseNum(armorCompareName.match(/\+\d+/));
						var ACbonus = parseNum(armorObj._ac) - enhancement;
						attrs[repeatPrefix + "_item-acbonus"] = ACbonus;
						attrs[repeatPrefix + "_item-acenhance"] = enhancement;
						if (!_underscore2.default.isUndefined(armorObj._equipped) && armorObj._equipped === "yes") {
							attrs[repeatPrefix + "_item-acp"] = shieldACP;
							attrs[repeatPrefix + "_item-spell-fail"] = shieldASF;
							attrs["shield3"] = item._name;
							attrs["shield3-acbonus"] = ACbonus;
							attrs["shield3-enhance"] = enhancement;
						}
					} else {
						var enhancement = parseNum(item._name.match(/\+\d+/));
						var ACbonus = parseNum(armorObj._ac) - enhancement;
						attrs[repeatPrefix + "_item-acbonus"] = ACbonus;
						attrs[repeatPrefix + "_item-acenhance"] = enhancement;
						if (!_underscore2.default.isUndefined(armorObj._equipped) && armorObj._equipped === "yes") {
							attrs["armor3-acp"] = attrs[repeatPrefix + "_item-acp"] = armorPenalties.ACP - shieldACP;
							attrs["armor3-spell-fail"] = attrs[repeatPrefix + "_item-spell-fail"] = armorPenalties.spellfail - shieldASF;
							if (armorPenalties.maxDex == 99) attrs["armor3-max-dex"] = attrs[repeatPrefix + "_item-max-dex"] = "";else attrs["armor3-max-dex"] = attrs[repeatPrefix + "_item-max-dex"] = armorPenalties.maxDex;
							attrs["armor3"] = item._name;
							attrs["armor3-acbonus"] = ACbonus;
							attrs["armor3-enhance"] = enhancement;
						}
					}
				}
			});
			setAttrs(attrs);
		});
	});
}

function importTraits(attrs, traits, traitIDList, resources) {
	var repeatPrefix = "repeating_ability";
	traits.forEach(function (trait) {
		var row = getOrMakeRowID(traitIDList, trait._name);
		if (!_underscore2.default.isUndefined(traitIDList[row])) delete traitIDList[row];
		attrs[repeatPrefix + "_" + row + "_name"] = trait._name;
		attrs[repeatPrefix + "_" + row + "_description"] = trait.description;
		attrs[repeatPrefix + "_" + row + "_rule_category"] = "traits";
		if (_underscore2.default.contains(Object.keys(resources), trait._name)) attrs[repeatPrefix + "_" + row + "_max-calculation"] = resources[trait._name]._max;
	});
}

function importSLAs(attrs, SLAs, SLAsIDList, resources) {
	var repeatPrefix = "repeating_ability";
	SLAs.forEach(function (SLA) {
		var row = getOrMakeRowID(SLAsIDList, SLA._name);
		if (!_underscore2.default.isUndefined(SLAsIDList[row])) delete SLAsIDList[row];
		attrs[repeatPrefix + "_" + row + "_name"] = SLA._name;
		attrs[repeatPrefix + "_" + row + "_description"] = SLA.description;
		attrs[repeatPrefix + "_" + row + "_rule_category"] = "spell-like-abilities";
		attrs[repeatPrefix + "_" + row + "_ability_type"] = "Sp";
		if (_underscore2.default.contains(Object.keys(resources), SLA._name)) attrs[repeatPrefix + "_" + row + "_max-calculation"] = resources[SLA._name]._max;
	});
}

function importFeatures(attrs, featureList, specials, archetypes, resources) {
	var specNameList = _underscore2.default.map(specials, function (special) {
		return special._name;
	});
	var skipList = [];
	_underscore2.default.each(specials, function (special) {
		var name = special._name;
		var repeatPrefix = "repeating_ability",
		    row,
		    classSource = -1;
		var cleanName = name.replace(/ x[0-9]+$/, "").replace(/\(([^\)]+)\)/g, "").trim();
		if (_underscore2.default.contains(skipList, cleanName)) return;
		var multiList = _underscore2.default.filter(specNameList, function (spec) {
			return spec.replace(/\(([^\)]+)\)/g, "").trim() === cleanName;
		});
		if (multiList.length > 1) {
			skipList.push(cleanName);
			var parenList = _underscore2.default.map(multiList, function (item) {
				return item.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
			});
			name = name.replace(/\(([^\)]+)\)/, "(" + _underscore2.default.uniq(parenList).join(", ") + ")");
		}
		row = getOrMakeClassRowID(featureList, name);
		repeatPrefix = "repeating_ability_" + row;
		if (!_underscore2.default.isUndefined(featureList[row])) delete featureList[row];else // If we created a new row for this, set rule category
			{
				// Import if it has a "specsource", assume it's a class feature
				if (special.specsource) attrs[repeatPrefix + "_rule_category"] = "class-features";else attrs[repeatPrefix + "_rule_category"] = "racial-traits";
			}
		classSource = getClassSource(arrayify(special.specsource), archetypes);
		attrs[repeatPrefix + "_name"] = name;
		attrs[repeatPrefix + "_description"] = special.description;

		if (classSource !== -1) {
			attrs[repeatPrefix + "_CL-basis"] = "@{class-" + classSource + "-level}";
			attrs[repeatPrefix + "_class-name"] = Object.keys(archetypes)[classSource];
		}

		if (_underscore2.default.contains(Object.keys(resources), special._name)) attrs[repeatPrefix + "_max-calculation"] = resources[special._name]._max;

		if (!_underscore2.default.isUndefined(special._type)) attrs[repeatPrefix + "_ability_type"] = special._type.substr(0, 2);
	});
}

function importClasses(attrs, classes) {
	var classList = new Object();

	var i = 0;
	var classObj;
	while (i < classes.length) {
		classObj = classes[i];

		// We can only handle 5 classes
		if (i >= 5) return;
		classList[classObj._name.replace(/\(([^\)]+)\)/g, "").replace("(", "").replace(")", "").trim()] = classObj;
		attrs["class-" + i + "-name"] = classObj._name;
		attrs["class-" + i + "-level"] = classObj._level;

		i++;
	}

	return classList;
}

// Import spellclasses; presence in spellclasses node means it's a spellcaster, but some of the data is in the classes node
function importSpellClasses(attrs, spellclasses, classes, abScores) {
	var spellClassesList = new Object();

	var i,
	    j,
	    abMod = 0,
	    currentAbMod,
	    spellslots,
	    spelllevel,
	    casterlevel,
	    concmod,
	    spellpenmod;
	var spellClassIndex = 0;
	for (i = 0; i < spellclasses.length; i++) {
		var spellClass = spellclasses[i];
		// Only 3 spellclasses on character sheet, so if they somehow have more...
		if (spellClassIndex >= 3) return spellClassesList;

		var spellClassName = spellClass._name.replace(/\(([^\)]+)\)/g, "").replace("(", "").replace(")", "").trim();
		var classIndex = _underscore2.default.indexOf(Object.keys(classes), _underscore2.default.find(Object.keys(classes), function (className) {
			if (className.toLowerCase().indexOf(spellClassName.toLowerCase()) !== -1) return true;
			return false;
		}));

		if (classIndex !== -1) {
			casterlevel = parseNum(classes[spellClassName]._casterlevel);
			attrs["spellclass-" + spellClassIndex] = classIndex;
			attrs["spellclass-" + spellClassIndex + "-level-misc"] = casterlevel - parseNum(classes[spellClassName]._level);
			attrs["spellclass-" + spellClassIndex + "-level"] = parseNum(classes[spellClassName]._level);
			attrs["spellclass-" + spellClassIndex + "-level-total"] = casterlevel;
			attrs["spellclass-" + spellClassIndex + "-name"] = classes[spellClassName]._name;

			if (!_underscore2.default.isUndefined(classes[spellClassName].arcanespellfailure)) attrs["armor3-spell-fail"] = parseNum(classes[spellClassName].arcanespellfailure._value);

			// Make a guess at which ability modifier is used for this class
			if (!_underscore2.default.isUndefined(classes[spellClassName]._basespelldc)) abMod = parseNum(classes[spellClassName]._basespelldc) - 10;
			if (!_underscore2.default.isUndefined(classes[spellClassName]._basespelldc)) {
				// Start at the fourth ability score (Intelligence), so we skip the physical abilities
				for (j = 3; j < abScores.length; j++) {
					if (parseNum(abScores[j].attrbonus._modified) === abMod) {
						var attr = {};
						attr["Concentration-" + spellClassIndex + "-ability"] = "@{" + abScores[j]._name.substr(0, 3).toUpperCase() + "-mod}";
						setAttrs(attr);
						break;
					}
				}
			}

			if (abMod !== 0) {
				// Calculate misc mods to concentration
				if (!_underscore2.default.isUndefined(classes[spellClassName]._concentrationcheck)) {
					concmod = parseNum(classes[spellClassName]._concentrationcheck) - casterlevel - abMod;
					attrs["Concentration-" + spellClassIndex + "-misc"] = concmod;
					attrs["Concentration-" + spellClassIndex] = parseNum(classes[spellClassName]._concentrationcheck);
					attrs["Concentration-" + spellClassIndex + "-mod"] = abMod;
				}

				// Calculate misc mods to spell penetration
				if (!_underscore2.default.isUndefined(classes[spellClassName].overcomespellresistance)) {
					spellpenmod = parseNum(classes[spellClassName].overcomespellresistance) - casterlevel;
					attrs["spellclass-" + spellClassIndex + "-SP_misc"] = spellpenmod;
				}

				// Populate spells / day; Hero Lab includes bonus slots, so remove those
				if (!_underscore2.default.isUndefined(spellclasses[i].spelllevel)) {
					spellclasses[i].spelllevel = arrayify(spellclasses[i].spelllevel);
					for (j = 0; j < spellclasses[i].spelllevel.length; j++) {
						spellslots = parseNum(spellclasses[i].spelllevel[j]._maxcasts);
						spelllevel = parseNum(spellclasses[i].spelllevel[j]._level);
						if (spelllevel > 0) spellslots = spellslots - bonusSpellSlots(abMod, spelllevel);
						if (spellslots < 0) spellslots = "";
						attrs["spellclass-" + spellClassIndex + "-level-" + spelllevel + "-class"] = spellslots;
					}
				}
				// Set bonus spell slot table entries
				attrs["spellclass-" + spellClassIndex + "-level-1-bonus"] = bonusSpellSlots(abMod, 1);
				attrs["spellclass-" + spellClassIndex + "-level-2-bonus"] = bonusSpellSlots(abMod, 2);
				attrs["spellclass-" + spellClassIndex + "-level-3-bonus"] = bonusSpellSlots(abMod, 3);
				attrs["spellclass-" + spellClassIndex + "-level-4-bonus"] = bonusSpellSlots(abMod, 4);
				attrs["spellclass-" + spellClassIndex + "-level-5-bonus"] = bonusSpellSlots(abMod, 5);
				attrs["spellclass-" + spellClassIndex + "-level-6-bonus"] = bonusSpellSlots(abMod, 6);
				attrs["spellclass-" + spellClassIndex + "-level-7-bonus"] = bonusSpellSlots(abMod, 7);
				attrs["spellclass-" + spellClassIndex + "-level-8-bonus"] = bonusSpellSlots(abMod, 8);
				attrs["spellclass-" + spellClassIndex + "-level-9-bonus"] = bonusSpellSlots(abMod, 9);
			}
			spellClassesList[spellClassName] = classes[Object.keys(classes)[classIndex]];
			spellClassIndex++;
		}
	}

	if (spellClassIndex > 1) attrs["spellclasses_multiclassed"] = 1;

	return spellClassesList;
}

function importSpells(spells, spellclasses) {
	console.log("Import spells");
	var repeatPrefix = "repeating_spells";
	getSectionIDs(repeatPrefix, function (idarray) {
		var spellNameAttrs = _underscore2.default.union(_underscore2.default.map(idarray, function (id) {
			return repeatPrefix + "_" + id + "_name";
		}), _underscore2.default.map(idarray, function (id) {
			return repeatPrefix + "_" + id + "_spellclass_number";
		}));
		getAttrs(spellNameAttrs, function (spellAttrs) {
			var spellObjList = {};
			var spellKeys = Object.keys(spellAttrs);
			_underscore2.default.each(spellKeys, function (spellKey) {
				var rowID;
				if (spellKey.indexOf("_name") !== -1) {
					rowID = spellKey.substring(repeatPrefix.length + 1, spellKey.indexOf("_name"));
					if (_underscore2.default.isUndefined(spellObjList[rowID])) spellObjList[rowID] = { rowID: rowID };
					spellObjList[rowID].name = spellAttrs[spellKey];
				}
				if (spellKey.indexOf("_spellclass_number") !== -1) {
					rowID = spellKey.substring(repeatPrefix.length + 1, spellKey.indexOf("_spellclass_number"));
					if (_underscore2.default.isUndefined(spellObjList[rowID])) spellObjList[rowID] = { rowID: rowID };
					spellObjList[rowID].spellclass = spellAttrs[spellKey];
				}
			});

			var spellClassesKeys = Object.keys(spellclasses);
			var attrs = {};
			_underscore2.default.each(spells, function (spell) {
				var rowID, spellClass, spellName, school, level;

				// Search for a repeating spell with the same name and spellclass; if not found, make new row
				level = parseNum(spell._level);
				repeatPrefix = "repeating_spells_";
				spellClass = _underscore2.default.indexOf(spellClassesKeys, spell._class);
				spellName = spell._name.replace(/\(x\d+\)/, "").trim();
				rowID = getOrMakeSpellRowID(spellObjList, spellName, spellClass);
				if (_underscore2.default.isUndefined(rowID)) {
					console.log("Undefined spell row ID!");
					console.log(spell);
				}
				// Update prefix with ID
				repeatPrefix = repeatPrefix + rowID;

				attrs[repeatPrefix + "_name"] = spellName;
				attrs[repeatPrefix + "_spell_level"] = level;
				attrs[repeatPrefix + "_spellclass_number"] = spellClass;
				attrs[repeatPrefix + "_components"] = spell._componenttext.replace("Divine Focus", "DF").replace("Focus", "F").replace("Material", "M").replace("Verbal", "V").replace("Somatic", "S").replace(" or ", "/");
				attrs[repeatPrefix + "_duration"] = spell._duration;
				attrs[repeatPrefix + "_save"] = spell._save.replace(/DC \d+/, "").trim();
				attrs[repeatPrefix + "_savedc"] = parseNum(spell._dc);
				attrs[repeatPrefix + "_cast-time"] = spell._casttime;
				attrs[repeatPrefix + "_sr"] = spell._resist.replace("harmless", "Harmless");
				attrs[repeatPrefix + "_DC_misc"] = parseNum(spell._dc) - parseNum(spellclasses[spell._class !== "" ? spell._class : Object.keys(spellclasses)[0]]._basespelldc) - level;

				switch (spell._range.toLowerCase()) {
					case "close (25 + 5 ft./2 levels)":
						attrs[repeatPrefix + "_range_pick"] = "close";
						break;
					case "medium (100 + 10 ft./level)":
						attrs[repeatPrefix + "_range_pick"] = "medium";
						break;
					case "long (400 + 40 ft./level)":
						attrs[repeatPrefix + "_range_pick"] = "long";
						break;
					case "touch":
					case "personal":
						attrs[repeatPrefix + "_range_pick"] = spell._range.toLowerCase();
						break;
					default:
						attrs[repeatPrefix + "_range_pick"] = "number";
						attrs[repeatPrefix + "_range"] = spell._range;
				}

				if (spell._area !== "") attrs[repeatPrefix + "_targets"] = spell._area;else if (spell._effect !== "") attrs[repeatPrefix + "_targets"] = spell._effect;else attrs[repeatPrefix + "_targets"] = spell._target;

				school = spell._schooltext;
				if (spell._subschooltext !== "") school = school + " (" + spell._subschooltext + ")";
				if (spell._descriptortext !== "") school = school + " [" + spell._descriptortext + "]";
				attrs[repeatPrefix + "_school"] = school;

				attrs[repeatPrefix + "_description"] = spell.description;
			});
			setAttrs(attrs);
		});
	});
}

function calcHitDice(hitdice) {
	var dice = hitdice.match(/\d+d\d/g);
	var numDice = 0;
	var i = 0;
	while (i < dice.length) {
		numDice += parseInt(dice[i].split("d")[0]);
		i++;
	}
	return numDice;
}

// Builds an object collection of archetypes, with the appropriate classes as the keys, in the order they're entered in the character sheet; use this to determine class specials come from
function buildArchetypeArray(classes) {
	var archetypes = new Object();

	_underscore2.default.each(classes, function (classObj, className) {
		if (classObj._name.indexOf("(") === -1) {
			archetypes[className] = [];
			return;
		}
		var archeString = classObj._name.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
		var archeList = archeString.split(",");
		archeList = _underscore2.default.map(archeList, function (arche) {
			return arche.trim();
		});
		archetypes[className] = archeList;
	});
	return archetypes;
}

// Returns the array number of the class that grants a feature; returns -1 if we can't find the class
function getClassSource(sources, archetypes) {
	// If there's no listed source, it isn't from a class
	if (!sources.length) return -1;

	// Grab an array of class names from the archetypes object
	var classes = Object.keys(archetypes);

	// Check if source is a class, first
	var intersect = _underscore2.default.intersection(sources, classes);
	if (intersect.length) return classes.indexOf(intersect[0]);

	// If not a class, check for an archetype as a source, and return the associated class
	var className = _underscore2.default.find(classes, function (item) {
		return _underscore2.default.intersection(archetypes[item], sources).length;
	});
	if (className) return classes.indexOf(className);

	return -1;
}

function importSkills(attrs, skills, size, ACP) {
	// Ripped from the PF character sheet JS
	var skillSize;
	switch (Math.abs(size)) {
		case 0:
			skillSize = 0;break;
		case 1:
			skillSize = 2;break;
		case 2:
			skillSize = 4;break;
		case 4:
			skillSize = 6;break;
		case 8:
			skillSize = 8;break;
		case 16:
			skillSize = 10;break;
		default:
			skillSize = 0;
	}
	if (size < 0) {
		skillSize = skillSize * -1;
	}

	// Clear out all existing skills data
	_underscore2.default.extend(attrs, { "acrobatics-ability": "", "acrobatics-cs": "", "acrobatics-ranks": "", "acrobatics-class": "", "acrobatics-ability-mod": "", "acrobatics-racial": "", "acrobatics-feat": "", "acrobatics-item": "", "acrobatics-size": "", "acrobatics-acp": "", "acrobatics-misc": "", "acrobatics-reqtrain": "", "artistry-ability": "", "artistry-cs": "", "artistry-ranks": "", "artistry-class": "", "artistry-ability-mod": "", "artistry-racial": "", "artistry-feat": "", "artistry-item": "", "artistry-size": "", "artistry-acp": "", "artistry-misc": "", "artistry-reqtrain": "", "artistry2-ability": "", "artistry2-cs": "", "artistry2-ranks": "", "artistry2-class": "", "artistry2-ability-mod": "", "artistry2-racial": "", "artistry2-feat": "", "artistry2-item": "", "artistry2-size": "", "artistry2-acp": "", "artistry2-misc": "", "artistry2-reqtrain": "", "artistry3-ability": "", "artistry3-cs": "", "artistry3-ranks": "", "artistry3-class": "", "artistry3-ability-mod": "", "artistry3-racial": "", "artistry3-feat": "", "artistry3-item": "", "artistry3-size": "", "artistry3-acp": "", "artistry3-misc": "", "artistry3-reqtrain": "", "appraise-ability": "", "appraise-cs": "", "appraise-ranks": "", "appraise-class": "", "appraise-ability-mod": "", "appraise-racial": "", "appraise-feat": "", "appraise-item": "", "appraise-size": "", "appraise-acp": "", "appraise-misc": "", "appraise-reqtrain": "", "bluff-ability": "", "bluff-cs": "", "bluff-ranks": "", "bluff-class": "", "bluff-ability-mod": "", "bluff-racial": "", "bluff-feat": "", "bluff-item": "", "bluff-size": "", "bluff-acp": "", "bluff-misc": "", "bluff-reqtrain": "", "climb-ability": "", "climb-cs": "", "climb-ranks": "", "climb-class": "", "climb-ability-mod": "", "climb-racial": "", "climb-feat": "", "climb-item": "", "climb-size": "", "climb-acp": "", "climb-misc": "", "climb-reqtrain": "", "craft-ability": "", "craft-cs": "", "craft-ranks": "", "craft-class": "", "craft-ability-mod": "", "craft-racial": "", "craft-feat": "", "craft-item": "", "craft-size": "", "craft-acp": "", "craft-misc": "", "craft-reqtrain": "", "craft2-ability": "", "craft2-cs": "", "craft2-ranks": "", "craft2-class": "", "craft2-ability-mod": "", "craft2-racial": "", "craft2-feat": "", "craft2-item": "", "craft2-size": "", "craft2-acp": "", "craft2-misc": "", "craft2-reqtrain": "", "craft3-ability": "", "craft3-cs": "", "craft3-ranks": "", "craft3-class": "", "craft3-ability-mod": "", "craft3-racial": "", "craft3-feat": "", "craft3-item": "", "craft3-size": "", "craft3-acp": "", "craft3-misc": "", "craft3-reqtrain": "", "diplomacy-ability": "", "diplomacy-cs": "", "diplomacy-ranks": "", "diplomacy-class": "", "diplomacy-ability-mod": "", "diplomacy-racial": "", "diplomacy-feat": "", "diplomacy-item": "", "diplomacy-size": "", "diplomacy-acp": "", "diplomacy-misc": "", "diplomacy-reqtrain": "", "disable-device-ability": "", "disable-device-cs": "", "disable-device-ranks": "", "disable-device-class": "", "disable-device-ability-mod": "", "disable-device-racial": "", "disable-device-feat": "", "disable-device-item": "", "disable-device-size": "", "disable-device-acp": "", "disable-device-misc": "", "disable-device-reqtrain": "", "disguise-ability": "", "disguise-cs": "", "disguise-ranks": "", "disguise-class": "", "disguise-ability-mod": "", "disguise-racial": "", "disguise-feat": "", "disguise-item": "", "disguise-size": "", "disguise-acp": "", "disguise-misc": "", "disguise-reqtrain": "", "escape-artist-ability": "", "escape-artist-cs": "", "escape-artist-ranks": "", "escape-artist-class": "", "escape-artist-ability-mod": "", "escape-artist-racial": "", "escape-artist-feat": "", "escape-artist-item": "", "escape-artist-size": "", "escape-artist-acp": "", "escape-artist-misc": "", "escape-artist-reqtrain": "", "fly-ability": "", "fly-cs": "", "fly-ranks": "", "fly-class": "", "fly-ability-mod": "", "fly-racial": "", "fly-feat": "", "fly-item": "", "fly-size": "", "fly-acp": "", "fly-misc": "", "fly-reqtrain": "", "handle-animal-ability": "", "handle-animal-cs": "", "handle-animal-ranks": "", "handle-animal-class": "", "handle-animal-ability-mod": "", "handle-animal-racial": "", "handle-animal-feat": "", "handle-animal-item": "", "handle-animal-size": "", "handle-animal-acp": "", "handle-animal-misc": "", "handle-animal-reqtrain": "", "heal-ability": "", "heal-cs": "", "heal-ranks": "", "heal-class": "", "heal-ability-mod": "", "heal-racial": "", "heal-feat": "", "heal-item": "", "heal-size": "", "heal-acp": "", "heal-misc": "", "heal-reqtrain": "", "intimidate-ability": "", "intimidate-cs": "", "intimidate-ranks": "", "intimidate-class": "", "intimidate-ability-mod": "", "intimidate-racial": "", "intimidate-feat": "", "intimidate-item": "", "intimidate-size": "", "intimidate-acp": "", "intimidate-misc": "", "intimidate-reqtrain": "", "linguistics-ability": "", "linguistics-cs": "", "linguistics-ranks": "", "linguistics-class": "", "linguistics-ability-mod": "", "linguistics-racial": "", "linguistics-feat": "", "linguistics-item": "", "linguistics-size": "", "linguistics-acp": "", "linguistics-misc": "", "linguistics-reqtrain": "", "lore-ability": "", "lore-cs": "", "lore-ranks": "", "lore-class": "", "lore-ability-mod": "", "lore-racial": "", "lore-feat": "", "lore-item": "", "lore-size": "", "lore-acp": "", "lore-misc": "", "lore-reqtrain": "", "lore2-ability": "", "lore2-cs": "", "lore2-ranks": "", "lore2-class": "", "lore2-ability-mod": "", "lore2-racial": "", "lore2-feat": "", "lore2-item": "", "lore2-size": "", "lore2-acp": "", "lore2-misc": "", "lore2-reqtrain": "", "lore3-ability": "", "lore3-cs": "", "lore3-ranks": "", "lore3-class": "", "lore3-ability-mod": "", "lore3-racial": "", "lore3-feat": "", "lore3-item": "", "lore3-size": "", "lore3-acp": "", "lore3-misc": "", "lore3-reqtrain": "", "knowledge-arcana-ability": "", "knowledge-arcana-cs": "", "knowledge-arcana-ranks": "", "knowledge-arcana-class": "", "knowledge-arcana-ability-mod": "", "knowledge-arcana-racial": "", "knowledge-arcana-feat": "", "knowledge-arcana-item": "", "knowledge-arcana-size": "", "knowledge-arcana-acp": "", "knowledge-arcana-misc": "", "knowledge-arcana-reqtrain": "", "knowledge-dungeoneering-ability": "", "knowledge-dungeoneering-cs": "", "knowledge-dungeoneering-ranks": "", "knowledge-dungeoneering-class": "", "knowledge-dungeoneering-ability-mod": "", "knowledge-dungeoneering-racial": "", "knowledge-dungeoneering-feat": "", "knowledge-dungeoneering-item": "", "knowledge-dungeoneering-size": "", "knowledge-dungeoneering-acp": "", "knowledge-dungeoneering-misc": "", "knowledge-dungeoneering-reqtrain": "", "knowledge-engineering-ability": "", "knowledge-engineering-cs": "", "knowledge-engineering-ranks": "", "knowledge-engineering-class": "", "knowledge-engineering-ability-mod": "", "knowledge-engineering-racial": "", "knowledge-engineering-feat": "", "knowledge-engineering-item": "", "knowledge-engineering-size": "", "knowledge-engineering-acp": "", "knowledge-engineering-misc": "", "knowledge-engineering-reqtrain": "", "knowledge-geography-ability": "", "knowledge-geography-cs": "", "knowledge-geography-ranks": "", "knowledge-geography-class": "", "knowledge-geography-ability-mod": "", "knowledge-geography-racial": "", "knowledge-geography-feat": "", "knowledge-geography-item": "", "knowledge-geography-size": "", "knowledge-geography-acp": "", "knowledge-geography-misc": "", "knowledge-geography-reqtrain": "", "knowledge-history-ability": "", "knowledge-history-cs": "", "knowledge-history-ranks": "", "knowledge-history-class": "", "knowledge-history-ability-mod": "", "knowledge-history-racial": "", "knowledge-history-feat": "", "knowledge-history-item": "", "knowledge-history-size": "", "knowledge-history-acp": "", "knowledge-history-misc": "", "knowledge-history-reqtrain": "", "knowledge-local-ability": "", "knowledge-local-cs": "", "knowledge-local-ranks": "", "knowledge-local-class": "", "knowledge-local-ability-mod": "", "knowledge-local-racial": "", "knowledge-local-feat": "", "knowledge-local-item": "", "knowledge-local-size": "", "knowledge-local-acp": "", "knowledge-local-misc": "", "knowledge-local-reqtrain": "", "knowledge-nature-ability": "", "knowledge-nature-cs": "", "knowledge-nature-ranks": "", "knowledge-nature-class": "", "knowledge-nature-ability-mod": "", "knowledge-nature-racial": "", "knowledge-nature-feat": "", "knowledge-nature-item": "", "knowledge-nature-size": "", "knowledge-nature-acp": "", "knowledge-nature-misc": "", "knowledge-nature-reqtrain": "", "knowledge-nobility-ability": "", "knowledge-nobility-cs": "", "knowledge-nobility-ranks": "", "knowledge-nobility-class": "", "knowledge-nobility-ability-mod": "", "knowledge-nobility-racial": "", "knowledge-nobility-feat": "", "knowledge-nobility-item": "", "knowledge-nobility-size": "", "knowledge-nobility-acp": "", "knowledge-nobility-misc": "", "knowledge-nobility-reqtrain": "", "knowledge-planes-ability": "", "knowledge-planes-cs": "", "knowledge-planes-ranks": "", "knowledge-planes-class": "", "knowledge-planes-ability-mod": "", "knowledge-planes-racial": "", "knowledge-planes-feat": "", "knowledge-planes-item": "", "knowledge-planes-size": "", "knowledge-planes-acp": "", "knowledge-planes-misc": "", "knowledge-planes-reqtrain": "", "knowledge-religion-ability": "", "knowledge-religion-cs": "", "knowledge-religion-ranks": "", "knowledge-religion-class": "", "knowledge-religion-ability-mod": "", "knowledge-religion-racial": "", "knowledge-religion-feat": "", "knowledge-religion-item": "", "knowledge-religion-size": "", "knowledge-religion-acp": "", "knowledge-religion-misc": "", "knowledge-religion-reqtrain": "", "perception-ability": "", "perception-cs": "", "perception-ranks": "", "perception-class": "", "perception-ability-mod": "", "perception-racial": "", "perception-feat": "", "perception-item": "", "perception-size": "", "perception-acp": "", "perception-misc": "", "perception-reqtrain": "", "perform-ability": "", "perform-cs": "", "perform-ranks": "", "perform-class": "", "perform-ability-mod": "", "perform-racial": "", "perform-feat": "", "perform-item": "", "perform-size": "", "perform-acp": "", "perform-misc": "", "perform-reqtrain": "", "perform2-ability": "", "perform2-cs": "", "perform2-ranks": "", "perform2-class": "", "perform2-ability-mod": "", "perform2-racial": "", "perform2-feat": "", "perform2-item": "", "perform2-size": "", "perform2-acp": "", "perform2-misc": "", "perform2-reqtrain": "", "perform3-ability": "", "perform3-cs": "", "perform3-ranks": "", "perform3-class": "", "perform3-ability-mod": "", "perform3-racial": "", "perform3-feat": "", "perform3-item": "", "perform3-size": "", "perform3-acp": "", "perform3-misc": "", "perform3-reqtrain": "", "profession-ability": "", "profession-cs": "", "profession-ranks": "", "profession-class": "", "profession-ability-mod": "", "profession-racial": "", "profession-feat": "", "profession-item": "", "profession-size": "", "profession-acp": "", "profession-misc": "", "profession-reqtrain": "", "profession2-ability": "", "profession2-cs": "", "profession2-ranks": "", "profession2-class": "", "profession2-ability-mod": "", "profession2-racial": "", "profession2-feat": "", "profession2-item": "", "profession2-size": "", "profession2-acp": "", "profession2-misc": "", "profession2-reqtrain": "", "profession3-ability": "", "profession3-cs": "", "profession3-ranks": "", "profession3-class": "", "profession3-ability-mod": "", "profession3-racial": "", "profession3-feat": "", "profession3-item": "", "profession3-size": "", "profession3-acp": "", "profession3-misc": "", "profession3-reqtrain": "", "ride-ability": "", "ride-cs": "", "ride-ranks": "", "ride-class": "", "ride-ability-mod": "", "ride-racial": "", "ride-feat": "", "ride-item": "", "ride-size": "", "ride-acp": "", "ride-misc": "", "ride-reqtrain": "", "sense-motive-ability": "", "sense-motive-cs": "", "sense-motive-ranks": "", "sense-motive-class": "", "sense-motive-ability-mod": "", "sense-motive-racial": "", "sense-motive-feat": "", "sense-motive-item": "", "sense-motive-size": "", "sense-motive-acp": "", "sense-motive-misc": "", "sense-motive-reqtrain": "", "sleight-of-hand-ability": "", "sleight-of-hand-cs": "", "sleight-of-hand-ranks": "", "sleight-of-hand-class": "", "sleight-of-hand-ability-mod": "", "sleight-of-hand-racial": "", "sleight-of-hand-feat": "", "sleight-of-hand-item": "", "sleight-of-hand-size": "", "sleight-of-hand-acp": "", "sleight-of-hand-misc": "", "sleight-of-hand-reqtrain": "", "spellcraft-ability": "", "spellcraft-cs": "", "spellcraft-ranks": "", "spellcraft-class": "", "spellcraft-ability-mod": "", "spellcraft-racial": "", "spellcraft-feat": "", "spellcraft-item": "", "spellcraft-size": "", "spellcraft-acp": "", "spellcraft-misc": "", "spellcraft-reqtrain": "", "stealth-ability": "", " stealth-cs": "", "stealth-ranks": "", "stealth-class": "", "stealth-ability-mod": "", "stealth-racial": "", "stealth-feat": "", "stealth-item": "", "stealth-size": "", "stealth-acp": "", "stealth-misc": "", "stealth-reqtrain": "", "survival-ability": "", "survival-cs": "", "survival-ranks": "", "survival-class": "", "survival-ability-mod": "", "survival-racial": "", "survival-feat": "", "survival-item": "", "survival-size": "", "survival-acp": "", "survival-misc": "", "survival-reqtrain": "", "swim-ability": "", "swim-cs": "", "swim-ranks": "", "swim-class": "", "swim-ability-mod": "", "swim-racial": "", "swim-feat": "", "swim-item": "", "swim-size": "", "swim-acp": "", "swim-misc": "", "swim-reqtrain": "", "use-magic-device-ability": "", "use-magic-device-cs": "", "use-magic-device-ranks": "", "use-magic-device-class": "", "use-magic-device-ability-mod": "", "use-magic-device-racial": "", "use-magic-device-feat": "", "use-magic-device-item": "", "use-magic-device-size": "", "use-magic-device-acp": "", "use-magic-device-misc": "", "use-magic-device-reqtrain": "", "misc-skill-0-ability": "", "misc-skill-0-cs": "", "misc-skill-0-ranks": "", "misc-skill-0-class": "", "misc-skill-0-ability-mod": "", "misc-skill-0-racial": "", "misc-skill-0-feat": "", "misc-skill-0-item": "", "misc-skill-0-size": "", "misc-skill-0-acp": "", "misc-skill-0-misc": "", "misc-skill-0-reqtrain": "", "misc-skill-1-ability": "", "misc-skill-1-cs": "", "misc-skill-1-ranks": "", "misc-skill-1-class": "", "misc-skill-1-ability-mod": "", "misc-skill-1-racial": "", "misc-skill-1-feat": "", "misc-skill-1-item": "", "misc-skill-1-size": "", "misc-skill-1-acp": "", "misc-skill-1-misc": "", "misc-skill-1-reqtrain": "", "misc-skill-2-ability": "", "misc-skill-2-cs": "", "misc-skill-2-ranks": "", "misc-skill-2-class": "", "misc-skill-2-ability-mod": "", "misc-skill-2-racial": "", "misc-skill-2-feat": "", "misc-skill-2-item": "", "misc-skill-2-size": "", "misc-skill-2-acp": "", "misc-skill-2-misc": "", "misc-skill-2-reqtrain": "", "misc-skill-3-ability": "", "misc-skill-3-cs": "", "misc-skill-3-ranks": "", "misc-skill-3-class": "", "misc-skill-3-ability-mod": "", "misc-skill-3-racial": "", "misc-skill-3-feat": "", "misc-skill-3-item": "", "misc-skill-3-size": "", "misc-skill-3-acp": "", "misc-skill-3-misc": "", "misc-skill-3-reqtrain": "", "misc-skill-4-ability": "", "misc-skill-4-cs": "", "misc-skill-4-ranks": "", "misc-skill-4-class": "", "misc-skill-4-ability-mod": "", "misc-skill-4-racial": "", "misc-skill-4-feat": "", "misc-skill-4-item": "", "misc-skill-4-size": "", "misc-skill-4-acp": "", "misc-skill-4-misc": "", "misc-skill-4-reqtrain": "", "misc-skill-5-ability": "", "misc-skill-5-cs": "", "misc-skill-5-ranks": "", "misc-skill-5-class": "", "misc-skill-5-ability-mod": "", "misc-skill-5-racial": "", "misc-skill-5-feat": "", "misc-skill-5-item": "", "misc-skill-5-size": "", "misc-skill-5-acp": "", "misc-skill-5-misc": "", "misc-skill-5-reqtrain": "", "craft-name": "", "craft2-name": "", "craft3-name": "", "lore-name": "", "perform-name": "", "perform2-name": "", "perform3-name": "", "profession-name": "", "profession2-name": "", "profession3-name": "", "misc-skill-0-name": "", "misc-skill-1-name": "", "misc-skill-2-name": "", "misc-skill-3-name": "", "misc-skill-4-name": "", "misc-skill-5-name": "" });

	// Keep track of which of these skills we're on
	var craft = 1;
	var perform = 1;
	var profession = 1;
	var artistry = 1;
	var lore = 1;
	var misc = 0;

	var i = 0;
	var skill;
	var skillMisc;
	var skillAttrPrefix;
	for (i = 0; i < skills.length; i++) {
		/*if (_.isUndefined(skill._name))
  {
  	continue;
  }*/
		skill = skills[i];
		console.log(skill._name);
		// Figure out where we're putting this skill on the character sheet
		if (skill._name.indexOf("Craft") !== -1) {
			if (craft === 1) {
				skillAttrPrefix = "craft";
				if (skill._name.match(/\(([^\)]+)\)/) !== null) attrs["craft-name"] = skill._name.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
				craft++;
			} else if (craft <= 3) {
				skillAttrPrefix = "craft" + craft;
				if (skill._name.match(/\(([^\)]+)\)/) !== null) attrs["craft" + craft + "-name"] = skill._name.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
				craft++;
			} else {
				if (misc <= 5) {
					skillAttrPrefix = "misc-skill-" + misc;
					if (skill._name.match(/\(([^\)]+)\)/) !== null) attrs[skillAttrPrefix + "-name"] = skill._name;
					misc++;
				} else console.log("Ran out of misc skills for " + skill._name + "!");
			}
		} else if (skill._name.indexOf("Perform") !== -1) {
			if (perform === 1) {
				skillAttrPrefix = "perform";
				if (skill._name.match(/\(([^\)]+)\)/) !== null) attrs["perform-name"] = skill._name.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
				perform++;
			} else if (perform <= 3) {
				skillAttrPrefix = "perform" + perform;
				if (skill._name.match(/\(([^\)]+)\)/) !== null) attrs["perform" + perform + "-name"] = skill._name.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
				perform++;
			} else {
				if (misc <= 5) {
					skillAttrPrefix = "misc-skill-" + misc;
					if (skill._name.match(/\(([^\)]+)\)/) !== null) attrs[skillAttrPrefix + "-name"] = skill._name;
					misc++;
				} else console.log("Ran out of misc skills for " + skill._name + "!");
			}
		} else if (skill._name.indexOf("Profession") !== -1) {
			if (profession === 1) {
				skillAttrPrefix = "profession";
				if (skill._name.match(/\(([^\)]+)\)/) !== null) attrs["profession-name"] = skill._name.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
				profession++;
			} else if (profession <= 3) {
				skillAttrPrefix = "profession" + profession;
				if (skill._name.match(/\(([^\)]+)\)/) !== null) attrs["profession" + profession + "-name"] = skill._name.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
				profession++;
			} else {
				if (misc <= 5) {
					skillAttrPrefix = "misc-skill-" + misc;
					if (skill._name.match(/\(([^\)]+)\)/) !== null) attrs[skillAttrPrefix + "-name"] = skill._name;
					misc++;
				} else console.log("Ran out of misc skills for " + skill._name + "!");
			}
		} else if (skill._name.indexOf("Knowledge") !== -1) {
			switch (skill._name.match(/\(([^\)]+)\)/g)[0]) {
				case "(arcana)":
				case "(dungeoneering)":
				case "(engineering)":
				case "(geography)":
				case "(history)":
				case "(local)":
				case "(nature)":
				case "(nobility)":
				case "(planes)":
				case "(religion)":
					skillAttrPrefix = skill._name.toLowerCase().replace(/\s/g, "-").replace("(", "").replace(")", "");
					break;
				default:
					skillAttrPrefix = "misc-skill-" + misc;
					attrs[skillAttrPrefix + "-name"] = skill._name;
					misc++;
			}
		} else if (skill._name.indexOf("Artistry") !== -1) {
			if (artistry === 1) {
				skillAttrPrefix = "artistry";
				attrs["artistry-name"] = skill._name.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
				artistry++;
			} else if (artistry <= 3) {
				skillAttrPrefix = "artistry" + artistry;
				attrs["artistry" + artistry + "-name"] = skill._name.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
				artistry++;
			} else {
				if (misc <= 5) {
					skillAttrPrefix = "misc-skill-" + misc;
					attrs[skillAttrPrefix + "-name"] = skill._name;
					misc++;
				} else console.log("Ran out of misc skills for " + skill._name + "!");
			}
		} else if (skill._name.indexOf("Lore") !== -1) {
			if (lore === 1) {
				skillAttrPrefix = "lore";
				attrs["lore-name"] = skill._name.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
				lore++;
			} else if (lore <= 3) {
				skillAttrPrefix = "lore" + lore;
				attrs["lore" + lore + "-name"] = skill._name.match(/\(([^\)]+)\)/)[0].replace("(", "").replace(")", "");
				lore++;
			} else {
				if (misc <= 5) {
					skillAttrPrefix = "misc-skill-" + misc;
					attrs[skillAttrPrefix + "-name"] = skill._name;
					misc++;
				} else console.log("Ran out of misc skills for " + skill._name + "!");
			}
		} else skillAttrPrefix = skill._name.toLowerCase().replace(/\s/g, "-").replace("(", "").replace(")", "").replace("-hand", "-Hand").replace("e-device", "e-Device").replace("-artist", "-Artist").replace("-animal", "-Animal");

		attrs[skillAttrPrefix + "-ranks"] = parseNum(skill._ranks);
		attrs[skillAttrPrefix + "-ability"] = "@{" + skill._attrname + "-mod}";
		attrs[skillAttrPrefix + "-ability-mod"] = parseNum(skill._attrbonus);

		if (skill._classskill === "yes") attrs[skillAttrPrefix + "-cs"] = 3;

		skillMisc = parseNum(skill._value) - parseNum(skill._ranks) - parseNum(skill._attrbonus);
		if (parseNum(skill._ranks) != 0 && skill._classskill === "yes") skillMisc -= 3;
		if (skill._armorcheck === "yes") skillMisc -= ACP;
		if (skill._name === "Fly") skillMisc -= skillSize;
		if (skill._name === "Stealth") skillMisc -= 2 * skillSize;
		attrs[skillAttrPrefix + "-misc"] = skillMisc;

		if (skill._trainedonly === "yes") attrs[skillAttrPrefix + "-ReqTrain"] = 1;

		// Add situation modifiers to the macro
		if (!_underscore2.default.isUndefined(skill.situationalmodifiers.situationalmodifier)) {
			var macro = "@{PC-whisper} &{template:pf_generic} {{color=@{rolltemplate_color}}} {{header_image=@{header_image-pf_generic-skill}}} @{toggle_rounded_flag} {{character_name=@{character_name}}} {{character_id=@{character_id}}} {{subtitle}} {{name=" + skill._name + "}} {{Check=[[ @{skill-query} + [[ @{" + skillAttrPrefix + "} ]] ]]}}";
			skill.situationalmodifiers.situationalmodifier = arrayify(skill.situationalmodifiers.situationalmodifier);
			var j = 0;
			while (j < skill.situationalmodifiers.situationalmodifier.length) {
				macro = macro + " {{" + skill.situationalmodifiers.situationalmodifier[j]._source + "=" + skill.situationalmodifiers.situationalmodifier[j]._text + "}}";
				j++;
			}
			attrs[skillAttrPrefix + "-macro"] = macro;
		}
	}
}

// Import ACP and Max Dex; these aren't included under items, but the final values are listed in penalties
function importPenalties(attrs, penalties) {
	var ACP = 0;
	var i = 0;
	while (i < penalties.length) {
		if (penalties[i]._name === "Armor Check Penalty") {
			ACP = parseNum(penalties[i]._value);
			attrs["armor3-acp"] = ACP;
		} else if (penalties[i]._name === "Max Dex Bonus") attrs["armor3-max-dex"] = Math.min(99, parseNum(penalties[i]._value)); // Hero Lab uses 1000 for Max Dex when player doesn't have one; cap it at 99 to match sheet default
		i++;
	}
	return ACP;
}

function importAC(attrs, acObj) {
	attrs["AC-natural"] = parseNum(acObj._fromnatural);
	attrs["AC-deflect"] = parseNum(acObj._fromdeflect);
	attrs["AC-dodge"] = parseNum(acObj._fromdodge);

	// Are we replacing Dex to AC with something else?
	if (acObj._fromdexterity === "") {
		if (acObj._fromcharisma !== "") {
			attrs["AC-ability"] = "( ((@{CHA-mod} + [[ @{max-dex-source} ]]) - abs(@{CHA-mod} - [[ @{max-dex-source} ]])) / 2 )";
			attrs["AC-misc"] = parseNum(acObj._ac) - 10 - parseNum(acObj._fromarmor) - parseNum(acObj._fromshield) - parseNum(acObj._fromcharisma) - parseNum(acObj._fromsize) - parseNum(acObj._fromnatural) - parseNum(acObj._fromdeflect) - parseNum(acObj._fromdodge);
		} else if (acObj._fromwisdom !== "") {
			attrs["AC-ability"] = "( ((@{WIS-mod} + [[ @{max-dex-source} ]]) - abs(@{WIS-mod} - [[ @{max-dex-source} ]])) / 2 )";
			attrs["AC-misc"] = parseNum(acObj._ac) - 10 - parseNum(acObj._fromarmor) - parseNum(acObj._fromshield) - parseNum(acObj._fromwisdom) - parseNum(acObj._fromsize) - parseNum(acObj._fromnatural) - parseNum(acObj._fromdeflect) - parseNum(acObj._fromdodge);
		} else attrs["AC-misc"] = parseNum(acObj._ac) - 10 - parseNum(acObj._fromarmor) - parseNum(acObj._fromshield) - parseNum(acObj._fromdexterity) - parseNum(acObj._fromsize) - parseNum(acObj._fromnatural) - parseNum(acObj._fromdeflect) - parseNum(acObj._fromdodge);
	}
}

function importCharacter(characterObj) {
	var attrs = {};

	importAbilityScores(attrs, characterObj.attributes.attribute);
	importSaves(attrs, characterObj.saves);
	var classes,
	    spellClasses,
	    archetypes = {};
	// Class objects won't exist for creatures w/o class levels, such as animals
	if (!_underscore2.default.isUndefined(characterObj.classes.class)) {
		// Class will be an array if multiclassed, but a single object if single-classed; make it an array, just to be safe
		characterObj.classes.class = arrayify(characterObj.classes.class);

		classes = importClasses(attrs, characterObj.classes.class);

		// If any of the character's classes is a spellcaster, it'll be listed here, too
		if (!_underscore2.default.isUndefined(characterObj.spellclasses.spellclass)) {
			characterObj.spellclasses.spellclass = arrayify(characterObj.spellclasses.spellclass);
			spellClasses = importSpellClasses(attrs, characterObj.spellclasses.spellclass, classes, characterObj.attributes.attribute);

			// Well, it's a spellcaster, so let's import those spells, too!
			var spellsArray = arrayify(characterObj.spellsknown.spell).concat(arrayify(characterObj.spellbook.spell)).concat(arrayify(characterObj.spellsmemorized.spell));
			var spellNames = [];
			spellsArray = _underscore2.default.reject(spellsArray, function (spell) {
				if (_underscore2.default.contains(spellNames, spell._name)) return true;spellNames.concat(spell._name);return false;
			});
			importSpells(spellsArray, spellClasses);
			/*if (!_.isUndefined(characterObj.spellsknown.spell))
   {
   	characterObj.spellsknown.spell = arrayify(characterObj.spellsknown.spell);
   	importSpells(characterObj.spellsknown.spell,spellClasses);
   }
   if (!_.isUndefined(characterObj.spellbook.spell))
   {
   	characterObj.spellbook.spell = arrayify(characterObj.spellbook.spell);
   	importSpells(characterObj.spellbook.spell,spellClasses);
   }
   if (!_.isUndefined(characterObj.spellsmemorized.spell))
   {
   	characterObj.spellsmemorized.spell = arrayify(characterObj.spellsmemorized.spell);
   	importSpells(characterObj.spellsmemorized.spell,spellClasses);
   }*/
		}

		// Need to keep track of what archetypes the character has, since class feature source could be an archetype
		archetypes = buildArchetypeArray(classes);
	}

	importAC(attrs, characterObj.armorclass);
	characterObj.penalties.penalty = arrayify(characterObj.penalties.penalty);
	var ACP = importPenalties(attrs, characterObj.penalties.penalty);

	// Build an object we can pass to the item importing, so we can attach this to the inventory item
	var armorPenalties = {};
	armorPenalties.ACP = parseNum(attrs["armor3-acp"]);
	armorPenalties.maxDex = parseNum(attrs["armor3-max-dex"]);
	armorPenalties.spellfail = parseNum(attrs["armor3-spell-fail"]);

	// We might change these values if we're using a shield, so don't set them outside of item import
	if (!_underscore2.default.isUndefined(attrs["armor3-acp"])) delete attrs["armor3-acp"];
	if (!_underscore2.default.isUndefined(attrs["armor3-spell-fail"])) delete attrs["armor3-spell-fail"];

	var armor = _underscore2.default.reject(arrayify(characterObj.defenses.armor || {}), function (item) {
		return _underscore2.default.isUndefined(item._name);
	});
	var weapons = _underscore2.default.reject(arrayify(characterObj.melee.weapon || {}).concat(arrayify(characterObj.ranged.weapon || {})), function (item) {
		return _underscore2.default.isUndefined(item._name);
	});

	// "Tracked Resources" is a list of uses, either a quantity of items, charges, or uses per day
	var resources = _underscore2.default.object(_underscore2.default.map(characterObj.trackedresources.trackedresource, function (resource) {
		return [resource._name, resource];
	}));

	// Make an array of items, both magic and mundane
	var items = _underscore2.default.reject(arrayify(characterObj.magicitems.item || {}).concat(arrayify(characterObj.gear.item || {})), function (item) {
		return _underscore2.default.isUndefined(item._name);
	});

	// "Specials" could include items, so we need to filter them out
	var itemNames = _underscore2.default.map(items, function (obj) {
		return obj._name;
	});
	var specials = _underscore2.default.reject(arrayify(characterObj.attack.special).concat(arrayify(characterObj.defenses.special), arrayify(characterObj.otherspecials.special), arrayify(characterObj.movement.special)), function (obj) {
		return _underscore2.default.contains(itemNames, obj._name);
	});

	importItems(items, resources, armorPenalties, armor, weapons);

	getSectionIDs("repeating_ability", function (idarray) {
		var abilityNameAttrs = _underscore2.default.union(_underscore2.default.map(idarray, function (id) {
			return "repeating_ability_" + id + "_name";
		}), _underscore2.default.map(idarray, function (id) {
			return "repeating_ability_" + id + "_rule_category";
		}));
		getAttrs(abilityNameAttrs, function (abilityAttrs) {
			var abilityObjList = {};
			var abilityKeys = Object.keys(abilityAttrs);
			var asyncAttrs = {};
			_underscore2.default.each(abilityKeys, function (abilityKey) {
				var rowID;
				if (abilityKey.indexOf("_name") !== -1) {
					rowID = abilityKey.substring("repeating_ability_".length, abilityKey.indexOf("_name"));
					if (_underscore2.default.isUndefined(abilityObjList[rowID])) abilityObjList[rowID] = { rowID: rowID };
					abilityObjList[rowID].name = abilityAttrs[abilityKey];
				}
				if (abilityKey.indexOf("_rule_category") !== -1) {
					rowID = abilityKey.substring("repeating_ability_".length, abilityKey.indexOf("_rule_category"));
					if (_underscore2.default.isUndefined(abilityObjList[rowID])) abilityObjList[rowID] = { rowID: rowID };
					abilityObjList[rowID].rulecategory = abilityAttrs[abilityKey];
				}
			});

			if (!_underscore2.default.isUndefined(characterObj.feats.feat)) {
				var featsArray = _underscore2.default.filter(abilityObjList, _underscore2.default.matcher({ rulecategory: "feats" }));
				var featsList = {};
				_underscore2.default.each(featsArray, function (obj) {
					featsList[obj.rowID] = obj.name;
				});
				characterObj.feats.feat = arrayify(characterObj.feats.feat);
				importFeats(asyncAttrs, characterObj.feats.feat, featsList, resources);
			}

			if (!_underscore2.default.isUndefined(characterObj.traits.trait)) {
				var traitsArray = _underscore2.default.filter(abilityObjList, _underscore2.default.matcher({ rulecategory: "traits" }));
				var traitsList = {};
				_underscore2.default.each(traitsArray, function (obj) {
					traitsList[obj.rowID] = obj.name;
				});
				characterObj.traits.trait = arrayify(characterObj.traits.trait);
				importTraits(asyncAttrs, characterObj.traits.trait, traitsList, resources);
			}

			if (!_underscore2.default.isUndefined(characterObj.spelllike.special)) {
				var SLAsArray = _underscore2.default.filter(abilityObjList, _underscore2.default.matcher({ rulecategory: "spell-like-abilities" }));
				var SLAsList = {};
				_underscore2.default.each(SLAsArray, function (obj) {
					SLAsList[obj.rowID] = obj.name;
				});
				characterObj.spelllike.special = arrayify(characterObj.spelllike.special);
				importSLAs(asyncAttrs, characterObj.spelllike.special, SLAsList, resources);
			}

			var featuresArray = _underscore2.default.filter(abilityObjList, function (obj) {
				if (obj.rulecategory === "traits" || obj.rulecategory === "feats") return false;return true;
			});
			var featuresList = {};
			_underscore2.default.each(featuresArray, function (obj) {
				featuresList[obj.rowID] = obj;
			});
			importFeatures(asyncAttrs, featuresList, specials, archetypes, resources);

			setAttrs(asyncAttrs);
		});
	});

	attrs["experience"] = parseFloat(characterObj.xp._total);

	attrs["class-0-bab"] = parseNum(characterObj.attack._baseattack);

	// Set max hp; remove Con mod from hp first, since the sheet will add that in
	// Since the XML doesn't break this down by class, add it all to class 0
	var level = calcHitDice(characterObj.health._hitdice);
	attrs["class-0-hp"] = parseNum(characterObj.health._hitpoints) - level * parseNum(characterObj.attributes.attribute[2].attrbonus._modified);
	importInit(attrs, characterObj.initiative);
	var racialHD = level - parseNum(characterObj.classes._level);
	if (racialHD > 0) attrs["npc-hd-num"] = racialHD;

	var size = getSizeMod(characterObj.size._name);
	attrs["size"] = size;
	attrs["default_char_size"] = size;

	characterObj.skills.skill = arrayify(characterObj.skills.skill);
	importSkills(attrs, characterObj.skills.skill, size, ACP);

	if (!_underscore2.default.isUndefined(characterObj.senses.special)) {
		characterObj.senses.special = arrayify(characterObj.senses.special);
		attrs["vision"] = buildList(characterObj.senses.special, "_shortname");
	}

	if (!_underscore2.default.isUndefined(characterObj.damagereduction.special)) {
		characterObj.damagereduction.special = arrayify(characterObj.damagereduction.special);
		attrs["DR"] = buildList(characterObj.damagereduction.special, "_shortname");
	}

	if (!_underscore2.default.isUndefined(characterObj.resistances.special)) {
		characterObj.resistances.special = arrayify(characterObj.resistances.special);
		attrs["resistances"] = buildList(characterObj.resistances.special, "_shortname");
	}

	if (!_underscore2.default.isUndefined(characterObj.immunities.special)) {
		characterObj.immunities.special = arrayify(characterObj.immunities.special);
		attrs["immunities"] = buildList(characterObj.immunities.special, "_shortname");
	}

	if (!_underscore2.default.isUndefined(characterObj.weaknesses.special)) {
		characterObj.weaknesses.special = arrayify(characterObj.weaknesses.special);
		attrs["weaknesses"] = buildList(characterObj.weaknesses.special, "_shortname");
	}
	if (!_underscore2.default.isUndefined(characterObj.languages.language)) {
		characterObj.languages.language = arrayify(characterObj.languages.language);
		attrs["languages"] = buildList(characterObj.languages.language, "_name");
	}

	attrs["character_name"] = characterObj._name;
	attrs["player-name"] = characterObj._playername;
	attrs["deity"] = characterObj.deity._name;
	attrs["race"] = characterObj.race._racetext.substr(0, 1).toUpperCase() + characterObj.race._racetext.substr(1, 1000);
	attrs["alignment"] = characterObj.alignment._name;
	attrs["gender"] = characterObj.personal._gender;
	attrs["age"] = characterObj.personal._age;
	attrs["height"] = characterObj.personal.charheight._text;
	attrs["weight"] = characterObj.personal.charweight._text;
	attrs["hair"] = characterObj.personal._hair;
	attrs["eyes"] = characterObj.personal._eyes;
	attrs["skin"] = characterObj.personal._skin;

	attrs["npc-cr"] = characterObj.challengerating._text.replace("CR ", "");
	attrs["npc-xp"] = characterObj.xpaward._value;

	if (!_underscore2.default.isUndefined(characterObj.favoredclasses.favoredclass)) {
		characterObj.favoredclasses.favoredclass = arrayify(characterObj.favoredclasses.favoredclass);
		attrs["class-favored"] = buildList(characterObj.favoredclasses.favoredclass, "_name");
	}
	setAttrs(attrs, {}, function () {
		PFSheet.recalculate();
	});
}
function registerEventHandlers() {
	on("change:herolab_import", function (eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event" + eventInfo.sourceType);
		if (eventInfo.sourceType !== "player") return;
		getAttrs(["herolab_import"], function (values) {
			var xmlObj;
			if (_underscore2.default.isUndefined(values.herolab_import)) return;
			try {
				xmlObj = JSON.parse(values.herolab_import);
				if (_underscore2.default.isArray(xmlObj.document.public.character)) importCharacter(xmlObj.document.public.character[0]);else importCharacter(xmlObj.document.public.character);
				setAttrs({ herolab_import: "" }, { silent: true });
			} catch (err) {
				console.log(err);setAttrs({ herolab_import: err.message }, { silent: true });
			}
		});
	});
}
registerEventHandlers();
_PFLog.PFConsole.log('   HLImport module loaded         ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.write = write;
exports.handleExpression = handleExpression;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var rollOperator;

function parseExpression(s, until) {
  var untilCb = typeof until === "function" ? until : function (tok) {
    return tok == until;
  },

  // constants
  ARG_COUNTS = {
    'abs': 1,
    'ceil': 1,
    'floor': 1,
    'round': 1,
    'max': [1],
    'min': [1]
  },
      BINARY_PRECEDENCE = {
    '?': 1,
    ':': 2,
    '||': 3,
    '&&': 4,
    '|': 5,
    '^': 6,
    '&': 7,
    '=': 8,
    '==': 8,
    '!=': 8,
    '>=': 9,
    '>': 9,
    '<': 9,
    '<=': 9,
    '<<': 10,
    '>>': 10,
    '+': 11,
    '-': 11,
    '*': 12,
    '/': 12,
    '%': 12,
    '**': 14,
    't': 98,
    'd': 99
  },
      UNARY_PRECEDENCE = {
    '!': 13,
    '~': 13,
    '-': 13
  },
      CLOSERS = {
    '(': ")",
    '{': "}"
  },

  // local variables
  operators = [{
    'precedence': 0
  }],
      operands = [],
      tableExp,
      m,
      err,
      operand;
  // helper functions
  function getToken(s) {
    var m;
    if (!s) {
      return s;
    }

    function retVal(tokType, matchObj) {
      return {
        'type': tokType,
        'text': matchObj[0],
        'match': matchObj
      };
    }
    m = s.match(/^\s+/);
    if (m) {
      return retVal("whitespace", m);
    }
    m = s.match(/^(abs|ceil|floor|round|max|min)[(]/);
    if (m) {
      return retVal("function", m);
    }
    m = s.match(/^[({]/);
    if (m) {
      return retVal("opengroup", m);
    }
    m = s.match(/^[)}]/);
    if (m) {
      return retVal("closegroup", m);
    }
    m = s.match(/^((\d+(\.\d+)?)|(\.\d+))/);
    if (m) {
      return retVal("number", m);
    }
    m = s.match(/^['"]/);
    if (m) {
      return retVal("quote", m);
    }
    m = s.match(/^((\|\|)|(&&)|(==)|(!=)|(>=)|(<=)|(<<)|(>>)|(\*\*)|[?:|\^&=><%!~])/);
    if (m) {
      return retVal("extoperator", m);
    }
    m = s.match(/^[\-+*\/td]/);
    if (m) {
      return retVal("baseoperator", m);
    }
    m = s.match(/^\[([^\]]+)\]/);
    if (m) {
      return retVal("label", m);
    }
    m = s.match(/^\$\{([^'"\($\}][^}]*)\}/);
    if (m) {
      return retVal("variable", m);
    }
    m = s.match(/^\$\{/);
    if (m) {
      return retVal("openvariable", m);
    }
    return {
      'type': "raw",
      'text': s.charAt(0)
    };
  }

  function popToken(state) {
    state.tok = getToken(state.s);
    if (state.tok) {
      state.s = state.s.substring(state.tok.text.length);
    }
    return state;
  }

  function popString(state, delim) {
    var i = -1,
        j = i,
        retval;
    // find first index of delim not preceded by an odd number of backslashes
    while ((i - j & 1) === 0) {
      i = state.s.indexOf(delim, i + 1);
      if (i < 0) {
        return;
      }
      j = i - 1;
      while (j >= 0 && state.s.charAt(j) === '\\') {
        j--;
      }
    }
    // unescape string to be returned
    function replaceEscapes(s) {
      return s.replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\t/g, "\t").replace(/\\/g, "");
    }
    retval = state.s.substring(0, i).split("\\\\").map(replaceEscapes).join("\\");
    // point state delim, then pop off the delimiter token
    state.s = state.s.substring(i);
    popToken(state);
    return retval;
  }

  function popOperator() {
    var op = operators.pop(),
        right = operands.pop(),
        left,
        cond,
        datatype;
    if (op.unary) {
      operands.push({
        'type': op.type === "baseoperator" ? "unop" : "unopex",
        'datatype': right.datatype,
        'operator': op.text,
        'operand': right
      });
      return;
    }
    left = operands.pop();
    if (op.text !== ":") {
      if (op.text === "d" || op.text === "t") {
        datatype = "number";
      } else if (left.datatype === right.datatype) {
        datatype = left.datatype;
      } else if (left.datatype === "string" || right.datatype === "string") {
        datatype = "string";
      }
      operands.push({
        'type': op.type === "baseoperator" ? "binop" : "binopex",
        'datatype': datatype,
        'operator': op.text,
        'left': left,
        'right': right,
        'mods': op.mods,
        'label': op.label
      });
      return;
    }
    op = operators.pop();
    if (op.text !== "?") {
      return "Error: Expected ? but got " + op.text;
    }
    cond = operands.pop();
    operands.push({
      'type': "cond",
      'cond': cond,
      'left': left,
      'right': right,
      'datatype': left.datatype === right.datatype ? left.datatype : undefined
    });
  }

  function pushOperator(op) {
    var err;
    op.precedence = (op.unary ? UNARY_PRECEDENCE[op.text] : BINARY_PRECEDENCE[op.text]) || 0;
    while (operators[operators.length - 1].precedence >= op.precedence) {
      err = popOperator();
      if (err) {
        return err;
      }
    }
    operators.push(op);
  }

  function argListUntil(tok) {
    return tok === ',' || tok === ')';
  }

  function parseHelper() {
    var err, func, argCounts, minArgs, maxArgs, str, args, argTree, opener, closer, operand, varExp;
    popToken(s);
    if (!s.tok) {
      return "Error: Unrecognized token: " + s.s.split(" ", 1)[0];
    }
    while (s.tok.type === "whitespace") {
      popToken(s);
      if (!s.tok) {
        return "Error: Unrecognized token: " + s.s.split(" ", 1)[0];
      }
    }
    switch (s.tok.type) {
      case "function":
        func = s.tok.match[1];
        argCounts = ARG_COUNTS[func];
        if (argCounts === undefined) {
          return "Error: Unrecognized function: " + func;
        }
        if (Array.isArray(argCounts)) {
          minArgs = argCounts[0];
          maxArgs = argCounts[1];
        } else {
          minArgs = argCounts;
          maxArgs = argCounts;
        }
        args = [];
        while (s.tok && s.tok.text !== ')') {
          argTree = parseExpression(s, argListUntil);
          if (typeof argTree === "string") {
            return argTree;
          } // error
          args.push(argTree);
          if (!s.tok) {
            return "Error: Unterminated function: " + func;
          }
          if (!argListUntil(s.tok.text)) {
            return "Error: Expected ',' or ')' to continue/close '" + func + "(', but got '" + s.tok.text + "'";
          }
        }
        if (minArgs < 0) {
          minArgs = args.length;
        }
        if (isNaN(maxArgs) || maxArgs < 0) {
          maxArgs = args.length;
        }
        if (args.length < minArgs) {
          return "Error: Function '" + func + "' requires at least " + minArgs + " argument(s)";
        }
        if (args.length > maxArgs) {
          return "Error: Function '" + func + "' requires at most " + maxArgs + " argument(s)";
        }
        operands.push({
          'type': "function",
          'datatype': "number",
          'function': func,
          'args': args
        });
        return;
      case "number":
        operands.push({
          'type': "number",
          'datatype': "number",
          'value': parseFloat(s.tok.text)
        });
        return;
      case "variable":
        operands.push({
          'type': "variable",
          'value': s.tok.match[1]
        });
        return;
      case "quote":
        str = popString(s, s.tok.text);
        if (typeof str !== "string") {
          return "Error: Unterminated string";
        }
        operands.push({
          'type': "string",
          'datatype': "string",
          'value': str
        });
        return;
      case "opengroup":
        opener = s.tok.text;
        closer = CLOSERS[opener];
        operand = parseExpression(s, closer);
        if (typeof operand === "string") {
          return operand;
        } // error
        operands.push(operand);
        if (s.tok.text !== closer) {
          return "Error: Expected '" + closer + "' to close '" + opener + "', but got '" + s.tok.text + "'";
        }
        return;
      case "openvariable":
        varExp = parseExpression(s, "}");
        if (typeof varExp === "string") {
          return varExp;
        } // error
        if (s.tok.text !== "}") {
          return "Error: Expected '}' to close '${', but got '" + s.tok.text + "'";
        }
        operands.push({
          'type': "variable",
          'value': varExp
        });
        return;
      case "extoperator":
      case "baseoperator":
        if (!UNARY_PRECEDENCE[s.tok.text]) {
          return "Error: " + s.tok.text + " is not a unary operator";
        }
        s.tok.unary = true;
        err = pushOperator(s.tok);
        if (err) {
          return err;
        }
        return parseHelper();
    }
    return "Error: Unrecognized token: " + s.tok.text + (s.tok.type === "raw" ? s.s.split(" ", 1)[0] : "");
  }
  // if we were given a string, construct a state object
  if (typeof s === "string") {
    s = {
      's': s
    };
  }
  // push operators and operands to their respective stacks, building sub-ASTs in the operand stack as needed
  err = parseHelper();
  if (err) {
    return err;
  }
  for (popToken(s); s.tok && !untilCb(s.tok.text) && (until || s.tok.type !== "raw"); popToken(s)) {
    switch (s.tok.type) {
      case "extoperator":
      case "baseoperator":
        rollOperator = s.tok.text === "d" ? s.tok : null;
        err = pushOperator(s.tok);
        if (err) {
          return err;
        }
        if (rollOperator && s.s.charAt(0) === 'F') {
          operands.push({
            'type': "rollspec",
            'value': "F"
          });
          s.s = s.s.substring(1);
        } else if (s.tok.text === "t") {
          if (s.s.charAt(0) !== '[') {
            return "Error: 't' operator requires '[table]' argument";
          }
          m = s.s.match(/^\[([^'"$(\]][^\]]*)\]/);
          if (m) {
            tableExp = m[1];
            s.s = s.s.substring(m[0].length);
          } else {
            s.s = s.s.substring(1);
            tableExp = parseExpression(s, "]");
            if (typeof tableExp === "string") {
              return tableExp;
            } // error
            if (s.tok.text !== "]") {
              return "Error: Expected ']' to close 't[', but got '" + s.tok.text + "'";
            }
          }
          operands.push({
            'type': "tablename",
            'value': tableExp
          });
        } else {
          err = parseHelper();
          if (err) {
            return err;
          }
        }
        if (rollOperator) {
          m = s.s.match(/^[acdfhkloprs0-9<=>!]+/);
          if (m) {
            rollOperator.mods = m[0];
            s.s = s.s.substring(m[0].length);
          }
        }
        break;
      case "label":
        if (operators.length > 0 && operators[operators.length - 1].text === "d") {
          // set label on "d" operator instead of operand (e.g. "1d6[foo]" is "(1d6)[foo]", not "1d(6[foo])")
          operators[operators.length - 1].label = s.tok.match[1];
          break;
        }
        operand = operands.pop();
        if (operand) {
          operand.label = s.tok.match[1];
          operands.push(operand);
        }
        break;
    }
  }
  // no more input; collapse remaining operators and operands into a single AST
  while (operators.length > 1) {
    err = popOperator();
    if (err) {
      return err;
    }
  }
  return operands.pop();
}
function write(s) {
  _exportsLoaderTASTheAaronSheet2.default.debug("EXEXP:" + s);
}
function sendCommand(chunks, asts, evalResults, labels) {
  //infinite loop
  //TAS.debug("at sendCommand");
  //TAS.debug(chunks, asts, evalResults, labels);
  // constants
  var FUNCTION_FUNCTIONS = {
    'abs': Math.abs,
    'ceil': Math.ceil,
    'floor': Math.floor,
    'round': Math.round,
    'max': Math.max,
    'min': Math.min
  },
      BINARY_FUNCTIONS = {
    '||': function _(x, y) {
      return x || y;
    },
    '&&': function _(x, y) {
      return x && y;
    },
    '|': function _(x, y) {
      return x | y;
    },
    '^': function _(x, y) {
      return x ^ y;
    },
    '&': function _(x, y) {
      return x & y;
    },
    '=': function _(x, y) {
      return x == y;
    },
    '==': function _(x, y) {
      return x === y;
    },
    '!=': function _(x, y) {
      return x != y;
    },
    '>=': function _(x, y) {
      return x >= y;
    },
    '>': function _(x, y) {
      return x > y;
    },
    '<': function _(x, y) {
      return x < y;
    },
    '<=': function _(x, y) {
      return x <= y;
    },
    '<<': function _(x, y) {
      return x << y;
    },
    '>>': function _(x, y) {
      return x >> y;
    },
    '+': function _(x, y) {
      return x + y;
    },
    '-': function _(x, y) {
      return x - y;
    },
    '*': function _(x, y) {
      return x * y;
    },
    '/': function _(x, y) {
      return x / y;
    },
    '%': function _(x, y) {
      return x % y;
    },
    '**': Math.pow,
    'd': function d(x, y) {
      var retval = 0,
          i = 0;
      for (i = 0; i < x; i++) {
        retval += randomInteger(y);
      }
      return retval;
    }
  },
      UNARY_FUNCTIONS = {
    '!': function _(x) {
      return !x;
    },
    '~': function _(x) {
      return ~x;
    },
    '-': function _(x) {
      return -x;
    }
  },

  // local variables
  references = {},
      unevalRefs = [],
      evalReqs = [],
      i = 0,
      t,
      err,
      doSubstitution = false,
      label,
      newUneval = [],
      r,
      retval;
  // helper functions
  function lazyEval(t, labels, references, unevalRefs, evalReqs, force) {
    //alert(' at lazyEval, t: ' + t + ', t.type:'+t.type);
    var x,
        y,
        args = [],
        i = 0,
        forceSubtrees;
    if (t.label) {
      labels[t.label] = t;
    }
    switch (t.type) {
      case "number":
      case "rollspec":
        t.baseValid = true;
        return t;
      case "string":
        return t;
      case "tablename":
        if (typeof t.value !== "string") {
          x = lazyEval(t.value, labels, references, unevalRefs, evalReqs, true);
          if (typeof x === "string") {
            return x;
          } // error
          if (x.type === "number") {
            // number node; coerce to string
            x.value = String(x.value);
            x.type = "string";
          }
          if (x.type !== "string") {
            // unable to fully evaluate table name
            if (t.baseValid) {
              t.baseValid = false;
            }
            unevalRefs.push(t.value);
            return t;
          }
          // successfully evaluated table name
          t.value = x.value;
        }
        // if we got here, t.value is the name of a rollable table
        t.baseValid = true;
        return t;
      case "function":
        for (i = 0; i < t.args.length; i++) {
          x = lazyEval(t.args[i], labels, references, unevalRefs, evalReqs, true);
          if (typeof x === "string") {
            return x;
          } // error
          if (x.type === "string") {
            x.value = parseFloat(x.value);
            x.type = "number";
          }
          if (x.type !== "number") {
            // unable to fully evaluate argument
            if (t.baseValid) {
              t.baseValid = false;
            }
            return t;
          }
          args.push(x.value);
        }
        // successfully evaluated all arguments
        t.type = "number";
        t.datatype = "number";
        t.value = FUNCTION_FUNCTIONS[t["function"]].apply(args, args);
        for (i = 0; i < t.args.length; i++) {
          if (t.args[i].label) {
            labels[t.args[i].label] = t.args[i];
          }
        }
        delete t["function"];
        delete t.args;
        t.baseValid = true;
        return t;
      case "unop":
      case "unopex":
        force = force || t.type !== "unop";
        x = lazyEval(t.operand, labels, references, unevalRefs, evalReqs, force);
        if (typeof x === "string") {
          return x;
        } // error
        if (force) {
          if (x.type !== "number") {
            // unable to fully evaluate operand
            if (t.baseValid) {
              t.baseValid = false;
            }
            return t;
          }
          // successfully evaluated operand
          t.type = "number";
          t.datatype = "number";
          t.value = UNARY_FUNCTIONS[t.operator](x.value);
          delete t.operator;
          if (t.operand.label) {
            labels[t.operand.label] = x;
          }
          delete t.operand;
          t.baseValid = true;
        } else {
          t.baseValid = x.baseValid;
        }
        return t;
      case "binop":
      case "binopex":
        force = force || t.type !== "binop" || t.left.datatype === "string" || t.right.datatype === "string";
        forceSubtrees = force || t.operator === "d" || t.operator === "t";
        //TAS.debug('left is: ' + t.left + ', right is:' + t.right);
        x = lazyEval(t.left, labels, references, unevalRefs, evalReqs, forceSubtrees);
        y = lazyEval(t.right, labels, references, unevalRefs, evalReqs, forceSubtrees);
        //TAS.debug(x);
        //TAS.debug(y);
        force = true;
        /*********************didn't work until i commented out, now seems to have no effect ********************************/
        if (typeof x === "string") {
          //TAS.debug(x);
          return x;
        } // error
        if (typeof y === "string") {
          //TAS.debug(y);
          return y;
        } // error
        /****************************************************/
        if (force) {
          if (x.type !== "number" && x.type !== "string") {
            // unable to fully evaluate left operand
            if (t.baseValid) {
              t.baseValid = false;
            }
            return t;
          }
          if (y.type !== "number" && y.type !== "string" && y.type !== "rollspec" && y.type !== "tablename") {
            // unable to fully evaluate right operand
            if (t.baseValid) {
              t.baseValid = false;
            }
            return t;
          }
          if (y.type === "rollspec" && t.operator !== "d") {
            return "Rollspec operand is only compatible with 'd' operator";
          }
          if (t.operator === "t" && y.type !== "tablename") {
            return "'t' operator requires tablename operand";
          }
          // successfully evaluated both operands
          if (t.operator === "t" || t.operator === "d" && t.mods) {
            // operator is rollable table or is roll with mods; must submit to base system for evaluation
            evalReqs.push(t);
            return t;
          }
          //TAS.debug('about to call binary');
          t.value = BINARY_FUNCTIONS[t.operator](x.value, y.value);
          delete t.operator;
          if (t.left.label) {
            labels[t.left.label] = x;
          }
          delete t.left;
          if (t.right.label) {
            labels[t.right.label] = y;
          }
          delete t.right;
          t.type = typeof t.value === "string" ? "string" : "number";
          t.datatype = t.type;
          t.baseValid = t.datatype === "number";
        } else if (x.datatype === "number" && y.datatype === "number") {
          t.datatype = "number";
          t.baseValid = true;
        }
        return t;
      case "cond":
        x = lazyEval(t.cond, labels, references, unevalRefs, evalReqs, true);
        if (typeof x === "string") {
          return x;
        } // error
        if (x.type !== "number" && x.type !== "string") {
          // unable to fully evaluate condition
          t.baseValid = false;
          return t;
        }
        // successfully evaluated condition; replace t with t.left or t.right as appropriate
        y = x.value ? t.left : t.right;
        if (t.cond.label) {
          labels[t.cond.label] = x;
        }
        delete t.cond;
        delete t.left;
        delete t.right;
        _underscore2.default.each(y, function (k) {
          t[k] = y[k];
        });
        return lazyEval(t, labels, references, unevalRefs, evalReqs, force);
      case "variable":
        if (typeof t.value !== "string") {
          x = lazyEval(t.value, labels, references, unevalRefs, evalReqs, true);
          if (typeof x === "string") {
            return x;
          } // error
          if (x.type === "number") {
            // number node; coerce to string
            x.value = String(x.value);
            x.type = "string";
          }
          if (x.type !== "string") {
            // unable to fully evaluate variable name
            if (t.baseValid) {
              t.baseValid = false;
            }
            unevalRefs.push(t.value);
            return t;
          }
          // successfully evaluated variable name
          t.value = x.value;
        }
        // if we got here, t.value is the name of a variable
        if (labels[t.value] && (labels[t.value].type === "string" || labels[t.value].type === "number")) {
          // variable exists and has been fully evaluated
          t.type = labels[t.value].type;
          t.datatype = labels[t.value].datatype;
          t.baseValid = labels[t.value].baseValid;
          t.value = labels[t.value].value;
        } else {
          // variable not yet defined or not yet fully evaluated
          if (!references[t.value]) {
            references[t.value] = [];
          }
          references[t.value].push(t);
          if (t.baseValid) {
            t.baseValid = false;
          }
        }
        return t;
      default:
        return "Unknown node type: " + t.type;
    }
  }

  function hasUnevaluatedLabels(t) {
    var i = 0;
    // base types: fully evaluated
    if (t.type === "number" || t.type === "string" || t.type === "rollspec") {
      return false;
    }
    // if we got here, node is unevaluated
    if (t.label) {
      return true;
    }
    // node has no label; check children
    switch (t.type) {
      case "function":
        for (i = 0; i < t.args.length; i++) {
          if (hasUnevaluatedLabels(t.args[i])) {
            return true;
          }
        }
        return false;
      case "tablename":
      case "variable":
        if (typeof t.value === "string") {
          return false;
        }
        return hasUnevaluatedLabels(t.value);
      case "unop":
      case "unopex":
        return hasUnevaluatedLabels(t.operand);
      case "cond":
        if (hasUnevaluatedLabels(t.cond)) {
          return true;
        }
        //don't fall through
        if (hasUnevaluatedLabels(t.left)) {
          return true;
        }
        return hasUnevaluatedLabels(t.right);
      case "binop":
      case "binopex":
        if (hasUnevaluatedLabels(t.left)) {
          return true;
        }
        return hasUnevaluatedLabels(t.right);
    }
  }

  function flattenAST(t) {
    var retval;
    switch (t.type) {
      case "number":
      case "rollspec":
        retval = t.value || 0;
        break;
      case "tablename":
        retval = "[" + t.value + "]";
        break;
      case "unop":
        retval = "(" + t.operator + flattenAST(t.operand) + ")";
        break;
      case "binop":
        retval = "(" + flattenAST(t.left) + t.operator + flattenAST(t.right) + (t.mods || "") + ")";
        if (t.label && t.operator === "d") {
          retval += "[" + t.label + "]";
        }
        break;
      default:
        return "Unknown node type: " + t.type;
    }
    return retval;
  }

  function astToCmd(t) {
    if (t.type === "string") {
      return t.value;
    }
    var retval = flattenAST(t);
    return retval;
  }

  function reportError(err) {
    write("Error: " + err);
    return "";
  }
  //BEGIN
  // substitute in results of base evaluation
  for (i = 0; i < evalResults.length; i++) {
    t = evalResults[i][0];
    delete t.operator;
    delete t.left;
    delete t.right;
    t.type = "number";
    t.datatype = "number";
    t.value = evalResults[i][1];
    t.baseValid = true;
  }
  // traverse ASTs, collapsing as much as possible
  for (i = 0; i < asts.length; i++) {
    if (asts[i].baseValid) {
      continue;
    } // can be handled by base expression evaluator
    if (asts[i].type === "string" || asts[i].type === "number") {
      continue;
    } // tree is fully evaluated
    err = lazyEval(asts[i], labels, references, unevalRefs, evalReqs, false);
    if (typeof err === "string") {
      return reportError(err);
    }
  }
  // do variable substitution; repeat until we don't make any more progress
  doSubstitution = true;
  while (doSubstitution) {
    doSubstitution = false;
    // substitute in values for variables for which we already have names
    for (label in references) {
      if (references.hasOwnProperty(label)) {
        if (!labels[label]) {
          return reportError("Variable '" + label + "' not defined");
        }
        if (labels[label].type !== "string" && labels[label].type !== "number") {
          // variable exists but not yet evaluated; try to evaluate
          err = lazyEval(labels[label], labels, references, unevalRefs, evalReqs, true);
          if (typeof err === "string") {
            return reportError(err);
          }
        } else if (labels[label].type === "string" || labels[label].type === "number") {
          // variable fully evaluated; substitute it in
          for (i = 0; i < references[label].length; i++) {
            references[label][i].type = labels[label].type;
            references[label][i].datatype = labels[label].datatype;
            references[label][i].value = labels[label].value;
            references[label][i].baseValid = labels[label].baseValid;
          }
          delete references[label];
          doSubstitution = true;
        }
      }
    }
    // try to get names for variables and tables with unevaluated names
    while (unevalRefs.length > 0) {
      r = lazyEval(unevalRefs.shift(), labels, references, unevalRefs, evalReqs, true);
      if (typeof r === "string") {
        return reportError(err);
      }
      if (r.type === "string" || r.type === "number") {
        doSubstitution = true;
      } else {
        newUneval.push(r);
      }
    }
    unevalRefs = newUneval;
  }
  // flatten fully evaluated ASTs into strings and splice into chunks
  for (i = asts.length - 1; i >= 0; i--) {
    if (!asts[i].baseValid && asts[i].type !== "number" && asts[i].type !== "string") {
      continue;
    }
    if (unevalRefs.length > 0 & hasUnevaluatedLabels(asts[i])) {
      continue;
    }
    chunks.splice(i, 2, (chunks[i] || "") + astToCmd(asts.splice(i, 1)[0]) + (chunks[i + 1] || ""));
  }
  if (evalReqs.length > 0) {
    _exportsLoaderTASTheAaronSheet2.default.error("Cannot evaluate");
    return "";
  }
  if (asts.length > 0) {
    // need to finish evaluating some ASTs; recurse directly
    //TAS.debug("sendCommand (recurse), asts.length=" + asts.length + ", asts[0].baseValid=" + asts[0].baseValid + ", asts[0].type=" + asts[0].type);
    if (!(asts.length === 1 && asts[0].type === "binop")) {
      // HACK! minus (probably) in front; no math needed
      return sendCommand(chunks, asts, [], labels);
    }
  }
  // if we got here, we're done evaluating everything; submit results
  retval = chunks.join("");
  return retval;
}
function handleExpression(msg) {
  //replace spaces. replace "-" in front with "0-", replace "(-" with "(0-"
  //also replace leading + with '', and replace (+  with (0+
  var chunks = [],
      asts = [],
      cmd,
      state,
      ast;
  msg = msg.replace(/\s/g, '').replace(/^-/, '0-').replace(/\(-/g, '(0-').replace(/^\+/, '').replace(/\(\+/g, '(0+');
  cmd = msg;
  state = {
    's': cmd
  };
  //TAS.debug(msg);
  ast = parseExpression(state, null);
  //TAS.debug(ast);
  if (typeof ast === "string") {
    write("could not parse" + msg);
    return "";
  }
  asts.push(ast);
  state.s = state.tok ? state.tok.text + state.s : state.s;
  //  ((state.tok || {'text': ""}).text || "") + state.s;
  chunks.push(state.s);
  return sendCommand(chunks, asts, [], {});
}

_PFLog.PFConsole.log('   ExExp module loaded            ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFInitiative = __webpack_require__(22);

var PFInitiative = _interopRequireWildcard(_PFInitiative);

var _PFSpellCasterClasses = __webpack_require__(24);

var PFSpellCasterClasses = _interopRequireWildcard(_PFSpellCasterClasses);

var _PFSkills = __webpack_require__(16);

var PFSkills = _interopRequireWildcard(_PFSkills);

var _PFAbilityScores = __webpack_require__(11);

var PFAbilityScores = _interopRequireWildcard(_PFAbilityScores);

var _PFSaves = __webpack_require__(23);

var PFSaves = _interopRequireWildcard(_PFSaves);

var _PFAttackGrid = __webpack_require__(7);

var PFAttackGrid = _interopRequireWildcard(_PFAttackGrid);

var _PFDefense = __webpack_require__(13);

var PFDefense = _interopRequireWildcard(_PFDefense);

var _PFHealth = __webpack_require__(21);

var PFHealth = _interopRequireWildcard(_PFHealth);

var _PFChecks = __webpack_require__(19);

var PFChecks = _interopRequireWildcard(_PFChecks);

var _PFAttacks = __webpack_require__(8);

var PFAttacks = _interopRequireWildcard(_PFAttacks);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* updateGrapple Ensures Grapple and Pin are mutually exclusive */
function updateGrapple() {
	getAttrs(["condition-Pinned", "condition-Grappled"], function (values) {
		if (values["condition-Pinned"] !== "0" && values["condition-Grappled"] !== "0") {
			setAttrs({
				"condition-Pinned": "0"
			});
		} else {
			//user hit either pinned and it undid grapple, or hit grapple first time.
			PFAbilityScores.applyConditions();
		}
	});
}
/* updatePin Ensures Grapple and Pin are mutually exclusive */
function updatePin() {
	getAttrs(["condition-Pinned", "condition-Grappled"], function (values) {
		if (values["condition-Pinned"] !== "0" && values["condition-Grappled"] !== "0") {
			setAttrs({
				"condition-Grappled": "0"
			});
		} else {
			//user hit grapple and it  undid pinned, or hit pinned first time.
			PFAbilityScores.applyConditions();
		}
	});
}
/* updates drain for condition status panel */
function updateDrainCheckbox(callback, silently, eventInfo) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("Leaving PFConditions.updateDrainCheckbox");
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["condition-Drained", "condition_is_drained"], function (v) {
		var levels = parseInt(v["condition-Drained"], 10) || 0,
		    drained = parseInt(v["condition_is_drained"], 10) || 0;
		_exportsLoaderTASTheAaronSheet2.default.debug("################", "PFConditions.updateDrainCheckbox we found ", v, " and levels=" + levels + ", drained=" + drained, "##############");
		if (levels !== 0 && drained === 0) {
			setAttrs({
				"condition_is_drained": "1"
			}, _PFConst2.default.silentParams, done);
		} else if (levels === 0 && drained !== 0) {
			setAttrs({
				"condition_is_drained": "0"
			}, _PFConst2.default.silentParams, done);
		} else {
			done();
		}
	});
}
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("Leaving PFConditions.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	});
	updateDrainCheckbox(done);
	//PFAbilityScores.applyConditions(done);
}

var events = {
	conditionEventsEither: {
		"change:condition-grappled": [updateGrapple, PFAttackGrid.applyConditions],
		"change:condition-pinned": [updatePin, PFDefense.applyConditions],
		"change:condition-wounds change:has_endurance_feat change:wounds_gritty_mode": [PFChecks.applyConditions, PFSaves.applyConditions, PFAttackGrid.applyConditions, PFDefense.applyConditions]
	},
	conditionEventsPlayer: {
		"change:condition-Sickened": [PFAttacks.updateRepeatingWeaponDamages, PFChecks.applyConditions, PFSaves.applyConditions, PFAttackGrid.applyConditions],
		"change:condition-stunned": [PFDefense.updateDefenses, PFDefense.applyConditions],
		"change:condition-Flat-Footed": [PFDefense.updateDefenses],
		"change:condition-deafened": [PFInitiative.updateInitiative, PFSpellCasterClasses.applyConditions],
		"change:condition-fatigued": [PFAbilityScores.applyConditions],
		"change:condition-entangled": [PFAbilityScores.applyConditions, PFAttackGrid.applyConditions],
		"change:condition-drained": [updateDrainCheckbox, PFHealth.updateMaxHPLookup, PFChecks.applyConditions, PFSaves.applyConditions, PFAttackGrid.applyConditions, PFDefense.applyConditions],
		"change:condition-fear": [PFChecks.applyConditions, PFSaves.applyConditions, PFAttackGrid.applyConditions],
		"change:condition-blinded": [PFChecks.applyConditions, PFDefense.applyConditions],
		"change:condition-cowering": [PFDefense.applyConditions],
		"change:condition-invisible": [PFDefense.updateDefenses, PFDefense.applyConditions, PFAttackGrid.applyConditions],
		"change:condition-dazzled": [PFAttackGrid.applyConditions],
		"change:condition-prone": [PFAttackGrid.applyConditions],
		"change:condition-Helpless": [PFAbilityScores.applyConditions]
	}
};

function registerEventHandlers() {
	_underscore2.default.each(events.conditionEventsPlayer, function (functions, eventToWatch) {
		_underscore2.default.each(functions, function (methodToCall) {
			on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventConditionEventsPlayer(eventInfo) {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
				if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
					methodToCall(null, null, eventInfo);
				}
			}));
		});
	});
	_underscore2.default.each(events.conditionEventsEither, function (functions, eventToWatch) {
		_underscore2.default.each(functions, function (methodToCall) {
			on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventConditionEventsEither(eventInfo) {
				_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
				methodToCall(null, null, eventInfo);
			}));
		});
	});
	on("change:Perception-cond", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateSkillPerceptionCond(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		PFSkills.verifyHasSkill("Perception", function (hasSkill) {
			if (hasSkill) {
				PFSkills.updateSkill("Perception", eventInfo);
			} else {
				PFSkills.updateSkill("CS-Perception", eventInfo);
			}
		});
	}));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFConditions module loaded     ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function setSanityThreshold(callback) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    };
    getAttrs(['use_horror_adventures', 'sanity_threshold', 'sanity-ability-mod', 'sanity_threshold_misc-mod'], function (v) {
        var currThreshold = 0,
            newThreshold = 0,
            setter = {};
        try {
            _exportsLoaderTASTheAaronSheet2.default.debug("At PFHorror.setSanityThreshold:", v);
            if (parseInt(v.use_horror_adventures, 10)) {
                currThreshold = parseInt(v.sanity_threshold, 10) || 0;
                newThreshold = (parseInt(v['sanity-ability-mod'], 10) || 0) + (parseInt(v['sanity_threshold_misc-mod'], 10) || 0);
                newThreshold = Math.max(1, newThreshold);
                if (currThreshold !== newThreshold) {
                    setter.sanity_threshold = newThreshold;
                }
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFHorror.setSanityThreshold error", err);
        } finally {
            if (_underscore2.default.size(setter)) {
                setAttrs(setter, _PFConst2.default.silentParams, done);
            } else {
                done();
            }
        }
    });
}

function setSanityScore(callback) {
    var done = function done() {
        if (typeof callback === "function") {
            callback();
        }
    };
    getAttrs(['use_horror_adventures', 'sanity_score_max', 'sanity_edge', 'sanity_score_misc-mod', 'WIS', 'INT', 'CHA', 'WIS-damage', 'INT-damage', 'CHA-damage', 'WIS-penalty', 'INT-penalty', 'CHA-penalty', 'buff_WIS-total_penalty', 'buff_INT-total_penalty', 'buff_CHA-total_penalty'], function (v) {
        var currSanity = 0,
            newSanity = 0,
            newEdge = 0,
            setter = {};
        try {
            _exportsLoaderTASTheAaronSheet2.default.debug("At PFHorror.setSanityScore:", v);
            if (parseInt(v.use_horror_adventures, 10)) {
                currSanity = parseInt(v.sanity_score_max, 10) || 0;
                newSanity = (parseInt(v['sanity_score_misc-mod'], 10) || 0) + (parseInt(v['WIS'], 10) || 0) + (parseInt(v['INT'], 10) || 0) + (parseInt(v['CHA'], 10) || 0) + (parseInt(v['WIS-damage'], 10) || 0) + (parseInt(v['INT-damage'], 10) || 0) + (parseInt(v['CHA-damage'], 10) || 0) + (parseInt(v['WIS-penalty'], 10) || 0) + (parseInt(v['INT-penalty'], 10) || 0) + (parseInt(v['CHA-penalty'], 10) || 0) + (parseInt(v['buff_WIS-total_penalty'], 10) || 0) + (parseInt(v['buff_INT-total_penalty'], 10) || 0) + (parseInt(v['buff_CHA-total_penalty'], 10) || 0);
                if (currSanity !== newSanity) {
                    newEdge = Math.floor(newSanity / 2);
                    setter.sanity_score_max = newSanity;
                    setter.sanity_edge = newEdge;
                }
            }
        } catch (err) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFHorror.setSanityScore error", err);
        } finally {
            if (_underscore2.default.size(setter)) {
                setAttrs(setter, _PFConst2.default.silentParams, done);
            } else {
                done();
            }
        }
    });
}

function recalculate(callback) {
    setSanityScore();
    setSanityThreshold();
    if (typeof callback === "function") {
        callback();
    }
}

function registerEventHandlers() {
    on("change:sanity_score_misc-mod change:WIS change:INT change:CHA change:buff_WIS-total_penalty change:buff_INT-total_penalty change:buff_CHA-total_penalty", _exportsLoaderTASTheAaronSheet2.default.callback(function eventAllMentalStatsAutoUpdate(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "sheetworker") {
            setSanityScore();
        }
    }));
    on("change:WIS-damage change:INT-damage change:CHA-damage change:WIS-penalty change:INT-penalty change:CHA-penalty", _exportsLoaderTASTheAaronSheet2.default.callback(function eventAllMentalStatsPlayerUpdate(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
            setSanityScore();
        }
    }));
    on("change:sanity-ability-mod change:sanity_threshold_misc-mod", _exportsLoaderTASTheAaronSheet2.default.callback(function eventThresholdUpdate(eventInfo) {
        _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
        if (eventInfo.sourceType === "sheetworker") {
            setSanityThreshold();
        }
    }));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFHorror module loaded         ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* updateMythicPathHP
* Updates total at bottom of Mythic Path Information grid */
function updateMythicPathHP(callback, silently) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["mythic-tier", "mythic-hp", "total-mythic-hp"], function (values) {
		var tot = 0,
		    currTot = 0,
		    setter = {},
		    params = {};
		try {
			tot = (parseInt(values["mythic-tier"], 10) || 0) * (parseInt(values["mythic-hp"], 10) || 0);
			currTot = parseInt(values["total-mythic-hp"], 10) || 0;
			//TAS.debug("tot=" + tot + ", currTot=" + currTot);
			if (currTot !== tot) {
				setter["total-mythic-hp"] = tot;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFMythic.updateTierMythicPower error", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				if (silently) {
					params = _PFConst2.default.silentParams;
				}
				setAttrs(setter, params, done);
			} else {
				done();
			}
		}
	});
}
/* updateTierMythicPower sets tier mp*/
function updateTierMythicPower(callback, silently) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	//TAS.debug("entered updateTierMythicPower");
	getAttrs(["tier-mythic-power", "mythic-tier"], function (values) {
		var totalTier,
		    curr,
		    setter = {},
		    params = {},
		    finished = false;
		try {
			totalTier = 3 + 2 * (parseInt(values["mythic-tier"], 10) || 0);
			curr = parseInt(values["tier-mythic-power"], 10) || 0;
			//TAS.debug("totalTier=" + totalTier + ", curr=" + curr);
			if (curr !== totalTier) {
				setter["tier-mythic-power"] = totalTier;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFMythic.updateTierMythicPower error", err);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				if (silently) {
					params = _PFConst2.default.silentParams;
				}
				setAttrs(setter, params, done);
			} else {
				done();
			}
		}
	});
}
function migrate(callback) {
	if (typeof callback === "function") {
		callback();
	}
}
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("Leaving PFMythic.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["mythic-adventures-show"], function (v) {
		try {
			if (parseInt(v["mythic-adventures-show"], 10) === 1) {
				updateMythicPathHP(done, silently);
				updateTierMythicPower();
			} else {
				done();
			}
		} catch (err2) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFMythic.recalculate", err2);
			done();
		}
	});
}
function registerEventHandlers() {
	//mythic path and power
	on("change:mythic-tier change:mythic-hp", _exportsLoaderTASTheAaronSheet2.default.callback(function eventupdateMythicPathHP(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			updateMythicPathHP();
			updateTierMythicPower();
		}
	}));
	//mythic path
	on("change:mythic-hp", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateTierMythicPower(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			updateMythicPathHP();
		}
	}));
	on("change:misc-mythic-power change:tier-mythic-power", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdateMythicPower(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api" || eventInfo.sourceType === "sheetworker" && eventInfo.sourceAttribute === 'tier-mythic-power') {
			SWUtils.updateRowTotal(["mythic-power_max", "tier-mythic-power", "misc-mythic-power"]);
		}
	}));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFMythic module loaded         ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.setToNPC = setToNPC;
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* setToNPC when first setting a sheet , set other default config settings
* also switch to NPC page for when user leaves ocnfig page.
*/
function setToNPC(callback, eventInfo) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["npc-hd", "PFSheet_Version", "npc-hd-num", "level", "hp", "hp_max", "is_newsheet", "npc-type"], function (v) {
		//determine if this is a new sheet. if so set default config choices:
		if (parseInt(v.is_newsheet, 10) || (parseInt(v.PFSheet_Version, 10) || 0) === 0 || !(v["npc-type"] || parseInt(v['npc-hd'], 10) || parseInt(v['npc-hd-num'], 10) || parseInt(v['level'], 10) || parseInt(v['hp'], 10) || parseInt(v['hp_max'], 10))) {
			setAttrs({ 'auto_calc_hp': 1, 'autohp_percent': 1, 'maxhp_lvl1': 0, 'normal_macro_show': 1, 'max-dex-source': 3,
				'both_whisper_show': 1, 'use_traits': 0, 'use_racial_traits': 0, 'tab': 8, 'is_v1': 1 }, _PFConst2.default.silentParams, done);
		} else {
			done();
		}
	});
}
function migrate(callback) {
	PFMigrate.migrateNPC(callback);
}
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.debug("leaving PFNPC.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	});
	migrate(done);
}
function registerEventHandlers() {
	on("change:is_npc", _exportsLoaderTASTheAaronSheet2.default.callback(function eventSetIsNPCFlag(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			getAttrs(['is_npc'], function (v) {
				if (parseInt(v.is_npc, 10) === 1) {
					setToNPC(eventInfo);
				}
			});
		}
	}));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFNPC module loaded            ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.importFromCompendium = importFromCompendium;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFDB = __webpack_require__(28);

var _PFDB2 = _interopRequireDefault(_PFDB);

var _PFMigrate = __webpack_require__(6);

var PFMigrate = _interopRequireWildcard(_PFMigrate);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

var _PFSize = __webpack_require__(15);

var PFSize = _interopRequireWildcard(_PFSize);

var _PFSkills = __webpack_require__(16);

var PFSkills = _interopRequireWildcard(_PFSkills);

var _PFAbilityScores = __webpack_require__(11);

var PFAbilityScores = _interopRequireWildcard(_PFAbilityScores);

var _PFBuffs = __webpack_require__(26);

var PFBuffs = _interopRequireWildcard(_PFBuffs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var npcCompendiumAttributesPlayer = ["npc-spellike-ability-text", "npc-spells-known-text", "character_name", "cr_compendium", "xp_compendium", "alignment", "size_compendium", "type_compendium", "init_compendium", "senses_compendium", "npc-aura", "ac_compendium", "npc_hp_compendium", "fort_compendium", "ref_compendium", "will_compendium", "dr_compendium", "sr_compendium", "npc-defensive-abilities", "immunities", "resistances", "weaknesses", "speed_compendium", "space_compendium", "reach_compendium", "npc-melee-attacks-text", "npc-ranged-attacks-text", "npc-special-attacks", "str_compendium", "dex_compendium", "con_compendium", "int_compendium", "wis_compendium", "cha_compendium", "bab_compendium", "cmb_compendium", "cmd_compendium", "class_compendium", "npc-feats-text", "skills_compendium", "racial_mods_compendium", "environment", "organization", "other_items_treasure", "languages", "SQ_compendium", "content_compendium"];

/* ******************************** PARSING ******************************** */

/** returns number from a string, first looks at end of string, then beginning, then anywhere in middle
 * so it works with both compendium (number at end) and SRD ("init " number at beginning) or just a string number
 *@param {string} initstring from the compendium entry
 *@returns {int} the initiative modifier
 */
function getNPCInit(initstring) {
	var numberInit, matches;
	//Init +0;
	initstring = PFUtils.convertDashToMinus(initstring);
	initstring = SWUtils.trimBoth(initstring);
	if (/^Init/i.test(initstring) || /^[\+\-]{0,1}\d+/.test(initstring)) {
		//number at front
		numberInit = PFUtils.getIntFromString(initstring, true);
	} else if ((matches = initstring.match(/[\+\-]{0,1}\d+$/)) !== null) {
		//number at end
		initstring = initstring.slice(matches.index);
		if (initstring[0] !== '+') {
			initstring = '-' + initstring;
		}
		numberInit = parseInt(initstring.match(/[\-\+]\d+$/), 10) || 0;
	} else {
		numberInit = PFUtils.getIntFromString(initstring, true);
	}
	return numberInit;
}
/**getAbilityAndMod- returns the number and mod for an ability
 * @param {string} numberAsString the ability score -a number in string form
 * @returns {base: number or '-', mod:number}
 */
function getAbilityAndMod(numberAsString) {
	var base = parseInt(numberAsString, 10),
	    mod = 0;
	if (!isNaN(base)) {
		mod = Math.floor((base - 10) / 2);
		return {
			"base": base,
			"mod": mod
		};
	}
	if (_PFConst2.default.minusreg.test(numberAsString)) {
		return {
			"base": "-",
			"mod": 0
		};
	}
	return {
		"base": 10,
		"mod": 0
	};
}
/** Splits string into array, based on commas (ignoring commas between parenthesis) 
 * @param {string} featstring 
 * @returns {[string]} feats
 */
function parseFeats(featstring) {
	if (featstring.slice(0, 5).toLowerCase() === 'feats') {
		featstring = featstring.slice(5);
	}
	return SWUtils.splitByCommaIgnoreParens(featstring);
}

/** parseNPChp - parses statblock hp string such as 203 (14d10+126)
 * @param {string} hpstring - string format: "15 (3d8 + 4) Fast Healing 5"  can have multiple xdy, and any string left after ) is considered healing note.
 * @param {int} abilityMod: number representing ability score mod (normally CON-mod)
 * @returns {{hp:number,hdie1:number,hdice1:number,hdie2:number,hdice2:number,misc:number,heal:string}
 */
function parseNPChp(hpstring, abilityMod) {
	var hparray = {
		hp: 0,
		hdie1: 0,
		hdice1: 0,
		basehp: 0,
		misc: 0,
		heal: ""
	},
	    totalAbility = 0,
	    tempInt = 0,
	    dice,
	    calcHP = 0;
	try {
		abilityMod = abilityMod || 0;
		if (/^hp/i.test(hpstring)) {
			hpstring = hpstring.slice(2);
		}
		//this line should fix flying squirrel:
		hpstring = PFUtils.replaceMissingNegatives_BadDice(hpstring);
		hpstring = PFUtils.convertDashToMinus(hpstring);
		hpstring = hpstring.replace('plus', '+');
		//TAS.debug"parseNPChp", hpstring, abilityMod);
		hparray.hp = parseInt(hpstring, 10) || 0;
		hpstring = hpstring.slice(hpstring.indexOf("(") + 1);
		dice = PFUtils.getDiceDieFromString(hpstring, true);
		if (dice.dice !== 0) {
			hparray.hdice1 = dice.dice;
			hparray.hdie1 = dice.die;
			totalAbility = abilityMod * hparray.hdice1;
			hparray.misc = dice.plus - totalAbility;
			//set the base hp (for class/race) to only the hd average, so will be less than what is in statblock
			hparray.basehp = PFUtils.getAvgHP(hparray.hdice1, hparray.hdie1);
			//check total, if does not match, change 'misc' attr
			calcHP = hparray.basehp + dice.plus;
			if (hparray.hp <= 0) {
				_exportsLoaderTASTheAaronSheet2.default.warn("parseNPChp, hp is null! why!? str is:" + hpstring);
				hparray = calcHP;
			} else if (calcHP !== hparray.hp) {
				_exportsLoaderTASTheAaronSheet2.default.warn("parseNPChp, hp not adding right, should be:" + hparray.hp + " but getNPCHP returns " + calcHP, hparray);
				hparray.misc += hparray.hp - calcHP;
			}
			hpstring = hpstring.slice(dice.spaces + 1);
		}
		if (hpstring) {
			hpstring = SWUtils.trimBoth(hpstring.replace(/[\);]/g, ''));
			hparray.heal = hpstring || '';
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("parseNPChp", err);
	} finally {
		return hparray;
	}
}
/** parseNPCAC - parses AC string from statblock
 * @param {string} acstring - format: "24, Touch 24, Flat-footed 16 (+6 Deflection, +7 Dex, +1 Dodge, +1 Armor, +1 Shield, +1 Size, +6 Natural) some note can go here"
 * can start with "AC " or not.
 * if it doesn't add up then the bonus will be added to misc.
 * (others include: Luck, Sacred/Profane, Circumstance, Enhancement, Insight, Morale) - these ALL go to CMD too (and dodge, deflection).
 * @param {string} cmdStr string for cmd , just checks for a number in the string
 * @param {int} abilityMod - to apply, usually dex.
 * @param {int} sizeMod - ac mod due to size.
 * @returns {ac:10,touch:10,ff:10,armor:0,shield:0,deflect:0,dex:0,dodge:0,natural:0,misc:0,note:,size:0,acbuff:0,altability:""}
 */
function parseNPCAC(acstring, cmdStr, abilityMod, sizeMod) {
	var matches,
	    tempnum = 0,
	    tempstr = '',
	    acMap = {
		ac: 10,
		touch: 10,
		ff: 10,
		armor: 0,
		shield: 0,
		deflect: 0,
		dex: 0,
		dodge: 0,
		natural: 0,
		misc: 0,
		note: "",
		size: 0,
		altability: "",
		acbuff: 0,
		uncanny: 0,
		cmd: 10,
		notes: '',
		cmdnotes: ''
	};
	abilityMod = abilityMod || 0;
	sizeMod = sizeMod || 0;
	//TAS.debug"parseNPCAC: string:" + acstring + ", ability:" + abilityMod + ", size:" + sizeMod);
	try {
		if (/^ac\s/i.test(acstring)) {
			acstring = acstring.slice(3);
		}
		acMap.ac = parseInt(acstring, 10) || 0;

		matches = cmdStr.match(/(\d+)/); //get first match
		if (matches && matches[1]) {
			//TAS.debug("getting cmd matches is cmd is : "+matches[1],matches);
			acMap.cmd = parseInt(matches[1], 10) || 0;
			tempstr = cmdStr.slice(matches.index + matches[0].length);
			if (tempstr) {
				tempstr = SWUtils.trimBoth(tempstr);
				acMap.cmdnotes = tempstr;
			}
		}

		//get other AC totals
		matches = acstring.match(/Touch\s*?(\d+)/i);
		if (matches && matches[1]) {
			acMap.touch = parseInt(matches[1], 10);
		}
		matches = acstring.match(/Flat\-footed\s*?(\d+)/i);
		if (matches && matches[1]) {
			acMap.ff = parseInt(matches[1], 10);
		}
		//get modifiers compendium has all negatives as "1" intead of "-1"
		matches = acstring.match(/([+\-]??\d+)\s*?Deflect[,\i\s]/i);
		if (matches && matches[1]) {
			acMap.deflect = parseInt(matches[1], 10);
		}
		matches = acstring.match(/([+\-]??\d+)\s*?Nat[,u\s]/i);
		if (matches && matches[1]) {
			acMap.natural = parseInt(matches[1], 10);
		}
		matches = acstring.match(/([+\-]??\d+)\s*?Dodge/i);
		if (matches && matches[1]) {
			acMap.dodge = parseInt(matches[1], 10);
		}
		matches = acstring.match(/([+\-]??\d+)\s*?Size/i);
		if (matches && matches[1]) {
			acMap.size = parseInt(matches[1], 10);
		}
		//compendium size wrong: missing minus sign.
		// see Marilith
		if (acMap.size !== sizeMod) {
			acMap.size = sizeMod;
		}
		matches = acstring.match(/([+\-]??\d+)\s*?armor/i);
		if (matches && matches[1]) {
			acMap.armor = parseInt(matches[1], 10);
		}
		matches = acstring.match(/([+\-]??\d+)\s*?shield/i);
		if (matches && matches[1]) {
			acMap.shield = parseInt(matches[1], 10);
		}
		matches = acstring.match(/\)\s*?(.*)/);
		if (matches && matches[1]) {
			acMap.note = matches[1];
		}
		//get ability modifier, should be Dex by default.
		matches = acstring.match(/([+\-]??\d+)\s*?Dex/i);
		if (matches && matches[1]) {
			acMap.dex = parseInt(matches[1], 10) || 0;
			//if different then set, compendium error no minus
			// see Fire Giant.
			if (abilityMod !== acMap.dex) {
				acMap.dex = abilityMod;
			}
		} else {
			matches = acstring.match(/([+\-]??\d+)\s*?(Wis|Int|Str|Con|Cha)/i);
			if (matches && matches[1] && matches[2]) {
				acMap.dex = parseInt(matches[1], 10) || 0;
				//should not happen anymore since 6th printing of PRD they removed abilities that change ability to AC, now
				// just add dodge instead.
				acMap.altability = matches[2].toUppercase();
			}
		}
		//check total for any other (untyped, Luck, Sacred/Profane, Circumstance, Enhancement, Insight, Morale)
		//touch - if touch does not add up put difference in misc. (AC not match we'll put in a buff row)
		// we need to track a seperate ac misc buff/penalty. we can put it in buffs.
		tempnum = acMap.dodge + acMap.dex + acMap.deflect + acMap.size + 10;
		if (acMap.touch !== tempnum) {
			acMap.misc = acMap.touch - tempnum;
		}
		//if AC does not add up, even including misc found above, then put it in ac buff row.
		tempnum = acMap.armor + acMap.shield + acMap.dodge + acMap.dex + acMap.natural + acMap.deflect + acMap.size + acMap.misc + 10;
		if (acMap.ac !== tempnum) {
			acMap.acbuff = acMap.ac - tempnum;
		}
		//check for not caught flat footed
		if (acMap.ac === acMap.ff && (acMap.dex > 0 || acMap.dodge > 0)) {
			acMap.uncanny = 1;
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("parseNPCAC", err);
	} finally {
		return acMap;
	}
}
/* parseSpeed -returns object with speeds {land:base,fly:xx,swim:xx} etc*/
function parseSpeed(speedstr) {
	var speeds = speedstr.split(/,\s*/),
	    retobj;
	retobj = _underscore2.default.reduce(speeds, function (memo, speedComponent, idx) {
		var matches,
		    speedNum = 0;
		try {
			if (idx === 0) {
				speedNum = parseInt(speedComponent.match(/(\d+)/)[1], 10) || 0;
				if (speedNum) {
					memo["land"] = speedNum;
				}
			} else {
				matches = speedComponent.match(/([\w]+)\s*(\d+)/);
				if (matches) {
					speedNum = parseInt(matches[2], 10) || 0;
					if (speedNum) {
						memo[matches[1].toLowerCase()] = speedNum;
						if (/fly/i.test(matches[1])) {
							matches = speedComponent.match(/\(([\w]+)\)/);
							if (matches && matches[1].length > 0) {
								memo["flyability"] = matches[1];
							}
						}
					}
				}
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("parseSped", err);
		} finally {
			return memo;
		}
	}, {});
	return retobj;
}
/* getAtkNameFromStr get names of an attack or special attack
 * { Name :(full str up to first parens) , abilityName (without pluses the base ability ), basename (ability name lower case no spces)}
 * for instance: Mwk Longsword +6/+1 would be : {name:Mwk longsword +6/+1, abilityName:Longsword, basename: longsword}
 */
function getAtkNameFromStr(abilitystr) {
	var matches = abilitystr.match(/^\s*([^\(]+)/),
	    name = '',
	    abilityName = '',
	    basename = '';
	if (matches && matches[1]) {
		name = matches[1];
		name = SWUtils.trimBoth(name);
		abilityName = name.replace(/\d+d\d+|\-\d+|\+|\d+|\//g, '');
		abilityName = SWUtils.trimBoth(abilityName);
		abilityName = abilityName[0].toUpperCase() + abilityName.slice(1);
		basename = abilityName.toLowerCase();
		basename = basename.replace(/ray|cone|aura|mwk/ig, '');
		basename = basename.replace(/\s+/g, '');
	}
	return {
		'name': name,
		'basename': basename,
		'abilityName': abilityName
	};
}
/*parseReach - parses reach string from compendium or statblock: giant frog: Reach 5 ft. (15 ft. with tongue)
 * returns the default reach, rest of the string (if any), and an array of exceptions and reaches if any.
 * @returns = {reach:number (5,10,15 etc), reachNotes:"rest of string", reachExceptions:[['Bite':10],['Claw':5]]}
 */
function parseReach(reachStr) {
	var numerator = 0,
	    denominator = 1,
	    tempInt = 0,
	    tempFloat = 0.0,
	    tempstr,
	    restOf = "",
	    matches,
	    exceptionstr = "",
	    tempArray = [],
	    reachExceptions = [],
	    retobj = {
		reach: 5,
		reachNotes: "",
		reachExceptions: []
	};
	if (!reachStr) {
		return retobj;
	}
	try {
		//to handle PRD, SRD:
		matches = reachStr.match(/reach/i);
		if (matches) {
			reachStr = reachStr.slice(matches.index + matches[0].length);
		}
		reachStr = SWUtils.trimBoth(reachStr);
		reachStr = PFUtils.convertDashToMinus(reachStr);
		reachStr = reachStr.replace('21/2', '2-1/2');
		reachStr = reachStr.replace('2.5', '2-1/2');
		if (reachStr.slice(0, 5) === "2-1/2") {
			retobj.reach = 2.5;
			exceptionstr = reachStr.slice(5);
		} else {
			retobj.reach = parseInt(reachStr, 10) || 0;
			exceptionstr = PFUtils.getNoteAfterNumber(reachStr);
		}
		if (exceptionstr && exceptionstr.indexOf('(') >= 0) {
			retobj.reachNotes = exceptionstr;
			exceptionstr = SWUtils.trimBoth(exceptionstr.replace('(', '').replace(')', '').replace(/with\s/ig, '').replace(';', '').replace(/ft[\.\s]*/ig, '').replace(/,\s*/g, ','));
			if (exceptionstr) {
				tempArray = exceptionstr.split(',');
				reachExceptions = _underscore2.default.reduce(tempArray, function (memo, exceptioninstance) {
					var reachExceptions = [],
					    matches;
					try {
						if (exceptioninstance.slice(0, 5) === "2-1/2") {
							reachExceptions.push(SWUtils.trimBoth(exceptioninstance.slice(5)));
							if (reachExceptions[0]) {
								reachExceptions.push(2.5);
								memo.push(reachExceptions);
							}
						} else {
							reachExceptions.push(PFUtils.getNoteAfterNumber(reachStr) || '');
							if (reachExceptions[0]) {
								reachExceptions.push(parseInt(reachStr, 10) || 0);
								memo.push(reachExceptions);
							}
						}
					} catch (erri) {
						_exportsLoaderTASTheAaronSheet2.default.error("parseReach inner error erri:", erri);
					} finally {
						return memo;
					}
				}, []);
				if (reachExceptions && reachExceptions.length > 0) {
					retobj.reachExceptions = reachExceptions;
				}
			}
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("parseReach error:", err);
	} finally {
		return retobj;
	}
}
function getCreatureClassSkills(creatureType) {
	var typeToCheck = creatureType.toLowerCase().replace(/\s/g, ''),
	    classSkills,
	    subSkills;
	try {
		subSkills = _underscore2.default.find(_PFDB2.default.creatureTypeClassSkills, function (skills, mainType) {
			var reg = new RegExp(mainType);
			return reg.test(typeToCheck);
		});
		if (subSkills && subSkills.length > 0) {
			classSkills = subSkills;
		}
		subSkills = _underscore2.default.find(_PFDB2.default.creatureSubtypeClassSkills, function (skills, mainType) {
			var reg = new RegExp(mainType);
			return reg.test(typeToCheck);
		});
		if (subSkills) {
			if (classSkills) {
				classSkills = classSkills.concat(subSkills);
			} else {
				classSkills = subSkills;
			}
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("parseCreatureClassSkills", err);
	} finally {
		if (classSkills) {
			return classSkills;
		}
		return [];
	}
}
/* assignPrimarySecondary
 * to each attack in array, assigns attack.naturaltype='primary|secondary' and sometimes attack.dmgMult=1.5
 * returns attacks for chaining.
 */
function assignPrimarySecondary(attacks) {
	var attackGroups,
	    attacksToCheck = _underscore2.default.filter(attacks, function (attack) {
		return attack.type === 'natural';
	});
	if (_underscore2.default.size(attacksToCheck) <= 0) {
		return attacks;
	}
	if (_underscore2.default.size(attacksToCheck) === 1) {
		attacksToCheck[0].naturaltype = 'primary';
		if (attacksToCheck[0].iter && attacksToCheck[0].iter.length === 1 || isNaN(parseInt(attacksToCheck[0].iter, 10))) {
			attacksToCheck[0].dmgMult = 1.5;
		}
	} else {
		attackGroups = _underscore2.default.groupBy(attacksToCheck, function (attack) {
			return _PFDB2.default.primaryNaturalAttacksRegExp.exec(attack.name);
		});
		if (_underscore2.default.size(attackGroups) === 1) {
			_underscore2.default.each(attacksToCheck, function (attack) {
				attack.naturaltype = 'primary';
			});
		} else {
			_underscore2.default.each(attacksToCheck, function (attack) {
				if (_PFDB2.default.primaryNaturalAttacksRegExp.test(attack.name)) {
					attack.naturaltype = 'primary';
				} else {
					attack.naturaltype = 'secondary';
				}
			});
		}
	}
	return attacks;
}
/*buildImportantFeatObj - saves feats that require updates to the sheet in an object, no spaces and all lowercase.
 * returns sub objects for feats that only apply to certain attacks, and a criticaldamage subobject.
 * for instance:::  obj.weaponfinesse=1 obj.criticaldamage.bleedingcritical:1 obj.longsword.weaponfocus:1
 * @returns object of feats   as  {featname:1,feat2name:1, attacks:{attack1name:{featname:1}}, criticaldamage:{featname:1}}
 */
function buildImportantFeatObj(featlist) {
	return _underscore2.default.chain(featlist).filter(function (feat) {
		if (!feat) {
			return false;
		}return true;
	}).filter(function (feat) {
		return _PFDB2.default.importantFeatRegExp.test(feat);
	}).map(function (feat) {
		//TAS.debug("checking <" + feat + "> for ending letter");
		//if there is an "endnote" letter indicator at the end then remove it
		feat = SWUtils.trimBoth(feat);
		if (/\b[A-Z]$/i.test(feat)) {
			feat = feat.slice(0, -2);
			feat = SWUtils.trimBoth(feat);
		}
		return feat;
	}).reduce(function (memo, feat) {
		var origfeat = feat,
		    atktype = "",
		    matches,
		    attacks = {},
		    attack = {},
		    crits = {},
		    skills = {},
		    skill = "";
		try {
			if (feat.indexOf('(') >= 0) {
				matches = /(.*?)\((.*)\)/.exec(feat);
				feat = matches[1];
				atktype = matches[2];
				feat = SWUtils.trimBoth(feat);
				atktype = SWUtils.trimBoth(atktype);
			}
			feat = feat.replace(/\s/g, '').toLowerCase();
			if (feat === 'improvedcritical' || feat === 'criticalmastery') {
				return memo;
			}
			if (feat.indexOf('critical') > 0) {
				atktype = feat;
				feat = "criticaldamage";
			} else if (feat.indexOf('skillfocus') >= 0) {
				skill = atktype.replace(' ', '-');
				skill = skill[0].toUpperCase() + skill.slice(1);
			}
			memo[feat] = 1;
			switch (feat) {
				case 'weaponfinesse':
				case 'improvedcritical':
					if (memo.attacks) {
						attacks = memo.attacks;
					}
					if (attacks[atktype]) {
						attack = attacks[atktype];
					}
					attack[feat] = 1;
					attacks[atktype] = attack;
					memo.attacks = attacks;
					break;
				case 'criticaldamage':
					if (memo.criticaldamage) {
						crits = memo.criticaldamage;
					}
					crits[atktype] = 1; //or put sickening?
					memo.criticaldamage = crits;
					break;
				case 'skillfocus':
					if (memo.skillfocuses) {
						skills = memo.skillfocuses;
					}
					if (skill) {
						skills[skill] = 1;
						memo.skillfocuses = skills;
					}
					break;
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("buildImportantFeatObj error:", err);
			memo[feat] = 1;
		} finally {
			return memo;
		}
	}, {}).value();
}
function parseAttack(atkstr, atktypestr, addgroups, groupidx, isUndead) {
	var matches,
	    currpos = 0,
	    name = "",
	    iteratives,
	    i = 0,
	    tempInt = 0,
	    beforeBetweenAfterParens,
	    bonus = "",
	    origStr = atkstr,
	    countspaces = 0,
	    specCMB = 0,
	    abilityBaseName = '',
	    tempstr = "",
	    tempidx = 0,
	    names,
	    attackdescs,
	    retobj = {
		enh: 0,
		mwk: 0,
		name: "",
		basename: "",
		atktype: "melee",
		type: "",
		range: "",
		countFullBAB: 1,
		iter: [],
		dmgdice: 0,
		dmgdie: 0,
		dmgtype: "",
		crit: 20,
		critmult: 2,
		dmgbonus: 0,
		plus: "",
		plusamount: "",
		plustype: "",
		note: ""
	};
	try {
		//TAS.debug"parseAttack: "+atkstr);
		if (addgroups) {
			//retobj.name += "Group " + groupidx + ": ";
			retobj.group = 'Full attack ' + groupidx;
		}
		names = getAtkNameFromStr(atkstr);
		retobj.name += names.name;
		retobj.basename = names.basename;
		atkstr = SWUtils.trimBoth(atkstr);
		//if starts with number, it means number of attacks
		matches = atkstr.match(/^(\d+)\s*/);
		if (matches && matches[1]) {
			retobj.countFullBAB = parseInt(matches[1], 10) || 1;
			//move up
			atkstr = atkstr.slice(matches[0].length);
		}
		//starts with '+/-' number or 'mwk': enh or mwk
		matches = atkstr.match(/^([+\-]\d+|mwk)\s*/i);
		if (matches) {
			//starts with +n, is weapon
			//retobj.name += matches[0];
			if (matches[1].toLowerCase() === 'mwk') {
				retobj.mwk = 1;
			} else {
				retobj.enh = parseInt(matches[1], 10) || 0;
			}
			retobj.type = "weapon"; //for sure is a weapon
			//move up
			atkstr = atkstr.slice(matches[0].length);
		}
		if (_PFDB2.default.cmbPlusStrsrch.test(retobj.basename)) {
			retobj.atktype = 'cmb';
			retobj.vs = 'cmd';
			retobj.type = 'natural';
			specCMB = 1;
		} else if (atktypestr === 'melee' && _PFDB2.default.combatManeuversRegExp.test(retobj.basename)) {
			retobj.atktype = 'cmb';
			retobj.vs = 'cmd';
		} else if (_PFDB2.default.cmbMonsterSrch.test(retobj.basename)) {
			retobj.atktype = 'cmb';
			retobj.type = 'natural';
			retobj.vs = 'cmd';
		} else if (/web/i.test(retobj.basename)) {
			retobj.atktype = 'ranged';
			retobj.type = 'special';
			retobj.vs = 'touch';
			retobj.range = 10;
		} else if (/touch/i.test(retobj.basename)) {
			if (/range/i.test(retobj.basename)) {
				retobj.atktype = 'ranged';
			} else {
				retobj.atktype = 'melee';
			}
			retobj.vs = 'touch';
		} else if (/special/i.test(atktypestr)) {
			retobj.atktype = 'special';
			retobj.type = 'special';
		} else {
			retobj.atktype = atktypestr;
		}
		if (!retobj.type) {
			if (_PFDB2.default.naturalAttackRegExp.test(retobj.basename)) {
				retobj.type = "natural";
			} else if (_PFDB2.default.unarmedAttacksRegExp.test(name)) {
				retobj.type = "unarmed";
			} else {
				retobj.type = "weapon";
			}
		}
		if (!retobj.vs) {
			if (/touch|web/i.test(retobj.name)) {
				retobj.vs = 'touch';
				if (/ranged|web/i.test(retobj.name)) {
					retobj.atktype = 'ranged';
					if (/web/i.test(retobj.basename)) {
						retobj.range = 10;
					}
				}
			}
		}
		//skip past name
		//CB how the hell does this work? i wrote it and i cant' even tell
		matches = atkstr.match(/\s*([^0-9\/\+\-\(]+)/);
		if (matches && matches[0]) {
			if (matches.index) {
				tempidx = matches.index;
			}
			atkstr = atkstr.slice(tempidx + matches[0].length);
		}
		if (atkstr) {
			//after name split rest by parenthesis
			// format: name   attack bonus ( damage ) plus additional
			beforeBetweenAfterParens = atkstr.split(/\(|\)/);
			//attack amounts before paren
			iteratives = beforeBetweenAfterParens[0].split(/\//);
			if (/\d/.test(iteratives[0])) {
				retobj.iter = _underscore2.default.map(iteratives, function (iter, index) {
					if (/^[+\-]/.test(iter)) {
						return parseInt(iter, 10) || 0;
					}
					//minus missing assume minus
					return -1 * (parseInt(iter, 10) || 0);
				});
			} else if (retobj.atktype === 'cmb') {
				retobj.iter[0] = 0;
			}
			//damage between parens
			if (beforeBetweenAfterParens[1]) {
				attackdescs = beforeBetweenAfterParens[1].split(/,\s*/);
				//split on commas and strip out non damage, put damage in tempstr
				tempstr = _underscore2.default.reduce(attackdescs, function (memo, subattack) {
					if (/ft\./i.test(subattack)) {
						retobj.range = subattack;
					} else if (/D[Cc]\s\d+/.test(subattack)) {
						matches = subattack.match(/(D[Cc]\s\d+)/);
						retobj.DC = matches[1].toUpperCase();
						retobj.DCability = _PFDB2.default.specialAttackDCAbilityBase[retobj.basename] || 'CON';
						if (isUndead && retobj.DCability === 'CON') {
							retobj.DCability = 'CHA';
						}
						retobj.dcequation = PFUtils.getDCString(retobj.DCability, 'npc-hd-num', isUndead);
					} else if (/freq|day|constant|at.will/i.test(subattack)) {
						retobj.frequency = subattack;
					} else if (/AC|hp/.test(subattack) || !/\d|plus/.test(subattack)) {
						//if no number or 'plus' don't know what to do so stick it in note.
						retobj.note += subattack + ', ';
					} else {
						memo += subattack + ' ';
					}
					return memo;
				}, "");
				//TAS.debug"now left with :"+tempstr);
				// find damage
				//damage dice and die
				var dice = PFUtils.getDiceDieFromString(tempstr, true, true);
				if (dice.dice !== 0) {
					retobj.dmgdice = dice.dice;
					retobj.dmgdie = dice.die;
					retobj.dmgbonus = dice.plus;
					tempstr = tempstr.slice(dice.spaces);
				}
				bonus = SWUtils.trimBoth(tempstr);

				//any text after damage is 'plus' or damage type
				if (bonus) {
					//if engulf or swallowwhole, there will be inner AC and hp to put in notes
					if (specCMB) {
						matches = bonus.match(/\sac\s\d+/i);
						if (matches) {
							retobj.note += bonus.slice(matches.index);
							bonus = SWUtils.trimBoth(bonus.slice(0, matches.index));
						}
					}
					//look for plus
					matches = bonus.match(/plus(.*)/i);
					if (matches) {
						tempstr = SWUtils.trimBoth(matches[1]);
						bonus = SWUtils.trimBoth(bonus.slice(0, matches.index));
						if (/\d+d\d+/i.test(tempstr)) {
							matches = tempstr.match(/(\d+d\d+)\s*([\w\s]*)/);
							retobj.plusamount = matches[1];
							if (matches[2]) {
								retobj.plustype = matches[2].replace(/^\s+|\s+$/g, '');
							}
						} else {
							retobj.plus = tempstr;
						}
					}
					//matches = bonus.match(/\s|\//g);
					//if (matches) {
					//	countspaces = matches.length - 1;
					//}
					if (retobj.dmgbonus === 0) {
						matches = bonus.match(/\s|\//g);
						if (matches) {
							countspaces = matches.length - 1;
						}
						//--does not find dash in crit check for different types of minus
						matches = bonus.match(/(x\d+)|(\/\d+\-??20)|([+\-]??\d+)/ig);
						_underscore2.default.each(matches, function (match, index) {
							bonus = bonus.slice(match.length);
							if (/^[+\-]/.test(match)) {
								retobj.dmgbonus = parseInt(match, 10) || 0;
							} else if (/^[x\u00d7]\d+/.test(match)) {
								match = match.slice(1);
								retobj.critmult = parseInt(match, 10) || 2;
							} else if (/^\d+/.test(match)) {
								//minus missing
								retobj.dmgbonus = -1 * (parseInt(match, 10) || 0);
							} else if (match.indexOf('20') >= 0) {
								match = match.replace('20', '').replace('-', '').replace('/', '');
								if (match && match.length > 0) {
									retobj.crit = parseInt(match, 10) || 20;
								}
							}
						});
						bonus = bonus.slice(countspaces);
					}
					if (bonus && bonus.length > 0) {
						retobj.dmgtype += bonus;
					}
				}
				if (retobj.atktype !== 'cmb' && !retobj.iter[0] && retobj.dmgtype && retobj.dmgdice && retobj.dmgdie && !retobj.plusamount && !retobj.plustype && !/bludg|slash|pierc/i.test(retobj.dmgtype)) {
					retobj.plustype = retobj.dmgtype;
					tempstr = String(retobj.dmgdice) + "d" + String(retobj.dmgdie);
					if (retobj.dmgbonus) {
						if (retobj.dmgbonus > 0) {
							tempstr += "+" + retobj.dmgbonus;
						} else {
							tempstr += "-" + Math.abs(retobj.dmgbonus);
						}
					}
					retobj.plusamount = tempstr;
					retobj.dmgtype = "";
					retobj.dmgdice = 0;
					retobj.dmgdie = 0;
				}
			}
			//any notes at end
			i = 2;
			while (i < beforeBetweenAfterParens.length) {
				//can use filter then reduce, or use each, or use easy for loop.
				retobj.note += SWUtils.trimBoth(beforeBetweenAfterParens[i]);
				i++;
			}
		}
		if (retobj.note) {
			retobj.note = SWUtils.trimBoth(retobj.note);
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("parseAttack: error parsing:" + atkstr, err);
		if (retobj.name) {
			retobj.name += " ";
		}
		retobj.name += "Could not parse attack!";
		retobj.note = origStr + " , error: ";
		retobj.note += err;
	} finally {
		return retobj;
	}
}
/** parseAttacks parse atttack string one at a time, returns arrays grouped by full attacks
 * attacks split by commas, full attack groups split by 'or'
 * the name of the attack starts with Group 0, Group 1, etc.
 * @param {string} atkstr
 * @param {string} atktypestr "melee" or "ranged"
 * @returns {[{enh:0,mwk:0,name:"",atktype:"melee",type:"",countFullBAB:1,plus:"",plusamount:"",plustype:"",note:"",iter:[],dmgdice:0,dmgdie:0,crit:20,critmult:2,dmgbonus:0}]}
 */
function parseAttacks(atkstr, atktypestr, cmbval) {
	var atkarrayout,
	    atkarraysub,
	    attacksouter,
	    matches,
	    addgroups = false;
	if (!atkstr) {
		return null;
	}
	if (!atktypestr) {
		atktypestr = 'melee';
	}
	if (atkstr.slice(0, atktypestr.length).toLowerCase() === atktypestr) {
		atkstr = atkstr.slice(atktypestr.length);
	}
	if (atkstr[0] === '*' || atkstr[0] === ':') {
		atkstr = atkstr.slice(1);
	}
	atkstr = SWUtils.trimBoth(atkstr);
	atkstr = PFUtils.replaceMissingNegatives_BadDice(atkstr);
	atkstr = PFUtils.replaceMissingNegatives_CritRange(atkstr);
	atkstr = PFUtils.convertDashToMinus(atkstr);
	atkarrayout = atkstr.split(/\bor\b/i);
	if (atkarrayout.length > 1) {
		addgroups = true;
	}
	attacksouter = _underscore2.default.reduce(atkarrayout, function (memoout, atkstrout, groupidx) {
		var atkarray = atkstrout.split(/,\s*(?![^\(\)]*\))/),
		    attacks;
		if (atkarray.length > 1) {
			addgroups = true;
		}
		//TAS.debug('parseattacks outer group: ' + groupidx);
		attacks = _underscore2.default.reduce(atkarray, function (memo, atkstr) {
			var retobj;
			//TAS.debug('parseattacks: ' + atkstr);
			retobj = parseAttack(atkstr, atktypestr, addgroups, groupidx, cmbval);
			if (retobj) {
				memo.push(retobj);
			}
			return memo;
		}, []);
		return memoout.concat(attacks);
	}, []);
	return attacksouter;
}

function parseSkillRacialBonuses(racialstr) {
	//abilitymods = modify default ability score for a skill
	var abilitieslower = _underscore2.default.map(PFAbilityScores.abilities, function (ab) {
		return ab.toLowerCase();
	}),
	    allCoreSkillsLower = _underscore2.default.map(PFSkills.allCoreSkills, function (skill) {
		return skill.toLowerCase();
	}),
	    skillsWithSubSkillsLower = _underscore2.default.map(PFSkills.skillsWithSubSkills, function (skill) {
		return skill.toLowerCase();
	}),
	    skillsWithSpaces = PFSkills.skillsWithSpaces,
	    temparray,
	    modifiers = [],
	    abilitymodstr = "",
	    abilitymodlower = "",
	    ability = "",
	    setability = false,
	    tempskill = "",
	    matches,
	    skillmods = {},
	    skillnotes = [],
	    abilitymods = {},
	    retobj = {
		"skillmods": skillmods,
		"skillnotes": skillnotes,
		"abilitymods": abilitymods
	};
	if (!racialstr) {
		return retobj;
	}
	temparray = racialstr.split(';');
	if (temparray.length > 1) {
		racialstr = temparray[0];
		abilitymodstr = temparray[1];
	}
	if (abilitymodstr) {
		try {
			abilitymodlower = abilitymodstr.toLowerCase();
			ability = _underscore2.default.find(abilitieslower, function (ab) {
				return abilitymodlower.indexOf(ab) >= 0;
			});
			if (ability) {
				tempskill = _underscore2.default.find(allCoreSkillsLower, function (skill) {
					return abilitymodlower.indexOf(skill) >= 0;
				});
				if (tempskill) {
					abilitymods[tempskill[0].toUpperCase() + tempskill.slice(1)] = ability.toLowerCase();
					setability = true;
				}
			}
		} catch (err1) {
			_exportsLoaderTASTheAaronSheet2.default.error("parseSkillRacialBonuses inner", err1);
		}
		if (!setability) {
			skillnotes.push(abilitymodstr);
		}
	}
	modifiers = racialstr.split(/,\s*/);
	_underscore2.default.each(modifiers, function (modstr) {
		var modstrlower = modstr.toLowerCase(),
		    mod = 0,
		    moddedTitle,
		    modded = "",
		    tempstr = "",
		    exceptionstr = "",
		    conditionmod = 0,
		    conditionstr = "",
		    hasSubSkill = false,
		    matches;
		try {
			matches = modstr.match(/\s*([+\-]\d+)\s*(?:on|to)?\s*([\w]+)\s*([\w\s]+)?\s*(\([^)]*\))?/);
			if (!matches) {
				//is an exception or note
				tempskill = _underscore2.default.find(allCoreSkillsLower, function (skill) {
					return modstrlower.indexOf(skill) >= 0;
				});
				if (tempskill) {
					ability = _underscore2.default.find(abilitieslower, function (ab) {
						return modstrlower.indexOf(ab) >= 0;
					});
					if (ability) {
						abilitymods[tempskill.toLowerCase()] = ability;
					} else {
						skillnotes.push(modstr);
					}
				} else {
					skillnotes.push(modstr);
				}
				return;
			}
			exceptionstr = matches[3];
			mod = parseInt(matches[1], 10) || 0;
			modded = matches[2];
			if (!_underscore2.default.contains(allCoreSkillsLower, modded.toLowerCase())) {
				//TAS.warn("does not match " + modded);
				// +8 Sleight of Hand
				tempskill = _underscore2.default.find(skillsWithSpaces, function (skill) {
					return modstrlower.indexOf(skill) >= 0;
				});
				if (!tempskill || tempskill.length < 1) {
					//not sure what this is
					skillnotes.push(modstr);
					return;
				}
				temparray = tempskill.split(/\s/);
				temparray = _underscore2.default.map(temparray, function (part) {
					if (part === "of") {
						return "of";
					}
					return part[0].toUpperCase() + part.slice(1);
				});
				modded = temparray.join('-');
				exceptionstr = exceptionstr.slice(tempskill.length - tempskill.indexOf(' ') + 1);
				//TAS.debug("found skill with space converted to modded:"+modded+", exceptionstr:"+exceptionstr);
			}
			if (exceptionstr) {
				//entire thing is a "when" exception
				skillnotes.push(modstr);
				return;
			}
			moddedTitle = modded[0].toUpperCase() + modded.slice(1);
			if (!matches[4]) {
				skillmods[moddedTitle] = mod;
				return;
			}
			//if craft, knowledge, etc
			exceptionstr = matches[4].replace(/^\s+|\(|\)|\s+$/g, '');
			if (_underscore2.default.contains(skillsWithSubSkillsLower, modded.toLowerCase())) {
				exceptionstr = exceptionstr[0].toUpperCase() + exceptionstr.slice(1);
				if (modded.toLowerCase() === "knowledge") {
					moddedTitle += "-" + exceptionstr;
				} else {
					moddedTitle += "[" + exceptionstr + "]";
				}
				skillmods[moddedTitle] = mod;
			} else {
				//has bonus
				matches = exceptionstr.match(/([+\-]\d+)\s(.*)$/);
				if (matches && matches[1]) {
					conditionmod = parseInt(matches[1], 10) || 0;
					if (matches[2]) {
						conditionstr = matches[2];
					}
					conditionmod = conditionmod - mod;
					skillmods[moddedTitle] = mod;
					tempstr = (conditionmod > 0 ? "+" : "") + conditionmod + " " + moddedTitle + " " + conditionstr;
					skillnotes.push(tempstr);
				} else {
					skillnotes.push(modstr);
				}
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("parseSkillRacialBonuses outer error", err);
			skillnotes.push(modstr);
		}
	});
	return retobj;
}
function parseSkills(skillstr) {
	var rawSkills = skillstr.match(/[\w][\w\s]+\s*(?:\([\w\s,]+\))?\s*[+\-]\d+[,]??/g),
	    skills = _underscore2.default.reduce(rawSkills, function (memo, skill) {
		var matches = skill.match(/^([\w][\w\s]+[\w])\s*(\([\w\s,]+\))??([+\s]+\d+)$/),
		    tempskill = "",
		    tempval = 0,
		    tempskill2 = "",
		    subskills;
		if (matches) {
			tempval = parseInt(matches[3], 10) || 0;
			tempskill = matches[1].replace(/^\s+|\s+$/g, '');
			tempskill = tempskill[0].toUpperCase() + tempskill.slice(1);
			tempskill = tempskill.replace(/\s/g, '-');
			if (matches[2]) {
				subskills = matches[2].split(/,\s*/);
				_underscore2.default.each(subskills, function (subskill) {
					subskill = subskill.replace(/^\s+|,|\(|\)|\s+$/g, '');
					subskill = subskill[0].toUpperCase() + subskill.slice(1);
					if (tempskill === "Knowledge") {
						subskill = "-" + subskill;
					} else {
						subskill = "[" + subskill + "]";
					}
					memo[tempskill + subskill] = tempval;
				});
			} else {
				memo[tempskill] = tempval;
			}
		}
		return memo;
	}, {});
	return skills || {};
}
function parseAbilityScores(v) {
	var aS = {};
	aS.str = getAbilityAndMod(v["str_compendium"]);
	aS.dex = getAbilityAndMod(v["dex_compendium"]);
	aS.con = getAbilityAndMod(v["con_compendium"]);
	aS.wis = getAbilityAndMod(v["wis_compendium"]);
	aS['int'] = getAbilityAndMod(v["int_compendium"]);
	aS.cha = getAbilityAndMod(v["cha_compendium"]);
	return aS;
}
function parseSpecialAttack(setter, sastr) {
	var origsastr,
	    names,
	    tempstr,
	    tempstr2,
	    match,
	    matches,
	    parensplit,
	    atktyp = 'special',
	    baseability = "",
	    abilitytype = "",
	    isAttack = false,
	    retobj = {};
	try {
		origsastr = sastr;
		names = getAtkNameFromStr(sastr);
		if (sastr.indexOf('(') >= 0) {
			if (_PFDB2.default.spAttackAttacksPreProcess.test(names.basename)) {
				//preprocess
				if (/rake/i.test(names.basename)) {
					sastr = PFUtils.removeUptoFirstComma(sastr, true);
				} else if (/rend/i.test(names.basename)) {
					sastr = PFUtils.removeUptoFirstComma(sastr);
				} else if (/web/i.test(names.basename)) {
					sastr = PFUtils.removeUptoFirstComma(sastr, true);
					sastr = 'web ' + sastr;
					atktyp = 'ranged';
				}
				isAttack = true;
			} else if (_PFDB2.default.spAttackAttacks.test(names.basename)) {
				isAttack = true;
			}
		} else if (/damage|drain|dmg/i.test(names.basename) && !/blood|energy/i.test(names.basename) && _PFDB2.default.abilitySrch.test(names.basename)) {
			match = names.basename.match(/damage|drain/i);
			names.AbilityName = 'Ability ' + match[0];
			sastr = names.AbilityName + ' (' + sastr + ')';
			isAttack = true;
		}

		if (isAttack) {
			retobj = parseAttack(sastr, atktyp, false, 0);
			retobj.specialtype = 'attack';
			retobj.group = 'Special';
			retobj.name = names.AbilityName && names.AbilityName.slice(0, 7) === 'Ability' ? names.AbilityName : names.name;
			retobj.basename = names.basename;
		}
		if (!isAttack) {
			retobj.name = names.abilityName || names.name;
			retobj.basename = names.basename;
			retobj.specialtype = 'ability';
			retobj.rule_category = "special-attacks";
			matches = /usable\severy/i.exec(origsastr);
			if (matches) {
				retobj.frequency = 'everyrounds';
				tempstr = origsastr.slice(matches.index + matches[0].length);
				tempstr2 = PFUtils.getDiceDieString(tempstr);
				if (tempstr2) {
					retobj.used = tempstr2;
					matches = tempstr.match(/rounds|days|minutes/i);
					if (matches) {
						retobj.used += " " + matches[0];
					}
				}
			}
			if (_PFDB2.default.specialAttackDCAbilityBase[retobj.basename]) {
				retobj.DCability = _PFDB2.default.specialAttackDCAbilityBase[retobj.basename];
				if (parseInt(setter['is_undead'], 10) === 1 && retobj.DCability === 'CON') {
					retobj.DCability = 'CHA';
				}
			}
			retobj.shortdesc = PFUtils.replaceDCString(PFUtils.replaceDiceDieString(origsastr), retobj.DCability, 'npc-hd-num', setter.is_undead);
		}
		abilitytype = PFUtils.getSpecialAbilityTypeFromString(sastr);
		if (abilitytype) {
			retobj.ability_type = abilitytype;
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("parseSpecialAttack", err);
	} finally {
		return retobj;
	}
}
function parseSpecialAttacks(setter, saString, cmb) {
	var retarray;
	if (!saString) {
		return {};
	}
	retarray = saString.split(/,\s*(?![^\(\)]*\))/);
	return _underscore2.default.reduce(retarray, function (memo, sa) {
		var retobj, tempstr, names;
		try {
			retobj = parseSpecialAttack(setter, sa);
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("parseSpecialAttacks", err);
			retobj = {};
			retobj.name = sa;
			retobj.specialtype = 'ability';
			retobj.rule_category = "special-attacks";
		} finally {
			memo.push(retobj);
			return memo;
		}
	}, []);
}
function parseSpecialAbilities(str) {
	var saObj = {},
	    initiallines,
	    lines,
	    extralines,
	    contentstr,
	    tempstr,
	    lastLineIndex = 0;
	saObj.description = [];
	saObj.specialAbilities = [];
	//need to remove newlines that are right after an (Su) this is necessary for PRD
	str = str.replace(/\((Ex|Sp|Su)\)\s*(?:\r\n|[\n\v\f\r\x85\u2028\u2029])/ig, '($1) ');
	//break on newlines
	//We break 3 spaces, or on last period before a (Ex|Sp|Su) 
	//because sometimes special abilities do not have newlines between them. 
	lines = str.split(/\s\s\s|\r\n|[\n\v\f\r\x85\u2028\u2029]|special abilities|\.(?=[^\.]+\((?:Ex|Sp|Su)\))/i);
	//here is the one that grabs period before (su)
	//	initiallines = str.split(/(?:\s\s\s|\r\n|^|[\.\n\v\f\r\x85\u2028\u2029])(?=\s*spells[:\s]|\s*[\w\s]+:|[^\.\v\r\n\x85\u2028\u2029]+(?:\(Su\):??|\(Ex\):??|\(Sp\):??))/i);
	lines = SWUtils.trimBoth(lines).filter(function (line) {
		return line && !/^special abilities$/i.test(line);
	});
	_exportsLoaderTASTheAaronSheet2.default.debug("PFNPCParser.parseSpecialAbilities  split into ", lines);
	saObj = _underscore2.default.reduce(lines, function (memo, line) {
		var spObj = {},
		    splitter = '',
		    tempstr = '',
		    startIdx,
		    endIdx = -1,
		    matches,
		    abilitytype = '';
		try {
			//TAS.debug("PFNPCParser.parseSpecialAbilities on line:"+line);
			//why am i removing non word characters from the ends? what would be there?
			matches = line.match(/\((Su|Ex|Sp)\)|^(\w+):/i);
			if (!matches) {
				//this is just part of the description
				memo.description.push(line + '\r\n');
			} else if (matches[2]) {
				spObj.name = matches[2];
				spObj.description = SWUtils.trimBoth(line.slice(matches[0].length + 1));
				memo.specialAbilities.push(spObj);
			} else {
				tempstr = line.slice(0, matches.index);
				spObj.name = tempstr.replace(/^[^\w]+|[^\w]$/, '');
				spObj.basename = spObj.name.replace(/\s/g, '').toLowerCase();
				spObj.rule_category = 'special-abilities';
				spObj.ability_type = matches[1][0].toUpperCase() + matches[1][1].toLowerCase();
				spObj.description = SWUtils.trimBoth(line.slice(matches.index + matches[0].length + 1));
				matches = spObj.description.match(/(\d+d\d+) (?:points of){0,1}(.*?) damage/i);
				if (matches) {
					if (matches[1]) {
						spObj.extraDamage = '[[' + matches[1] + ']]';
					}
					if (matches[2]) {
						spObj.extraDamageType = matches[2];
					}
				} else {
					matches = spObj.description.match(/([a-z]) for (\d+d\d+) (rounds|minutes|hours|days)/i);
					if (matches) {
						if (matches[2]) {
							spObj.extraDamage = '[[' + matches[2] + ']] ' + matches[3] || '';
						}
						if (matches[1]) {
							spObj.extraDamageType = matches[1];
						}
					}
				}
				//before dc is usually 'the save'
				matches = spObj.description.match(/dc is (cha|con|wis|int|str|dex)[a-zA-Z]*.based/i);
				//TAS.debug"parseSpecialAbilities looking for DC ability it is: ",matches);
				if (matches && matches[1]) {
					tempstr = matches[1].toUpperCase();
					spObj.DCability = tempstr;
					//TAS.debug"parseSpecialAbilities setting DC ability to "+tempstr);
				} else if (_PFDB2.default.specialAttackDCAbilityBase[spObj.basename]) {
					spObj.DCability = _PFDB2.default.specialAttackDCAbilityBase[spObj.basename];
					//TAS.debug"parseSpecialAbilities setting DC ability to "+spObj.DCability+" based on "+ spObj.basename);
				}
				//bfore dc could be 'must make a', 'fails a'
				matches = spObj.description.match(/DC (\d+) (Will|Fort|Ref)[a-zA-Z]* save/i);
				if (matches) {
					if (matches[1]) {
						spObj.DC = matches[1];
					}
					if (matches[2]) {
						tempstr = matches[2][0].toUpperCase() + matches[2].slice(1).toLowerCase();
						spObj.save = tempstr;
					}
				} else {
					matches = spObj.description.match(/(Will|Fort|Ref)[a-zA-Z]* DC (\d+) ([^),.])/i);
					if (matches) {
						if (matches[1]) {
							tempstr = matches[1][0].toUpperCase() + matches[1].slice(1).toLowerCase();
							spObj.save = tempstr;
							if (matches[3]) {
								spObj.save += ' ' + matches[3];
							}
						}
						if (matches[2]) {
							spObj.DC = matches[2];
						}
					}
				}
				memo.specialAbilities.push(spObj);
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error('parseSpecialAbilities error parsing: ' + line + ' error is' + err);
		} finally {
			return memo;
		}
	}, saObj);
	//TAS.debug("parseSpecialAbilities returning",saObj);
	return saObj;
}
function parseSpecialQualities(str) {
	var matches,
	    rawAbilities,
	    saObjs = [];
	if (str) {
		//TAS.debug("PFNPCParser.parseSpecialQualities: "+str);
		//skip over "SQ" in front
		matches = str.match(/^SQ[\s:]*/i);
		if (matches) {
			str = str.slice(matches[0].length);
		}
		rawAbilities = str.split(/,\s*/);
		//TAS.debug("found the following:", rawAbilities);
		_underscore2.default.each(rawAbilities, function (ability) {
			var saAb = {},
			    type = "";
			saAb.name = ability;
			type = PFUtils.getSpecialAbilityTypeFromString(ability);
			if (type) {
				saAb.ability_type = type;
			}
			saAb.rule_category = 'special-qualities';
			saObjs.push(saAb);
		});
		//TAS.debug"returning ", saObjs);
		return saObjs;
	}
	return null;
}
function parseSLAs(spLAstr) {
	var lines,
	    clname = '',
	    lastFreq = '',
	    tempstr = '',
	    lastPerDay = 0,
	    slas = {};
	try {
		slas.spellLikeAbilities = [];
		slas.CL = 0;
		slas.concentration = 0;
		slas.classname = "";
		lines = spLAstr.split(/\r\n|[\n\v\f\r\x85\u2028\u2029]/);
		_underscore2.default.each(lines, function (line) {
			var matches,
			    slatdivider,
			    SLAArray,
			    freqStr = "",
			    slaofTypeStr = "",
			    thisSlaObj = {},
			    rawDC = 0,
			    tempstr2 = '',
			    slatype = "",
			    numPerDay = 0,
			    slasOfType,
			    header = 0,
			    row = 0,
			    hasSpellLevel = 0,
			    freqIsPer = 0,
			    tempsplit;
			try {
				//TAS.debug"parsing "+line);
				if (/CL\s*\d+/i.test(line) || /concentrat/i.test(line) || /psychic\smagic/i.test(line) || /spell.like.abilit/i.test(line)) {
					header = 1;
				} else if (/\u2013|\u2014|-/.test(line)) {
					row = 1;
				}
				if (header) {
					if (/CL\s*\d+/i.test(line)) {
						matches = line.match(/CL\s*(\d+)/i);
						if (matches[1]) {
							slas.CL = parseInt(matches[1], 10) || 0;
						}
					}
					if (/concentrat/i.test(line)) {
						matches = line.match(/concentrat[\w]*\s*[+\-]??(\d+)/i);
						if (matches[1]) {
							slas.concentration = parseInt(matches[1], 10) || 0;
						}
					}
					if (/psychic\smagic/i.test(line)) {
						slas.classname = 'Psychic Magic';
					} else {
						slas.classname = 'Spell-like abilities';
					}
				} else if (row) {
					//TAS.debug"splitting line "+line);
					matches = line.match(/\u2013|\u2014|\-/);
					slaofTypeStr = line.slice(matches.index + 1);
					freqStr = SWUtils.trimBoth(line.slice(0, matches.index)).toLowerCase();
					matches = freqStr.match(/constant|will|day|month/i);
					if (matches && matches[0]) {
						slatype = matches[0].toLowerCase();
						thisSlaObj.type = slatype;
						if (slatype === 'day' || slatype === 'month') {
							freqIsPer = 1;
							matches = freqStr.match(/\d+/);
							if (matches && matches[0]) {
								numPerDay = parseInt(matches[0], 10) || 0;
								thisSlaObj.perDay = numPerDay;
							}
						}
					} else {
						tempsplit = freqStr.split('/');
						if (tempsplit.length >= 2) {
							freqIsPer = 1;
							matches = tempsplit[0].match(/\d+/);
							if (matches && matches[0]) {
								numPerDay = parseInt(matches[0], 10) || 0;
								thisSlaObj.perDay = numPerDay;
							}
							slatype = 'other';
							thisSlaObj.type = slatype;
							thisSlaObj.otherPer = tempsplit[1];
						}
					}
					//TAS.debug"the frequency is " + slatype + " and are " + numPerDay + " per that");
					slasOfType = slaofTypeStr.split(/,\s*(?![^\(\)]*\))/);
					SLAArray = _underscore2.default.reduce(slasOfType, function (memo, sla) {
						var thissla = {},
						    dcstr = '';
						try {
							thissla.type = slatype;
							if (freqIsPer && numPerDay > 0) {
								thissla.perDay = numPerDay;
							}
							//look for spell level.
							matches = sla.match(/level\s*(\d+)/i);
							if (matches) {
								if (matches[1]) {
									//TAS.debug"spell level match on "+ sla+ " Is " + matches[1]);
									thissla.spell_level = parseInt(matches[1], 10) || 0;
									hasSpellLevel = 1;
								}
								sla = sla.replace(matches[0], '');
							}

							matches = sla.match(/D[Cc]\s*\d+/);
							if (matches) {
								tempstr2 = sla.replace(matches[0], '');
								tempstr = matches[0].match(/\d+/);
								rawDC = parseInt(tempstr, 10) || 0;
								thissla.DC = rawDC;
								matches = tempstr2.match(/\b(fortitude|willpower|reflex|fort|will|ref)\b([^,]+,)/i);
								if (matches) {
									thissla.save = matches[0]; //type of save up to first comma after it
								}
							}
							//if parenthesis, name should be only what is in parens,
							if (sla.indexOf('(') > 0) {
								thissla.name = sla.slice(0, sla.indexOf('(') - 1);
								tempstr = sla.slice(sla.indexOf('(') - 1);
								//sla= tempstr;
								//summon spells have levels
								thissla.shortdesc = tempstr;
							} else {
								thissla.name = sla;
							}
							if (thissla.spell_level && /^summon/i.test(thissla.name)) {
								thissla.name += " Level " + String(thissla.spell_level);
							}
							memo.push(thissla);
						} catch (errslain) {
							_exportsLoaderTASTheAaronSheet2.default.error("parseSLAs, error reducing to SLAArray for: " + sla, errslain);
							if (!thissla.name) {
								thissla.name = sla;
							} else {
								thissla.description = sla;
							}
							memo.push(thissla);
						} finally {
							return memo;
						}
					}, []);
					if (SLAArray && _underscore2.default.size(SLAArray) > 0) {
						thisSlaObj.type = slatype;
						if (freqIsPer && numPerDay > 0) {
							thisSlaObj.perDay = numPerDay;
						}
						thisSlaObj.SLAs = SLAArray;
						slas.spellLikeAbilities.push(thisSlaObj);
					}
				} else {
					_exportsLoaderTASTheAaronSheet2.default.warn("Cannot parse " + line);
					return;
				}
			} catch (ierr) {
				_exportsLoaderTASTheAaronSheet2.default.error("parseSLAs error parsing" + line, ierr);
			}
		});
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("parseSLAs", err);
	} finally {
		if (slas.spellLikeAbilities && _underscore2.default.size(slas.spellLikeAbilities) > 0) {
			return slas;
		}
		return null;
	}
}
/** parseSpells - parses spell string from compendium and returns js object
 *@param {string} spellstr the block of spells known text ex: "Sorcerer Spells Known (CL 8th)\r\n3rd (3/day)-Fireball (DC12)," etc
 *@returns {jsobject} {classname:"name",CL:#,concentration:#,
 * spells:{
 *	0:[{name:spellname,DC:#}],
 *   1:[{name:spellname},{name:spellname}]
 * }}
 */
function parseSpells(spellstr) {
	var lines,
	    spells = {};
	spells.classLevel = -1;
	spells.concentration = -1;
	spells.classname = "";
	spells.spellsByLevel = [];

	if (!spellstr) {
		return null;
	}
	lines = spellstr.split(/\r\n|[\n\v\f\r\x85\u2028\u2029]/);
	spells = _underscore2.default.reduce(lines, function (omemo, line) {
		var matches,
		    spellarray,
		    slatdivider,
		    splittedSpells,
		    dcstr,
		    tempstr,
		    temparray = [],
		    match,
		    thislvl = {},
		    slasOfType;
		thislvl.perDay = -1;
		thislvl.spellLevel = -1;
		try {
			if (spells.classLevel === -1 && /C[Ll]\s*\d+/i.test(line)) {
				matches = line.match(/C[Ll]\s*(\d+)/i);
				if (matches && matches[1]) {
					spells.classLevel = parseInt(matches[1], 10) || 0;
				}
				matches = line.match(/concentrat[\w]*\s*[+\-]??(\d+)/i);
				if (matches && matches[1]) {
					spells.concentration = parseInt(matches[1], 10) || 0;
				}
				matches = line.match(/([\w\s]*)spells\s(?:known|prepared)/i);
				if (matches && matches[1]) {
					spells.classname = matches[1].replace(/^\s|\s$/g, '');
					spells.classname = spells.classname[0].toUpperCase() + spells.classname.slice(1).toLowerCase();
				} else if (/spells\sprepared/i.test(line)) {
					spells.classname = 'Cleric'; //if prep caster then not a sorcerer
				} else {
					spells.classname = 'Sorcerer'; //default
				}
			} else {
				//look for endash, emdash, or dash
				slatdivider = line.split(/\u2013|\u2014|-/);
				if (slatdivider && slatdivider[0]) {
					matches = slatdivider[0].match(/^(\d+)/);
					if (matches && matches[1]) {
						thislvl.spellLevel = parseInt(matches[1], 10) || 0;
						matches = slatdivider[0].match(/(\d+)\/day/i);
						if (matches && matches[1]) {
							thislvl.perDay = parseInt(matches[1], 10) || 0;
						}
					} else {
						match = slatdivider[0].match(/opposition schools\s*/i);
						if (match) {
							tempstr = slatdivider[0].slice(match.index + match[0].length);
							spells.oppositionschools = tempstr;
						} else {
							//stuff is here but what? add to notes
							spells.spellnotes = slatdivider[0];
						}
					}
				}
				if (slatdivider && slatdivider[1]) {
					splittedSpells = slatdivider[1].split(',');
					spellarray = _underscore2.default.reduce(splittedSpells, function (memo, spell) {
						var thisspell = {};
						try {
							matches = spell.split(/\(dc/i);
							thisspell.name = matches[0].replace(/^\s|\s$/g, '');
							if (matches[1]) {
								dcstr = matches[1];
								matches = dcstr.match(/\d+/);
								if (matches && matches[0]) {
									thisspell.DC = parseInt(matches[0], 10) || 0;
								}
							}
							memo.push(thisspell);
						} catch (errinner) {
							_exportsLoaderTASTheAaronSheet2.default.error("PFNPCParser.parseSpells errinner:", errinner);
						} finally {
							return memo;
						}
					}, []);
					if (thislvl.spellLevel >= 0 && spellarray && spellarray.length > 0) {
						thislvl.spells = spellarray;
						omemo.spellsByLevel.push(thislvl);
					}
				}
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFNPCParser.parseSpells", err);
		} finally {
			return omemo;
		}
	}, spells);
	return spells;
}
function parseSpace(spaceStr) {
	var retstr = spaceStr,
	    matches,
	    tempFloat;
	try {
		matches = spaceStr.match(/\s*(\d*\.?\d*)?/);
		if (matches) {
			tempFloat = parseFloat(matches[1]);
			if (!isNaN) {
				retstr = String(tempFloat);
			}
		}
	} finally {
		return retstr;
	}
}
/** Gets info on caster from the spells known/prepared section.
 * @param {Map<string,any>} spellObj output from parseSpells
 * @param {Map<string,number>} abilityScores ability score base and modifiers
 * @param {Map<string,any>} healthObj output from parseNPChp
 * @param {boolean} isSLA if spell-like-ability then 1 else 0
 * @returns {{'classname':string,'ability':string,'abilityMod':number,'CL':number,'concentrationBonus':number,'oppositionschools':[string],'spellnotes':string}}
 */
function getCasterObj(spellObj, abilityScores, healthObj, isSLA) {
	var caster = {};
	if (!spellObj || !abilityScores || !healthObj) {
		return null;
	}
	try {
		//TAS.debug"getCasterObj spellObj,abilities,health are:", spellObj, abilityScores, healthObj);
		caster.abilityMod = 0;
		caster.CL = 0;
		caster.concentrationBonus = 0;
		if (isSLA || !spellObj.classname) {
			caster.classname = isSLA ? "Spell-like abilities" : "Sorcerer";
			caster.ability = 'CHA';
			caster.abilityMod = abilityScores.cha.mod;
		} else {
			caster.classname = spellObj.classname;
			if (_PFDB2.default.casterDefaultAbility[spellObj.classname] && abilityScores[_PFDB2.default.casterDefaultAbility[spellObj.classname]]) {
				caster.ability = _PFDB2.default.casterDefaultAbility[spellObj.classname].toUpperCase();
				caster.abilityMod = abilityScores[_PFDB2.default.casterDefaultAbility[spellObj.classname]].mod;
			}
		}
		if (spellObj.classLevel) {
			caster.CL = spellObj.classLevel;
		} else {
			//assume HD
			caster.CL = healthObj.hdice1;
		}
		if (spellObj.concentration) {
			caster.concentrationBonus = spellObj.concentration - caster.abilityMod - caster.CL;
		}
		if (spellObj.oppositionschools) {
			caster.oppositionschools = spellObj.oppositionschools;
			spellObj.oppositionschools = null;
		}
		if (spellObj.spellnotes) {
			caster.spellnotes = spellObj.spellnotes;
			spellObj.spellnotes = null;
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("getCasterObj error trying to create obj returning null", err);
		caster = null;
	} finally {
		//TAS.debug"returning ", caster);
		return caster;
	}
}
function setCasterFields(setter, casterObj, classidx) {
	var alreadyPresent = false;
	try {
		//TAS.debug"setCasterFields");
		classidx = classidx || 0;
		if (classidx < 0) {
			classidx = 0;
		}
		if (setter["spellclass-" + classidx + "-name"] || setter["spellclass-" + classidx + "-level"]) {
			if (!(parseInt(setter["spellclass-" + classidx + "-level"], 10) === parseInt(casterObj.CL, 10) && PFUtils.findAbilityInString(setter["Concentration-" + classidx + "-ability"]) === casterObj.ability.toUpperCase())) {
				classidx++;
			} else {
				alreadyPresent = true;
			}
		}
		if (classidx > 2) {
			_exportsLoaderTASTheAaronSheet2.default.error("Could not setCasterFields, 0,1,2 spellclasses already defined:" + setter["spellclass-0-name"] + ", " + setter["spellclass-1-name"] + ", " + setter["spellclass-2-name"], classidx);
			casterObj.pageClassIdx = -1;
		} else if (alreadyPresent) {
			setter["spellclass-" + classidx + "-name"] = setter["spellclass-" + classidx + "-name"] + " and " + casterObj.classname;
			casterObj.pageClassIdx = classidx;
		} else {
			setter["spellclass-" + classidx + "-name"] = casterObj.classname;
			//should add class here ? setter['class-'+what+'-name']
			setter["spellclass-" + classidx + "-level"] = casterObj.CL; //if they have hit dice, this will make it increase? not if we don'tdo class-x-level
			setter["spellclass-" + classidx + "-level-total"] = casterObj.CL;
			if (/wizard|cleric|druid|paladin|ranger|investigator|shaman|witch|alchemist|warpriest/i.test(casterObj.classname)) {
				setter["spellclass-" + classidx + "-casting_type"] = 2; //prepared
			} else {
				setter["spellclass-" + classidx + "-casting_type"] = 1; //spontaneous
			}
			if (casterObj.ability) {
				setter["Concentration-" + classidx + "-ability"] = "@{" + casterObj.ability + "-mod}";
			}
			setter["Concentration-" + classidx + "-mod"] = casterObj.abilityMod;
			if (casterObj.concentrationBonus) {
				setter["Concentration-" + classidx + "-misc"] = casterObj.concentrationBonus;
			}
			casterObj.pageClassIdx = classidx;
			if (casterObj.oppositionschools) {
				setter["spellclass-" + classidx + "-oppositionschool-0"] = casterObj.oppositionschools;
			}
			if (casterObj.spellnotes) {
				setter["spellclass-" + classidx + "-notes"] = casterObj.spellnotes;
			}
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("setSLACasterFields", err);
	} finally {
		return setter;
	}
}
/** createSpellEntries
 *@param {jsobject} setter - map to pass to setAttrs
 *@param {jsobject} spellObj obj like: {classname:"name",CL:#,concentration:#,
 *	spells:{
 *		0:[{name:spellname,DC:#}],
 *		1:[{name:spellname},{name:spellname}]
 *	}}
 *@param {?} casterObj ?
 *@param {?} section ?
 *@returns {jsobject} setter
 */
function createSpellEntries(setter, spellObj, casterObj, section) {
	section = section || 'spells';
	setter = setter || {};
	if (!spellObj || !casterObj) {
		return setter;
	}
	_underscore2.default.each(spellObj.spellsByLevel, function (spellLevel) {
		var thisSpellLevel = parseInt(spellLevel.spellLevel, 10) || 0,
		    baseDC = 0,
		    perdayPrefix = "";
		try {
			//TAS.debug"now look at level " + thisSpellLevel + " spells", spellLevel);
			perdayPrefix = "spellclass-" + casterObj.pageClassIdx + "-level-" + thisSpellLevel;
			if (spellLevel.perDay) {
				setter[perdayPrefix + "-class"] = spellLevel.perDay;
				setter[perdayPrefix + "-spells-per-day_max"] = spellLevel.perDay;
				setter[perdayPrefix + "-spells-per-day"] = spellLevel.perDay;
			}
			baseDC = 10 + thisSpellLevel + (parseInt(casterObj.abilityMod, 10) || 0);
		} catch (errlvl) {
			_exportsLoaderTASTheAaronSheet2.default.error("createSpellEntries error setting spells per day", errlvl);
		}
		setter = _underscore2.default.reduce(spellLevel.spells, function (memo, spell) {
			var newRowId = generateRowID(),
			    thisDC = 0,
			    prefix = "repeating_" + section + "_" + newRowId + "_";
			try {
				setter[prefix + "name"] = spell.name[0].toUpperCase() + spell.name.slice(1);
				setter[prefix + "classnumber"] = casterObj.pageClassIdx;
				setter[prefix + "spellclass"] = casterObj.classname;
				setter[prefix + "spell_level"] = thisSpellLevel;
				if (spell.DC) {
					thisDC = parseInt(spell.DC, 10) || 0;
					if (thisDC !== baseDC) {
						setter[prefix + "DC_misc"] = thisDC - baseDC;
					}
					setter[prefix + "savedc"] = thisDC;
				}
				if (casterObj.concentration) {
					setter[prefix + "Concentration-mod"] = casterObj.concentration;
				}
			} catch (err) {
				_exportsLoaderTASTheAaronSheet2.default.error("createSpellEntries error setting spell :", spell, err);
			} finally {
				return setter;
			}
		}, setter);
	});
	return setter;
}
function createSLAEntries(setter, slaObj, casterObj, section) {
	var defaultLevel = 0;
	section = section || 'ability';
	setter = setter || {};
	if (!slaObj || !casterObj) {
		return setter;
	}
	defaultLevel = parseInt(setter.level, 10) || 0;

	_underscore2.default.each(slaObj.spellLikeAbilities, function (perDaySLAs) {
		var thisPerDay = parseInt(perDaySLAs.perDay, 10) || 0,
		    freqType = perDaySLAs.type;
		//TAS.debug" at one set of SLAs, freq:" + freqType + " and perday:" + thisPerDay, perDaySLAs);
		setter = _underscore2.default.reduce(perDaySLAs.SLAs, function (memo, SLA) {
			var newRowId,
			    prefix = "repeating_" + section + "_" + newRowId + "_",
			    casterAbility,
			    dcTot = 0,
			    dcMod = 0,
			    sdstr = "",
			    charlvl = 0,
			    clmisc = 0,
			    tempint = 0,
			    slmisc = 0,
			    casterlevel = 0;
			try {
				newRowId = generateRowID();
				prefix = "repeating_" + section + "_" + newRowId + "_";
				memo[prefix + "name"] = SLA.name[0].toUpperCase() + SLA.name.slice(1);
				memo[prefix + "ability_type"] = 'Sp';
				memo[prefix + "rule_category"] = 'spell-like-abilities';
				memo[prefix + 'showinmenu'] = '1';
				if (casterObj.ability) {
					casterAbility = casterObj.ability;
					memo[prefix + "ability-basis"] = "@{" + casterObj.ability + "-mod}";
				} else {
					casterAbility = "CHA";
					memo[prefix + "ability-basis"] = "@{CHA-mod}";
				}
				memo[prefix + "CL-basis"] = "@{npc-hd-num}";
				memo[prefix + "CL-basis-mod"] = setter.level;
				if (setter['race']) {
					memo[prefix + "class-name"] = setter['race'];
				}
				//TAS.debug"CREATE SLA casterObj.CL: " + casterObj.CL + ", level:" + setter.level + " when processing "+ SLA );
				if (casterObj.CL) {
					tempint = setter.level || 0;
					if (tempint > 0) {
						memo[prefix + "CL-misc"] = casterObj.CL - tempint;
						memo[prefix + "CL-misc-mod"] = casterObj.CL - tempint;
					}
					casterlevel = casterObj.CL;
				} else {
					casterlevel = setter.level || 0;
				}

				memo[prefix + 'casterlevel'] = casterlevel;
				//assume 1/2? or calc based on DC?
				if (SLA.spell_level) {
					if (SLA.spell_level === defaultLevel) {
						memo[prefix + "spell_level-basis"] = "@{casterlevel}";
					} else if (SLA.spell_level === Math.floor(defaultLevel / 2)) {
						memo[prefix + "spell_level-basis"] = "floor(@{casterlevel}/2)";
					} else {
						memo[prefix + "spell_level-basis"] = "0";
						memo[prefix + "spell_level-misc"] = SLA.spell_level;
					}
				} else {
					memo[prefix + "spell_level-basis"] = "floor(@{casterlevel}/2)";
				}
				//memo[prefix+"classnumber"]=casterObj.pageClassIdx;
				//memo[prefix+"spellclass"]=casterObj.classname;
				switch (freqType) {
					case 'day':
						memo[prefix + "frequency"] = 'perday';
						memo[prefix + "used"] = thisPerDay;
						memo[prefix + "used_max"] = thisPerDay;
						memo[prefix + "max-calculation"] = thisPerDay;
						memo[prefix + "hasfrequency"] = '1';
						memo[prefix + "hasuses"] = '1';
						break;
					case 'will':
						memo[prefix + "frequency"] = 'atwill';
						memo[prefix + "hasfrequency"] = '1';
						break;
					case 'constant':
						memo[prefix + "frequency"] = "constant";
						memo[prefix + "hasfrequency"] = '1';
						break;
					case 'month':
						memo[prefix + "frequency"] = "permonth";
						memo[prefix + "used"] = thisPerDay;
						memo[prefix + "used_max"] = thisPerDay;
						memo[prefix + "max-calculation"] = thisPerDay;
						memo[prefix + "hasfrequency"] = '1';
						memo[prefix + "hasuses"] = '1';
						break;
					case 'everyrounds':
						memo[prefix + "frequency"] = "everyrounds";
						memo[prefix + "hasfrequency"] = '1';
						memo[prefix + "rounds_between"] = SLA.used || '';
						break;
					case 'other':
						memo[prefix + "frequency"] = "other";
						memo[prefix + "used"] = thisPerDay;
						memo[prefix + "used_max"] = thisPerDay;
						memo[prefix + "max-calculation"] = thisPerDay;
						memo[prefix + "hasfrequency"] = '1';
						memo[prefix + "hasuses"] = '1';
						if (slaObj.otherPer) {
							sdstr = "Frequency per :" + slaObj.otherPer;
						}
						break;
				}
				if (SLA.save) {
					memo[prefix + "save"] = SLA.save;
				}
				if (SLA.DC) {
					try {
						if (!SLA.save) {
							memo[prefix + "save"] = "See Text";
						}
						if (casterObj.abilityMod) {
							tempint = 0;
							if (SLA.spell_level) {
								tempint = 10 + casterObj.abilityMod + SLA.spell_level;
							} else {
								tempint = 10 + casterObj.abilityMod + Math.floor(casterlevel / 2);
							}
							if (tempint !== SLA.DC) {
								memo[prefix + "spell_level-misc"] = SLA.DC - tempint;
								memo[prefix + "spell_level-misc-mod"] = SLA.DC - tempint;
							}
						}
					} catch (err3) {
						_exportsLoaderTASTheAaronSheet2.default.error("createSLAentries, error trying to calculate DC: " + SLA, err3);
					}
				}
				if (SLA.description) {
					memo[prefix + "description"] = SLA.description;
				}
				if (SLA.shortdesc) {
					if (sdstr) {
						sdstr = SLA.shortdesc + ", " + sdstr;
					} else {
						sdstr = SLA.shortdesc;
					}
				}
				if (sdstr) {
					memo[prefix + "short-description"] = sdstr;
				}
			} catch (err) {
				_exportsLoaderTASTheAaronSheet2.default.error("createSLAEntries error setting SLA :", SLA, err);
			} finally {
				return memo;
			}
		}, setter);
	});
	return setter;
}
/**createAttacks - creates rows in repeating_weapon
 * @param {[{enh:number,name:string,type:string,countFullBAB:number,plus:string,note:string,iter:[number],dmgdice:number,dmgdie:number,crit:number,critmult:number,dmgbonus:number}]} attacklist
 * @param {Map<string,any>} setter the map to pass to setAttrs
 * @param {Map<string,number>} attackGrid populated as out param by parseAndCreateAttacks
 * @param {Map<string,number>} abilityScores output of parseAbilityScores
 * @param {[string]} importantFeats list of attack-affecting feats this char has
 * @param {number} defaultReach the default reach for melee attacks
 * @param {[[string,number]]} exceptionReaches list of attack names and reach numbers
 * @param {Map<string,number>} sizeMap output from PFSize.getSizeFromText
 * @returns {Map<string,any>} setter
 */
function createAttacks(attacklist, setter, attackGrid, abilityScores, importantFeats, defaultReach, exceptionReaches, sizeMap) {
	setter = setter || {};
	if (!attacklist || _underscore2.default.size(attacklist) === 0) {
		return setter;
	}

	//TAS.debug("##################","create attacks:", attacklist, attackGrid, abilityScores, importantFeats, defaultReach, exceptionReaches);
	setter = _underscore2.default.reduce(attacklist, function (memo, attack) {
		var newRowId = generateRowID(),
		    prefix = "repeating_weapon_" + newRowId + "_",
		    dmgAbilityStr = false,
		    specCMB = false,
		    i = 0,
		    iterativeNum = 0,
		    basebonus = 0,
		    tempInt = 0,
		    dmgMult = 1,
		    dmgMod = 0,
		    tohitbonus = 0,
		    name = "",
		    tempstr = "",
		    basename = "",
		    iterZero = NaN,
		    reach,
		    newRowId2,
		    prefix2;
		//TAS.debug"creating attack row id:" + newRowId);
		try {
			//TAS.debug"looking at attack:", attack);
			tohitbonus = Math.max(attack.enh, attack.mwk);
			basename = attack.basename;
			//basename.replace(/^group.*?:\s*/,'');
			name += attack.name;
			if (attack.plus) {
				name += " Plus " + attack.plus;
			}
			memo[prefix + "name"] = name;
			memo[prefix + "default_size"] = sizeMap.size;
			if (attack.atktype === 'ranged') {
				basebonus = attackGrid.ranged;
				memo[prefix + "attack-type"] = "@{attk-ranged}";
				memo[prefix + "attack-type-mod"] = attackGrid.ranged;
				memo[prefix + "isranged"] = 1;
			} else if (_PFDB2.default.cmbPlusStrsrch.test(basename)) {
				basebonus = attackGrid.cmb;
				memo[prefix + "attack-type"] = "@{CMB}";
				memo[prefix + "attack-type-mod"] = attackGrid.cmb;
				dmgAbilityStr = true;
				dmgMult = 1.5;
				specCMB = true;
			} else if (attack.atktype === 'cmb') {
				basebonus = attackGrid.cmb;
				memo[prefix + "attack-type"] = "@{CMB}";
				memo[prefix + "attack-type-mod"] = attackGrid.cmb;
			} else if (attack.atktype === 'special') {
				basebonus = 0;
				memo[prefix + "attack-type-mod"] = 0;
				memo[prefix + "total-attack"] = 0;
			} else {
				dmgAbilityStr = true;
				//melee
				if (importantFeats.weaponfinesse) {
					//assume all attacks use weapon finesse
					basebonus = attackGrid.melee2;
					memo[prefix + "attack-type"] = "@{attk-melee2}";
					memo[prefix + "attack-type-mod"] = attackGrid.melee2;
				} else {
					basebonus = attackGrid.melee;
					memo[prefix + "attack-type"] = "@{attk-melee}";
					memo[prefix + "attack-type-mod"] = attackGrid.melee;
				}
				if (attack.type === 'natural') {
					if (attack.naturaltype === 'secondary') {
						dmgMult = 0.5;
					} else if (attack.dmgMult && attack.dmgMult === 1.5) {
						memo[prefix + "damage_ability_mult"] = 1.5;
						dmgMult = 1.5;
					}
				}
			}
			//if(specCMB){
			//	TAS.debug("############ SPEC CMB ###############","dmgAbilityStr:"+dmgAbilityStr+" attackbonus:"+basebonus +", mult:"+ dmgMult);
			//}
			if (dmgAbilityStr || specCMB) {
				if (specCMB && attack.dmgbonus === 0) {
					memo[prefix + "damage-ability"] = "0";
					dmgMod = 0;
				} else {
					memo[prefix + "damage-ability"] = "@{STR-mod}";
					if (dmgMult !== 1) {
						dmgMod = Math.floor(dmgMult * abilityScores.str.mod);
						memo[prefix + "damage_ability_mult"] = dmgMult;
					} else {
						dmgMod = abilityScores.str.mod;
					}
				}
				memo[prefix + "damage-ability-mod"] = dmgMod;
			}
			if (attack.enh) {
				memo[prefix + "enhance"] = attack.enh;
			}
			if (attack.mwk) {
				memo[prefix + "masterwork"] = "1";
			}
			if (!specCMB && attack.iter && attack.iter.length > 0) {
				iterZero = parseInt(attack.iter[0], 10);
			} else if (specCMB) {
				iterZero = basebonus;
			}
			if (!isNaN(iterZero)) {
				if (specCMB) {
					memo[prefix + "attack"] = 0;
					memo[prefix + "attack-mod"] = 0;
					memo[prefix + "total-attack"] = basebonus;
				} else {
					memo[prefix + "attack"] = iterZero - tohitbonus - basebonus;
					memo[prefix + "attack-mod"] = iterZero - tohitbonus - basebonus;
					memo[prefix + "total-attack"] = iterZero;
				}
			} else if (attack.atktype === 'cmb') {
				if (/swallowwhole|pin/i.test(attack.basename)) {
					//if confirming crit add +5
					memo[prefix + "attack"] = 5;
					memo[prefix + "attack-mod"] = 5;
					memo[prefix + "total-attack"] = attackGrid.cmb + 5;
				} else {
					memo[prefix + "total-attack"] = attackGrid.cmb;
				}
			} else {
				memo[prefix + "total-attack"] = 0;
			}
			if (attack.crit !== 20) {
				memo[prefix + "crit-target"] = attack.crit;
			}
			if (attack.critmult !== 2 && attack.critmult) {
				memo[prefix + "crit-multiplier"] = attack.critmult;
			}
			if (importantFeats.criticalfocus) {
				memo[prefix + "crit_conf_mod"] = 4;
			}
			//somewhere this is getting lost:  just bandaid it:
			if (!memo[prefix + "total-attack"]) {
				memo[prefix + "total-attack"] = 0;
			}
			memo[prefix + "damage-dice-num"] = attack.dmgdice;
			memo[prefix + "default_damage-dice-num"] = attack.dmgdice;
			memo[prefix + "damage-die"] = attack.dmgdie;
			memo[prefix + "default_damage-die"] = attack.dmgdie;
			memo[prefix + "damage"] = attack.dmgbonus - attack.enh - dmgMod;
			memo[prefix + "damage-mod"] = attack.dmgbonus - attack.enh - dmgMod;
			memo[prefix + "total-damage"] = attack.dmgbonus;
			if (attack.note) {
				memo[prefix + "notes"] = "(" + attack.type + ") " + attack.note;
			} else {
				memo[prefix + "notes"] = "(" + attack.type + ")";
			}
			if (attack.iter.length > 1) {
				for (i = 1; i < attack.iter.length; i++) {
					iterativeNum = i + 1;
					//TAS.debug"at iteration " + iterativeNum + ", difference is :" + (attack.iter[i] - attack.iter[0]));
					memo[prefix + "toggle_iterative_attack" + iterativeNum] = "@{var_iterative_attack" + iterativeNum + "_macro}";
					memo[prefix + "iterative_attack" + iterativeNum + "_value"] = attack.iter[i] - attack.iter[0];
				}
			} else if (attack.countFullBAB > 1) {
				for (i = 1; i < attack.countFullBAB; i++) {
					iterativeNum = i + 1;
					memo[prefix + "toggle_iterative_attack" + iterativeNum] = "@{var_iterative_attack" + iterativeNum + "_macro}";
					memo[prefix + "iterative_attack" + iterativeNum + "_value"] = 0;
				}
			}
			// plus extra damage  **********************
			if (attack.plusamount) {
				memo[prefix + "precision_dmg_macro"] = "[[" + attack.plusamount + "]]";
				if (attack.plustype) {
					memo[prefix + "precision_dmg_type"] = attack.plustype;
				}
			} else if (attack.plus) {
				memo[prefix + "precision_dmg_type"] = "Plus";
				memo[prefix + "precision_dmg_macro"] = attack.plus;
			}
			if (attack.dmgtype) {
				memo[prefix + "notes"] = memo[prefix + "notes"] + ", damage type:" + attack.dmgtype;
			}
			//reach **************************
			if (attack.range) {
				tempInt = parseInt(attack.range, 10);
				if (isNaN(tempInt)) {
					memo[prefix + "notes"] = memo[prefix + "notes"] + ", range:" + attack.range;
				}
			} else if (/tongue/i.test(attack.name)) {
				reach = defaultReach * 3;
				memo[prefix + "range"] = reach;
				memo[prefix + "vs"] = "touch";
			} else if (attack.atktype === "melee") {
				if (exceptionReaches && exceptionReaches.length > 0) {
					//TAS.log("looking for match",exceptionReaches);
					reach = _underscore2.default.filter(exceptionReaches, function (reacharray) {
						//TAS.log("matching "+basename+" with "+reacharray[0]);
						if (basename.indexOf(reacharray[0]) >= 0) {
							//TAS.log("it matches!"+reacharray[0]);
							return true;
						}
						return false;
					});
					//TAS.log(reach);
					if (reach && reach[0] && reach[0][1]) {
						memo[prefix + "range"] = reach[0][1];
					} else if (defaultReach) {
						memo[prefix + "range"] = defaultReach;
					}
				} else if (defaultReach) {
					memo[prefix + "range"] = defaultReach;
				}
			}
			if (attack.vs && !/tongue/i.test(attack.name)) {
				memo[prefix + "vs"] = attack.vs;
			}
			if (attack.group) {
				memo[prefix + "group"] = attack.group;
			}
			if (attack.dc) {
				memo[prefix + "notes"] = memo[prefix + "notes"] + " " + attack.dc + attack.dcequation ? " " + attack.dcequation : '';
			}
		} catch (err) {
			_exportsLoaderTASTheAaronSheet2.default.error("createattacks error on:", attack, err);
		} finally {
			return memo;
		}
	}, setter);
	//TAS.debug("end of create attacks returning:", setter);
	return setter;
}
function createACEntries(setter, acMap, abilityScores, importantFeats, hpMap, bab) {
	var acAbility = "DEX",
	    acDexDef = abilityScores.dex.mod,
	    calcCMD = 0,
	    altbab = 0;
	try {
		//TAS.debug("acMap", acMap);
		if (acMap.altability) {
			//this should no longer happen.
			//TAS.debug("different ability score for AC!");
			acAbility = acMap.altability.toUpperCase();
			if (acAbility !== "DEX") {
				setter["AC-ability"] = "( ((@{XXX-mod} + [[ @{max-dex-source} ]]) - abs(@{XXX-mod} - [[ @{max-dex-source} ]])) / 2 )".replace(/XXX/g, acAbility);
				setter["CMD-ability2"] = "( ((@{XXX-mod} + [[ @{max-dex-source} ]]) - abs(@{XXX-mod} - [[ @{max-dex-source} ]])) / 2 )".replace(/XXX/g, acAbility);
				switch (acMap.altability.toLowerCase()) {
					case 'wis':
						acDexDef = abilityScores.wis.mod;
						break;
					case 'int':
						acDexDef = abilityScores['int'].mod;
						break;
					case 'cha':
						acDexDef = abilityScores.cha.mod;
						break;
					case 'con':
						acDexDef = abilityScores.con.mod;
						break;
					default:
						acDexDef = abilityScores.dex.mod;
						break;
				}
				setter["AC-ability-mod"] = acDexDef;
			}
		}
		//has uncanny dodge
		if (acMap.uncanny) {
			setter["FF-ability"] = "@{XXX-mod}".replace(/XXX/g, acAbility);
			setter["FF-ability-mod"] = acDexDef;
			setter["CMD-ability"] = "( ((@{XXX-mod} + [[ @{max-dex-source} ]]) - abs(@{XXX-mod} - [[ @{max-dex-source} ]])) / 2 )".replace(/XXX/g, acAbility);
			setter["CMD-ability"] = acDexDef;
			setter["uncanny_dodge"] = 1;
			setter["uncanny_cmd_dodge"] = 1;
		}
		altbab = bab;
		if (importantFeats.defensivecombattraining) {
			setter['hd_not_bab'] = 1;
			if (setter.level) {
				altbab = parseInt(setter.level, 10);
			}
			if (!altbab) {
				altbab = (hpMap.hdice1 || 0) + (hpMap.hdice2 || 0);
			}
		}
		try {
			calcCMD = 10 + altbab + abilityScores.str.mod + acDexDef + -1 * acMap.size;
			//TAS.debug("bab:"+altbab+"+ str:"+ abilityScores.str.mod + "+ dex" + acDexDef + " - size: " +acMap.size + ", calcCMD:"+calcCMD+", cmdparsed:"+acMap.cmd);
			if (isNaN(acMap.cmd) || calcCMD === acMap.cmd) {
				setter["CMD"] = calcCMD;
			} else {
				setter["CMD"] = acMap.cmd;
				setter["CMD-misc"] = acMap.cmd - calcCMD;
			}
		} catch (err2) {
			_exportsLoaderTASTheAaronSheet2.default.error("createACEntries error trying to calculate CMD", err2);
		}

		setter["AC"] = acMap.ac;
		setter["Touch"] = acMap.touch;
		setter["Flat-Footed"] = acMap.ff;
		setter["AC-deflect"] = acMap.deflect;
		setter["AC-dodge"] = acMap.dodge;
		setter["AC-misc"] = acMap.misc;
		setter["AC-natural"] = acMap.natural;
		if (acMap.armor) {
			setter["armor3-equipped"] = "1";
			setter["armor3-acbonus"] = acMap.armor;
			setter["armor3"] = "Armor bonus";
			setter["AC-armor"] = acMap.armor;
		}
		if (acMap.shield) {
			setter["shield3-equipped"] = "1";
			setter["shield3-acbonus"] = acMap.shield;
			setter["shield3"] = "Shield bonus";
			setter["AC-shield"] = acMap.shield;
		}
		if (acMap.notes) {
			setter['defense-notes'] = acMap.notes;
		}
		if (acMap.cmdnotes) {
			setter['cmd-notes'] = acMap.cmdnotes;
		}
		if (acMap.acbuff) {
			setter = PFBuffs.createTotalBuffEntry("AC adjustment from import", "AC", acMap.acbuff, acMap.acbuff, setter);
		}
	} catch (err) {} finally {
		return setter;
	}
}
function createSkillEntries(setter, skills, racial, abilityScores, importantFeats, classSkills, sizeMap, isUndead) {
	var npcSkillsWithFillInNames = ["Craft", "Perform", "Profession"],
	    craftLevel = -1,
	    performLevel = -1,
	    professionLevel = -1,
	    runningTot = 0,
	    counter = 0,
	    tempAbilities = PFSkills.coreSkillAbilityDefaults,
	    tempstr = "",
	    skillfeats = /skillfocus|intimidatingprowess/i;
	try {
		//TAS.debug("PFNPC createSkillEntries sizemap is: ", sizeMap, "skills ", skills , "racial", racial);
		if (racial) {
			if (racial.abilitymods && _underscore2.default.size(racial.abilitymods) > 0) {
				//set default ability for skill and substitute adjustments, make sure to use copy not original
				tempAbilities = _underscore2.default.extend({}, PFSkills.coreSkillAbilityDefaults, racial.abilitymods);
				setter = _underscore2.default.reduce(racial.abilitymods, function (memo, ability, skill) {
					memo[skill + "-ability"] = "@{" + ability.toUpperCase() + "-mod}";
					memo[skill + "-ability-mod"] = abilityScores[ability].mod;
					return memo;
				}, setter);
			}
			if (racial.skillmods && _underscore2.default.size(racial.skillmods) > 0) {
				setter = _underscore2.default.reduce(racial.skillmods, function (memo, mod, skill) {
					memo[skill + "-racial"] = mod;
					return memo;
				}, setter);
			}
			if (racial.skillnotes && racial.skillnotes.length > 0) {
				tempstr = "";
				_underscore2.default.each(racial.skillnotes, function (note) {
					tempstr += note + ", ";
				});
				tempstr.replace(/,\s$/, '');
				if (tempstr) {
					setter["Skill-notes"] = tempstr;
				}
			}
		}
		if (importantFeats && _underscore2.default.size(importantFeats) > 0) {
			setter = _underscore2.default.reduce(importantFeats, function (memo, val, feat) {
				if (/intimidatingprowess/i.test(feat)) {
					memo["Intimidate-misc"] = '@{STR-mod}';
					memo["Intimidate-misc-mod"] = abilityScores.str.mod;
				} else if (/skillfocus/i.test(feat)) {
					_underscore2.default.each(val, function (val2, skill) {
						memo[skill + "-feat"] = 3;
					});
				}
				return memo;
			}, setter);
		}
		if (classSkills && _underscore2.default.size(classSkills) > 0) {
			setter = _underscore2.default.reduce(classSkills, function (memo, skill) {
				try {
					if (skill === "Knowledge") {
						_underscore2.default.each(PFSkills.knowledgeSkills, function (kSkill) {
							memo[kSkill + "-cs"] = 3;
						});
					} else if (_underscore2.default.contains(PFSkills.coreSkillsWithFillInNames, skill)) {
						_underscore2.default.each(PFSkills.allFillInSkillInstances[skill], function (subskill) {
							memo[subskill + '-cs'] = 3;
						});
					} else {
						memo[skill + "-cs"] = 3;
					}
				} catch (err) {
					_exportsLoaderTASTheAaronSheet2.default.error("createSkillEntries", err);
				} finally {
					return memo;
				}
			}, setter);
		}
		setter = _underscore2.default.reduce(skills, function (memo, tot, skill) {
			var ability = "",
			    tempint = 0,
			    abilitymod = 0,
			    ranks = 0;
			try {
				tot = parseInt(tot, 10) || 0;
				if (tempAbilities[skill]) {
					ability = tempAbilities[skill];
					abilitymod = abilityScores[ability] ? abilityScores[ability].mod : 0;
					//TAS.debug("now setting " + skill + ", total:" + tot +", size:",sizeMap);
					memo[skill] = tot;
					ranks = tot;
					ranks -= abilitymod;
					if (skill === 'Stealth') {
						if (sizeMap.skillSize !== 0) {
							ranks -= 2 * sizeMap.skillSize;
						}
					} else if (skill === 'Fly') {
						if (sizeMap.skillSize !== 0) {
							ranks -= sizeMap.skillSize;
						}
					}
					if (racial && racial.skillmods && racial.skillmods[skill]) {
						ranks -= parseInt(racial.skillmods[skill], 10) || 0;
					}
					if (parseInt(memo[skill + "-feat"], 10) > 0) {
						ranks -= parseInt(memo[skill + "-feat"], 10) || 0;
					}
					if (parseInt(memo[skill + "-cs"], 10) > 0) {
						ranks -= 3;
					}
					memo[skill + "-ranks"] = ranks;
					memo[skill + "-ability-mod"] = abilitymod;
					runningTot++;
				} else {
					_exportsLoaderTASTheAaronSheet2.default.warn("createSkillEntries, skill " + skill + " not found");
				}
			} catch (err) {
				_exportsLoaderTASTheAaronSheet2.default.error("createSkillEntries inner reduce", err);
			} finally {
				return memo;
			}
		}, setter);
	} catch (errouter) {
		_exportsLoaderTASTheAaronSheet2.default.error("at createskillEntries OUTER error", errouter);
	} finally {
		return setter;
	}
}
/**createInitEntries adds init,init-misc,init-misc-mod,init-ability-mod values to setter
 * @param {Map<string,any>} setter the map to pass to setAttrs
 * @param {number} baseInit the total initiative bonus
 * @param {Map<string,{Map<string,number>>} abilityScores output of parseAbilityScores
 * @param {[string]} importantFeats list of attack-affecting feats this char has, IGNORED
 * @returns {Map<string,any>} setter 
 */
function createInitEntries(setter, baseInit, abilityScores, importantFeats) {
	var initMisc = 0;
	try {
		setter = setter || {};
		initMisc = baseInit - abilityScores.dex.mod;
		setter["init"] = baseInit;
		setter["init-misc"] = initMisc;
		setter["init-misc-mod"] = initMisc;
		setter["init-ability-mod"] = abilityScores.dex.mod;
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("createInitEntries", err);
	} finally {
		return setter;
	}
}

function createHPAbilityModEntry(setter, abilityScores, isUndead) {
	try {
		if (isUndead || abilityScores.con.base === "-") {
			setter["HP-ability"] = "@{CHA-mod}";
			setter["HP-ability-mod"] = abilityScores.cha.mod;
		} else {
			setter["HP-ability-mod"] = abilityScores.con.mod;
		}
	} finally {
		return setter;
	}
}
function createHealthEntries(setter, abilityScores, isUndead, hpMap) {
	var currlevel = 0;
	try {
		setter["npc-hd-num"] = hpMap.hdice1;
		setter["level"] = hpMap.hdice1;
		setter["npc-hd"] = hpMap.hdie1;
		setter["HP"] = hpMap.hp;
		setter["HP_max"] = hpMap.hp;
		setter["non-lethal-damage_max"] = hpMap.hp;
		setter["auto_calc_hp"] = "1";
		setter["both_whisper_show"] = "1";
		//NPC: add to race row of class/race grid
		if (hpMap.basehp) {
			setter["NPC-HP"] = hpMap.basehp;
		}
		//bonuses
		if (hpMap.misc) {
			setter["HP-formula-macro-text"] = hpMap.misc;
			setter["HP-formula-mod"] = hpMap.misc;
		}
		if (hpMap.heal) {
			setter["npc-heal-conditions"] = hpMap.heal;
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("createHealthEntries", err);
	} finally {
		return setter;
	}
}
function createSpeedEntries(setter, speedMap, importantFeats) {
	var tempstr = "";
	try {
		_underscore2.default.each(speedMap, function (speed, stype) {
			switch (stype) {
				case 'land':
					setter["speed-base"] = speed;
					setter["speed-modified"] = speed;
					break;
				case 'fly':
					setter["speed-fly"] = speed;
					break;
				case 'climb':
					setter["speed-climb"] = speed;
					break;
				case 'swim':
					setter["speed-swim"] = speed;
					break;
				case 'flyability':
					tempstr += "Fly (" + speed + ")";
					break;
				default:
					setter["speed-misc"] = speed;
					if (tempstr.length > 0) {
						tempstr += ", ";
					}
					tempstr += stype + " " + speed;
					break;
			}
		});
		if (tempstr) {
			setter["speed-notes"] = tempstr;
		}
		if (importantFeats.run) {
			setter["run-mult"] = 5;
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("parseAndSetSpeed error, speedMap", speedMap, err);
	} finally {
		return setter;
	}
}
function createSaveEntries(setter, abilityScores, isUndead, baseSaves, v) {
	var fortMisc,
	    refMisc,
	    willMisc,
	    tempNote = "",
	    tempstr = "";
	try {
		fortMisc = baseSaves.baseFort - abilityScores.con.mod;
		refMisc = baseSaves.baseRef - abilityScores.dex.mod;
		willMisc = baseSaves.baseWill - abilityScores.wis.mod;
		if (isUndead || abilityScores.con.base === "-") {
			fortMisc = baseSaves.baseFort - abilityScores.cha.mod;
			setter["Fort-ability"] = "@{CHA-mod}";
			setter["Fort-ability-mod"] = abilityScores.cha.mod;
		} else {
			setter["Fort-ability-mod"] = abilityScores.con.mod;
		}
		setter["npc-Fort"] = fortMisc;
		setter["Fort"] = baseSaves.baseFort;
		tempNote = "";
		tempstr = PFUtils.getNoteAfterNumber(v["fort_compendium"]);
		if (tempstr) {
			tempNote += "Fortitude " + tempstr;
		}
		setter["npc-Ref"] = refMisc;
		setter["Ref"] = baseSaves.baseRef;
		if (abilityScores.dex.mod !== 0) {
			setter["Ref-ability-mod"] = abilityScores.dex.mod;
		}
		tempstr = PFUtils.getNoteAfterNumber(v["ref_compendium"]);
		if (tempstr) {
			tempNote += "Reflex " + tempstr;
		}
		setter["npc-Will"] = willMisc;
		setter["Will"] = baseSaves.baseWill;
		if (abilityScores.wis.mod !== 0) {
			setter["Will-ability-mod"] = abilityScores.wis.mod;
		}
		tempstr = PFUtils.getNoteAfterNumber(v["will_compendium"]);
		if (tempstr) {
			tempNote += "Willpower " + tempstr;
		}
		if (tempNote) {
			setter["saves_notes"] = tempNote;
			setter["toggle_save_notes"] = "1";
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("createSaveEntries", err);
	} finally {
		return setter;
	}
}
function createAbilityScoreEntries(setter, abilityScores) {
	try {
		setter["STR-base"] = abilityScores.str.base;
		setter["DEX-base"] = abilityScores.dex.base;
		setter["CON-base"] = abilityScores.con.base;
		setter["WIS-base"] = abilityScores.wis.base;
		setter["INT-base"] = abilityScores['int'].base;
		setter["CHA-base"] = abilityScores.cha.base;
		setter["STR"] = abilityScores.str.base;
		setter["DEX"] = abilityScores.dex.base;
		setter["CON"] = abilityScores.con.base;
		setter["WIS"] = abilityScores.wis.base;
		setter["INT"] = abilityScores['int'].base;
		setter["CHA"] = abilityScores.cha.base;
		setter["STR-mod"] = abilityScores.str.mod;
		setter["DEX-mod"] = abilityScores.dex.mod;
		setter["CON-mod"] = abilityScores.con.mod;
		setter["WIS-mod"] = abilityScores.wis.mod;
		setter["INT-mod"] = abilityScores['int'].mod;
		setter["CHA-mod"] = abilityScores.cha.mod;
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("createAbilityScoreEntries", err);
	} finally {
		return setter;
	}
}
function parseAndCreateAttacks(setter, abilityScores, sizeMap, importantFeats, bab, attackGrid, reachObj, v) {
	var attacklist,
	    attackArrays,
	    matches,
	    tempstr = '',
	    defReach = 5,
	    tempCMB,
	    miscCMB = 0,
	    calcCMB = 0,
	    reachExceptions = [];
	try {
		if (reachObj) {
			if (reachObj.reach) {
				defReach = reachObj.reach;
			}
			if (reachObj.reachExceptions) {
				reachExceptions = reachObj.reachExceptions;
			}
		}
		setter["bab"] = bab;
		setter["npc-bab"] = bab;
		setter["melee-ability-mod"] = abilityScores.str.mod;
		setter["attk-melee"] = abilityScores.str.mod + bab + sizeMap.size;
		attackGrid.melee = abilityScores.str.mod + bab + sizeMap.size;
		setter["ranged-ability-mod"] = abilityScores.dex.mod;
		setter["attk-ranged"] = abilityScores.dex.mod + bab + sizeMap.size;
		attackGrid.ranged = abilityScores.dex.mod + bab + sizeMap.size;
		if (importantFeats.criticalfocus) {
			setter["cmb_crit_conf"] = 4;
			setter["ranged_crit_conf"] = 4;
			setter["melee_crit_conf"] = 4;
		}
		if (importantFeats.weaponfinesse) {
			setter["melee2-ability"] = "@{DEX-mod}";
			setter["melee2-ability-mod"] = abilityScores.dex.mod;
			setter["attk-melee2"] = abilityScores.dex.mod + bab + sizeMap.size;
			attackGrid.melee2 = abilityScores.dex.mod + bab + sizeMap.size;
			setter["attk_melee2_note"] = 'Weapon Finesse';
			if (importantFeats.criticalfocus) {
				setter["melee2_crit_conf"] = 4;
			}
		}
		try {
			if (importantFeats.agilemaneuvers) {
				setter["CMB-ability"] = "@{DEX-mod}";
				setter["CMB-ability-mod"] = abilityScores.dex.mod;
				calcCMB = abilityScores.dex.mod + bab - sizeMap.size;
				setter["cmb_desc"] = 'Agile Maneuvers';
			} else {
				setter["CMB-ability-mod"] = abilityScores.str.mod;
				calcCMB = abilityScores.str.mod + bab - sizeMap.size;
			}
			matches = v.cmb_compendium.match(/\d+/);
			if (matches) {
				tempCMB = parseInt(matches[0], 10);
				miscCMB = tempCMB - calcCMB;
				setter["CMB"] = tempCMB;
				attackGrid.cmb = tempCMB;
				if (miscCMB) {
					setter["attk-CMB-misc"] = miscCMB;
				}
				tempstr = v.cmb_compendium.slice(matches.index + matches[0].length);
				if (tempstr) {
					attackGrid.cmbnotes = tempstr;
					setter["CMB-notes"] = tempstr;
				}
			} else {
				setter["CMB"] = calcCMB;
				attackGrid.cmb = calcCMB;
			}
		} catch (errC) {
			_exportsLoaderTASTheAaronSheet2.default.error("parseAndCreateAttacks error creating CMB attack types", errC);
		}
		// Attacks *****************************
		if (v["npc-melee-attacks-text"]) {
			try {
				attacklist = parseAttacks(v["npc-melee-attacks-text"], "melee");
				assignPrimarySecondary(attacklist);
				setter = createAttacks(attacklist, setter, attackGrid, abilityScores, importantFeats, defReach, reachExceptions, sizeMap);
			} catch (errM) {
				_exportsLoaderTASTheAaronSheet2.default.error("parseAndCreateAttacks error creating melee attacks", errM);
			}
		}
		if (v["npc-ranged-attacks-text"]) {
			try {
				attacklist = parseAttacks(v["npc-ranged-attacks-text"], "ranged");
				setter = createAttacks(attacklist, setter, attackGrid, abilityScores, importantFeats, null, null, sizeMap);
			} catch (errR) {
				_exportsLoaderTASTheAaronSheet2.default.error("parseAndCreateAttacks error creating ranged attacks", errR);
			}
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("parseAndCreateAttacks", err);
	} finally {
		return setter;
	}
}
/*createFeatEntries
 *@returns setter */
function createFeatEntries(setter, featlist) {
	return _underscore2.default.reduce(featlist, function (memo, feat) {
		var newRowId = generateRowID(),
		    prefix = "repeating_ability_" + newRowId + "_";
		memo[prefix + "name"] = feat;
		memo[prefix + "rule_category"] = "feats";
		memo[prefix + "showinmenu"] = "1";
		memo[prefix + "CL-basis"] = "@{npc-hd-num}";
		memo[prefix + "CL-basis-mod"] = setter.level || 0;
		if (setter["race"]) {
			memo[prefix + 'class-name'] = setter["race"];
		}
		memo[prefix + "row_id"] = newRowId;
		memo[prefix + "frequency"] = 'not-applicable'; //'not-applicable';
		memo[prefix + 'ability_type'] = ''; //'not-applicable';
		return memo;
	}, setter);
}
/**createFeatureEntries
  *@returns {Map<string,any>} setter
  */
function createFeatureEntries(setter, abilitylist, abilityScoreMap) {
	var attrs = {},
	    creatureRace = "",
	    tempint = 0,
	    dc = 0,
	    abilityMod = 0,
	    charlevel = 0,
	    calcDC = 0;
	try {
		//TAS.debug("at createFeatureEntries:", abilitylist);
		charlevel = Math.floor((parseInt(setter.level, 10) || 0) / 2);
		creatureRace = setter["race"];
		attrs = _underscore2.default.chain(abilitylist).map(function (ability) {
			var match = null,
			    tempstr;
			//copy only settings we want to keep and return them in a new obj.
			//TAS.debug("first iter: ", ability);
			try {
				ability.description = ability.description || '';
				if (ability.note) {
					if (ability.description) {
						ability.description += ', ';
					}
					ability.description += ability.note.replace(/,\s$/, '');
				}
				if (ability.other) {
					if (ability.description) {
						ability.description += ', ';
					}
					ability.description += ability.other.replace(/,\s$/, '');
					ability.other = null;
				}
				if (!ability.ability_type) {
					if (ability.name) {
						tempstr = PFUtils.getSpecialAbilityTypeFromString(ability.name);
						if (tempstr) {
							ability.ability_type = tempstr;
							ability.name = ability.name.replace(/\b(Su|Ex|Sp)\b/i, '').replace('()', '');
						}
					}
				}
			} catch (err3) {
				_exportsLoaderTASTheAaronSheet2.default.error("createFeatureEntries err3", err3);
			} finally {
				//TAS.debug("this ability is:", ability);
				return ability;
			}
		}).filter(function (ability) {
			if (ability.name) {
				return true;
			}
			return false;
		}).reduce(function (memo, ability) {
			var newRowId, prefix;
			try {
				newRowId = generateRowID();
				prefix = "repeating_ability_" + newRowId + "_";
				memo[prefix + "name"] = ability.name;
				memo[prefix + "row_id"] = newRowId;
				memo[prefix + "showinmenu"] = '1';
				if (ability.shortdesc) {
					memo[prefix + 'short-description'] = ability.shortdesc;
				}
				if (ability.description) {
					memo[prefix + 'description'] = ability.description;
				}
				if (ability.used) {
					if (ability.frequency && ability.frequency === 'everyrounds') {
						memo[prefix + "frequency"] = ability.frequency;
						memo[prefix + 'rounds_between'] = ability.used;
					} else {
						if (ability.frequency) {
							memo[prefix + "frequency"] = ability.frequency;
						} else {
							memo[prefix + "frequency"] = 'perday';
						}
						memo[prefix + 'used'] = ability.used;
						memo[prefix + 'used_max'] = ability.used;
						memo[prefix + 'max-calculation'] = ability.used;
					}
				} else {
					memo[prefix + "frequency"] = 'not-applicable'; //'not-applicable';
				}
				if (ability.dmgtype) {
					memo[prefix + "damage-type"] = ability.dmgtype;
				}
				if (ability.rule_category) {
					memo[prefix + 'rule_category'] = ability.rule_category;
				}
				if (ability.ability_type) {
					memo[prefix + 'ability_type'] = ability.ability_type;
				} else {
					memo[prefix + 'ability_type'] = ''; //'not-applicable';
				}
				memo[prefix + "CL-basis"] = "@{npc-hd-num}";
				memo[prefix + "CL-basis-mod"] = setter.level || 0;
				if (creatureRace) {
					memo[prefix + 'class-name'] = creatureRace;
				}
				if (ability.save) {
					memo[prefix + 'save'] = ability.save;
				}

				if (ability.DCability) {
					memo[prefix + 'ability-basis'] = '@{' + ability.DCability.toUpperCase() + '-mod}';
					abilityMod = abilityScoreMap[ability.DCability.toLowerCase()].mod;
				} else if (ability.ability_type === 'Sp' || setter.is_undead) {
					memo[prefix + 'ability-basis'] = '@{CHA-mod}';
					abilityMod = abilityScoreMap.cha.mod;
				} else {
					memo[prefix + 'ability-basis'] = '@{CON-mod}';
					abilityMod = abilityScoreMap.con.mod;
				}
				if (ability.extraDamage) {
					memo[prefix + 'damage-macro-text'] = ability.extraDamage;
				}
				if (ability.extraDamageType) {
					memo[prefix + 'damage-type'] = ability.extraDamageType;
				}
				memo[prefix + "spell_level-basis"] = "floor(@{casterlevel}/2)";
				if (ability.DC) {
					dc = parseInt(ability.DC, 10) || 0;
					calcDC = abilityMod + charlevel + 10;
					tempint = dc - calcDC;
					if (tempint !== 0) {
						memo[prefix + "spell_level-misc"] = tempint;
						memo[prefix + "spell_level-misc-mod"] = tempint;
					}
				}
			} catch (ierr2) {
				_exportsLoaderTASTheAaronSheet2.default.error("createFeatureEntries", ierr2);
			} finally {
				return memo;
			}
		}, {}).value();
		//TAS.debug"createFeatureAttrs adding " + _.size(attrs) + " to " + _.size(setter), attrs);
		setter = _underscore2.default.extend(setter, attrs);
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("createFeatureEntries", err);
	} finally {
		return setter;
	}
}
/** appends values of objects in sa2 to sa1 if name already exists in sa1
 * by reference
 * @param {Array} sa1 Array of {} js objects:list of special abilities maps. Must have 'name' property to compare
 * @param {Array} sa2 Array of {} js objects:list of special abilities maps. Must have 'name' property to compare
 * @returns {Array} sa2 concatenated with sa2, for any duplicates, we add properties from the sa2 version to sa1, but do not overwrite.
 */
function combineSpecialAbilities(sa1, sa2) {
	var combined;
	combined = _underscore2.default.map(sa1, function (sa) {
		var existingSA;
		try {
			existingSA = _underscore2.default.findWhere(sa2, { 'name': sa.name });
			if (existingSA) {
				_underscore2.default.each(_underscore2.default.keys(existingSA), function (key) {
					//TAS.debug("combining abilties: "+sa[key]+ " plus "+ existingSA[key]);
					if (key === 'description') {
						sa.description = (sa.description ? sa.description + ", " : "") + (existingSA.description || "");
					} else if (key === 'shortdesc') {
						sa.shortdesc = (sa.shortdesc ? sa.shortdesc + ", " : "") + (existingSA.shortdesc || "");
					} else if (!sa[key] && existingSA[key]) {
						sa[key] = existingSA[key];
					}
				});
			}
		} catch (err1) {
			_exportsLoaderTASTheAaronSheet2.default.error("combineSpecialAbilities err1", err1);
		} finally {
			return sa;
		}
	});
	sa2 = _underscore2.default.reject(sa2, function (sa) {
		if (_underscore2.default.findWhere(sa1, { 'name': sa.name })) {
			return true;
		}
		return false;
	});

	combined = _underscore2.default.union(combined, sa2);
	return combined;
}
function createClassEntries(setter, characterClass) {
	var sumlvls = 0,
	    currlvls = 0,
	    i = 0,
	    startidx = 0,
	    alreadyPresent = false;
	try {
		if (characterClass.CL && characterClass.classname) {
			for (i = 0; i < 7; i++) {
				if (setter["class-" + i + "-name"] || setter["class-" + i + "-level"] > 0) {
					startidx = i;
					if (setter["class-" + i + "-name"].toLowerCase() === characterClass.classname.toLowerCase()) {
						alreadyPresent = true;
						break;
					}
				}
			}
			if (startidx >= 6) {
				_exportsLoaderTASTheAaronSheet2.default.warning("too many classes, cannot add " + characterClass.classname);
			} else {
				setter["class-" + startidx + "-name"] = characterClass.classname || "";
				setter["class-" + startidx + "-level"] = characterClass.CL || 0;
			}
			if (characterClass.CL) {
				currlvls = parseInt(setter.level, 10) || 0;
				currlvls += characterClass.CL || 0;
				setter.level = currlvls;
			}
		}
	} catch (err) {
		_exportsLoaderTASTheAaronSheet2.default.error("createClassEntries", err);
	} finally {
		return setter;
	}
}

/**************************** THE BIG ONE ***********************/
/*importFromCompendium - imports all stuff*/
function importFromCompendium(eventInfo, callback, errorCallback) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.info("##############################################");
		_exportsLoaderTASTheAaronSheet2.default.info("Leaving importFromCompendium");
		if (typeof callback === "function") {
			callback();
		}
	}),
	    errorDone = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.info("##############################################");
		_exportsLoaderTASTheAaronSheet2.default.info("Leaving importFromCompendium NOTHING DONE");
		if (typeof errorCallback === "function") {
			errorCallback();
		}
	}),
	    fields = npcCompendiumAttributesPlayer.concat(["is_npc", "alignment"]);
	getAttrs(fields, function (v) {
		var setter = {},
		    abilityScores = {},
		    sizeMap = {},
		    speedMap = {},
		    hpMap = {},
		    acMap = {},
		    importantFeats = {},
		    reachObj = {},
		    racialModsMap = {},
		    skillsMap = {},
		    attackGrid = {},
		    baseFort = parseInt(v.fort_compendium, 10) || 0,
		    baseRef = parseInt(v.ref_compendium, 10) || 0,
		    baseWill = parseInt(v.will_compendium, 10) || 0,
		    bab = parseInt(v["bab_compendium"], 10) || 0,
		    reachExceptions = [],
		    isUndead = false,
		    specAbilObj = {},
		    npcdesc = '',
		    tempNote = "",
		    tempstr = "",
		    tempInt = 0,
		    tempFloat = 0.0,
		    tempobj = null,
		    baseInit = 0,
		    initMisc = 0,
		    spellcastingclass = -1,
		    cr,
		    featlist,
		    attacklist,
		    hpMod,
		    tempArray,
		    spellObj,
		    casterObj,
		    matches,
		    attackArray,
		    classSkillArray,
		    specialAttacks,
		    SLAs,
		    attackArrays,
		    specialAbilities = {},
		    specialQualities = [],
		    match,
		    baseSaves = {};
		//TAS.debug("importFromCompendium", v);
		try {
			//some basics ***************************************************
			setter['level'] = 0;
			setter["is_npc"] = "1";
			setter['is_v1'] = "1";
			setter['PFSheet_Version'] = String(_PFConst2.default.version.toFixed(2));
			setter = PFMigrate.getAllMigrateFlags(setter);
			if (v.xp_compendium) {
				setter["npc-xp"] = v.xp_compendium;
			}
			if (v.cr_compendium) {
				cr = v.cr_compendium.replace(/\s*cr\s*/i, '');
				cr = SWUtils.trimBoth(cr);
				setter["npc-cr"] = cr;
			}
			setter["PC-Whisper"] = "/w gm";
			//Creature Race and Type *****************************************************
			//undead means use CHA instead of CON
			if (v.type_compendium) {
				setter["npc-type"] = v.type_compendium;
			}
			isUndead = /undead/i.test(v.type_compendium) || /undead/i.test(v.character_name);
			if (isUndead) {
				setter["is_undead"] = "1";
				_exportsLoaderTASTheAaronSheet2.default.warn("is undead! ");
			}
			if (v.character_name) {
				setter["race"] = v["character_name"];
			}

			/****************** class(es)******************************/
			if (v.class_compendium) {
				setter["add_class"] = 1;
				tempInt = 0;
				matches = v.class_compendium.split(/\s*,\s*/g);
				_underscore2.default.each(matches, function (classstr) {
					var lvl = 0,
					    localmatch = classstr.match(/\d+/),
					    newclassstr = classstr;
					tempInt++;
					if (match) {
						lvl = parseInt(match[0], 10) || 0;
						newclassstr = classstr.slice(0, match.index);
						if (match.index + match[0].length <= classstr.length) {
							newclassstr += classstr.slice(match.index + match[0].length);
						}
					}
					setter = createClassEntries(setter, { 'classname': classstr, 'CL': lvl });
				});
				if (tempInt > 1) {
					setter["multiclassed"] = 1;
					setter["class1_show"] = 1;
				}
				tempInt = 0;
			}
			// Ability Scores *****************************************************************
			abilityScores = parseAbilityScores(v);
			setter = createAbilityScoreEntries(setter, abilityScores, isUndead);
			// Size **********************************************************************
			sizeMap = PFSize.getSizeFromText(v.size_compendium);
			if (sizeMap && sizeMap.size !== 0) {
				setter.size = sizeMap.size;
				setter['default_char_size'] = sizeMap.size;
				setter.size_skill = sizeMap.skillSize;
				setter["CMD-size"] = sizeMap.size * -1;
				setter.size_skill_double = sizeMap.skillSize * 2;
			} else {
				setter['size'] = 0;
				setter['default_char_size'] = 0;
				setter.size_skill = 0;
				setter["CMD-size"] = 0;
				setter.size_skill_double = 0;
				if (!sizeMap) {
					sizeMap = { 'size': 0, 'skillSize': 0 };
				}
			}
			// Feats *********************************************************************
			if (v["npc-feats-text"]) {
				try {
					featlist = parseFeats(v["npc-feats-text"]);
					if (featlist && _underscore2.default.size(featlist) > 0) {
						setter = createFeatEntries(setter, featlist);
						importantFeats = buildImportantFeatObj(featlist);
					}
				} catch (featerr) {
					_exportsLoaderTASTheAaronSheet2.default.error("error parsing feats", featerr);
					if (!importantFeats) {
						importantFeats = {};
					}
				}
			}
			// Initiative *****************************************************************
			baseInit = getNPCInit(v.init_compendium);
			createInitEntries(setter, baseInit, abilityScores, importantFeats);
			/********************** Saves and defense ************************/
			baseSaves = {
				'baseFort': baseFort,
				'baseRef': baseRef,
				'baseWill': baseWill
			};
			if (v.dr_compendium) {
				setter["DR"] = v.dr_compendium;
			}
			if (v.sr_compendium) {
				setter["SR"] = v.sr_compendium;
				setter["SR-macro-text"] = v.sr_compendium;
			}
			createSaveEntries(setter, abilityScores, isUndead, baseSaves, v);

			//hit points ****************************
			createHPAbilityModEntry(setter, abilityScores, isUndead);
			hpMod = parseInt(setter["HP-ability-mod"], 10);
			//TAS.debug("calling parse hp with con mod of :" + hpMod);
			hpMap = parseNPChp(v["npc_hp_compendium"], hpMod);
			createHealthEntries(setter, abilityScores, isUndead, hpMap);

			//AC ************************************************
			acMap = parseNPCAC(v["ac_compendium"], v.cmd_compendium, abilityScores.dex.mod, sizeMap.size);
			createACEntries(setter, acMap, abilityScores, importantFeats, hpMap, bab);
			// Reach *******************************************
			reachObj = parseReach(v.reach_compendium);
			if (reachObj) {
				setter.reach = reachObj.reach;
				if (reachObj.reachNotes) {
					setter["reach-notes"] = reachObj.reachNotes;
				}
			} else {
				reachObj = {};
				reachObj.reach = 5;
				reachObj.reachExceptions = [];
			}
			// Attacks *********************************************************
			parseAndCreateAttacks(setter, abilityScores, sizeMap, importantFeats, bab, attackGrid, reachObj, v);
			//TAS.debug("after parseAndCreateAttacks attrnum:" + _.size(setter));
			//special Attacks ***************************************************
			specialAttacks = parseSpecialAttacks(setter, v["npc-special-attacks"], attackGrid.cmb);
			if (specialAttacks && specialAttacks.length > 0) {
				attackArrays = _underscore2.default.groupBy(specialAttacks, 'specialtype');
				setter = createAttacks(attackArrays.attack, setter, attackGrid, abilityScores, importantFeats, null, null, sizeMap);
				specialAbilities = attackArrays.ability;
				//TAS.debug("after createSpecialAttackEntries attrnum:" + _.size(setter));
			}
			//spells***************************************************
			//TAS.debug("checking for spells");
			if (v["npc-spells-known-text"]) {
				//advance index
				spellcastingclass = 0;
				setter['use_spells'] = 1;
				//TAS.debug("has some spells");
				spellObj = parseSpells(v["npc-spells-known-text"]);
				//TAS.debug("the spells are:",spellObj);
				if (spellObj) {
					setter['use_spells'] = 1;
					casterObj = getCasterObj(spellObj, abilityScores, hpMap);
					//do not add caster levels to hit dice or it gets screwed up
					//setter = createClassEntries (setter,casterObj);
					setter = setCasterFields(setter, casterObj, spellcastingclass);
					setter = createSpellEntries(setter, spellObj, casterObj);
				}
			}
			//Spell-like-abilities***************************************************
			//TAS.debug("checking for SLAs");
			if (v["npc-spellike-ability-text"]) {
				SLAs = parseSLAs(v["npc-spellike-ability-text"]);
				if (SLAs) {
					//TAS.debug("the SLAs are:", SLAs);
					casterObj = getCasterObj(SLAs, abilityScores, hpMap, true);
					setter = createSLAEntries(setter, SLAs, casterObj);
				}
			}
			//TAS.debug("before parsing special abilities are:", specialAbilities);
			// content and special abilities ***************************
			if (v.content_compendium) {
				//TAS.debug("before parseSpecialAbilities attrnum:"+_.size(setter));
				specAbilObj = parseSpecialAbilities(v.content_compendium);

				//TAS.debug("returned from parse special ablities with", specAbilObj);
				if (specAbilObj) {
					if (specAbilObj.description && _underscore2.default.size(specAbilObj.description) > 0) {
						npcdesc = _underscore2.default.reduce(specAbilObj.description, function (memo, line) {
							memo += " ";
							memo += line;
							return memo;
						}, "");
						setter["character_description"] = npcdesc;
					}
					if (specAbilObj.specialAbilities) {
						specialAbilities = combineSpecialAbilities(specialAbilities, specAbilObj.specialAbilities);
					}
				} else {
					v['character-description'] = v.content_compendium;
				}
				//TAS.debug("now special abilities are:", specialAbilities);
			}
			if (v.SQ_compendium) {
				//TAS.debug("found special qualities");
				specialQualities = parseSpecialQualities(v.SQ_compendium);
				if (specialQualities) {
					specialAbilities = combineSpecialAbilities(specialAbilities, specialQualities);
				}
			}
			if (specialAbilities && _underscore2.default.size(specialAbilities) > 0) {
				setter = createFeatureEntries(setter, specialAbilities, abilityScores);
				//look for sneak attack
				tempobj = _underscore2.default.find(specialAbilities, function (atkobj) {
					return (/sneak.attack/i.test(atkobj.name)
					);
				});
				if (tempobj) {
					setter['global_precision_dmg_macro'] = '[[[[floor((@{level}+1)/2)]]d6]]';
					setter['global_precision_dmg_type'] = tempobj.name;
				}

				//TAS.debug("after createFeatureEntries attrnum:" + _.size(setter));
			}

			// Misc *********************************************
			if (v.senses_compendium) {
				match = v.senses_compendium.match(/perception/i);
				if (match) {
					setter["vision"] = v.senses_compendium.slice(0, match.index - 1);
				} else {
					setter["vision"] = v.senses_compendium;
				}
			}
			if (v.speed_compendium) {
				speedMap = parseSpeed(v.speed_compendium);
				setter = createSpeedEntries(setter, speedMap, importantFeats);
			}
			if (v.alignment) {
				setter["alignment"] = v.alignment.toUpperCase();
			}
			if (v.space_compendium) {
				setter["space"] = parseSpace(v.space_compendium);
			}
			//TAS.debug("before skills attrnum:" + _.size(setter));
			// skills *********************************************************
			if (v.skills_compendium) {
				skillsMap = parseSkills(v.skills_compendium);
				classSkillArray = getCreatureClassSkills(v.type_compendium);
				if (v.racial_mods_compendium) {
					racialModsMap = parseSkillRacialBonuses(v.racial_mods_compendium);
				}
				if (skillsMap && _underscore2.default.size(skillsMap) > 0) {
					setter = createSkillEntries(setter, skillsMap, racialModsMap, abilityScores, importantFeats, classSkillArray, sizeMap, isUndead);
					//TAS.debug("after createSkillEntries attrnum:" + _.size(setter));
				}
			}
		} catch (err2) {
			_exportsLoaderTASTheAaronSheet2.default.error("importFromCompendium outer at end", err2);
		} finally {
			if (_underscore2.default.size(setter) > 0) {
				setter["npc_import_now"] = 0;
				setter['npc-compimport-show'] = 0;
				_exportsLoaderTASTheAaronSheet2.default.info("##############################################", "END OF importFromCompendium");
				_exportsLoaderTASTheAaronSheet2.default.debug("setting", setter);
				setAttrs(setter, _PFConst2.default.silentParams, done);
			} else {
				setter["npc_import_now"] = 0;
				setter['npc-compimport-show'] = 0;
				setAttrs(setter, _PFConst2.default.silentParams, errorDone);
			}
		}
	});
}

_PFLog.PFConsole.log('   NPCParser module loaded        ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.migrate = migrate;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _PFLog = __webpack_require__(0);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* **************PSIONIC************** */
function updatePsionicBonusPower(callback, silently) {
	var done = _underscore2.default.once(function () {
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["selected-ability-psionic-power", "psionic-level-total", "ability-psionic-power"], function (v) {
		SWUtils.evaluateExpression(v["selected-ability-psionic-power"], function (value) {
			var ability = 0,
			    currentTotal = 0,
			    newTotal = 0,
			    params = {},
			    finished = false;
			try {
				ability = parseInt(value, 10) || 0;
				currentTotal = parseInt(v["ability-psionic-power"], 10) || 0;
				newTotal = Math.floor(ability * (parseInt(v["psionic-level-total"], 10) || 0) * 0.5);
				//TAS.debug("ability=" + ability, "newTotal=" + newTotal, "currentTotal=" + currentTotal);
				if (currentTotal !== newTotal) {
					if (silently) {
						params = _PFConst2.default.silentParams;
					}
					finished = true;
					setAttrs({
						"ability-psionic-power": newTotal
					}, params, done);
				}
			} catch (err) {
				_exportsLoaderTASTheAaronSheet2.default.error("PFPsionic.updatePsionicBonusPower", err);
			} finally {
				if (!finished) {
					done();
				}
			}
		});
	});
}
function migrate(callback) {
	if (typeof callback === "function") {
		callback();
	}
}
function recalculate(callback, silently, oldversion) {
	var done = _underscore2.default.once(function () {
		_exportsLoaderTASTheAaronSheet2.default.info("Leaving PFPsionic.recalculate");
		if (typeof callback === "function") {
			callback();
		}
	});
	getAttrs(["psionics-show"], function (v) {
		try {
			if (parseInt(v["psionics-show"], 10) === 1) {
				updatePsionicBonusPower(done, silently);
			} else {
				done();
			}
		} catch (err2) {
			_exportsLoaderTASTheAaronSheet2.default.error("PFPsionic.recalculate", err2);
			done();
		}
	});
}
function registerEventHandlers() {
	on("change:psionic-level change:psionic-level-misc", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdatePsionicLevel(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
			SWUtils.updateRowTotal(["psionic-level-total", "psionic-level", "psionic-level-misc"]);
		}
	}));
	on("change:class-psionic-power change:ability-psionic-power change:misc-psionic-power", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdatePsionicPower(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api" || eventInfo.sourceType === "sheetworker" && eventInfo.sourceAttribute === 'ability-psionic-power') {
			SWUtils.updateRowTotal(["psionic-power_max", "class-psionic-power", "ability-psionic-power", "misc-psionic-power"]);
		}
	}));
	on("change:selected-ability-psionic-power change:psionic-level-total", _exportsLoaderTASTheAaronSheet2.default.callback(function eventUpdatePsionicBonusPower(eventInfo) {
		_exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
		updatePsionicBonusPower();
	}));
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFPsionic module loaded        ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.optionTemplateRegexes = exports.optionTemplates = exports.optionToggles = undefined;
exports.updateSpellOption = updateSpellOption;
exports.getOptionText = getOptionText;
exports.resetOption = resetOption;
exports.resetOptions = resetOptions;
exports.recalculate = recalculate;

var _underscore = __webpack_require__(2);

var _underscore2 = _interopRequireDefault(_underscore);

var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFLog = __webpack_require__(0);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _SWUtils = __webpack_require__(4);

var SWUtils = _interopRequireWildcard(_SWUtils);

var _PFUtils = __webpack_require__(5);

var PFUtils = _interopRequireWildcard(_PFUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var optionToggles = exports.optionToggles = ["toggle_spell_school_notes", "toggle_spell_casting_time_notes", "toggle_spell_duration_notes", "toggle_spell_saving_throw_notes", "toggle_spell_sr_notes", "toggle_spell_range_notes", "toggle_spell_targets_notes", "toggle_spell_description_notes", "toggle_spell_concentration_notes", "toggle_spell_concentration_check", "toggle_spell_casterlevel_notes", "toggle_spell_casterlevel_check", "toggle_spell_level_notes", "toggle_spell_components_notes", "toggle_spell_spellnotes_notes", "toggle_spell_spell_fail_check", "toggle_spell_damage_notes"],
    optionTemplates = exports.optionTemplates = {
    school: "{{school=REPLACE}}",
    casting_time: "{{casting_time=REPLACE}}",
    components: "{{components=REPLACE}}",
    duration: "{{duration=REPLACE}}",
    saving_throw: "{{saving_throw=REPLACE}}",
    sr: "{{sr=REPLACE}}",
    casterlevel: "{{casterlevel=[[ REPLACE ]]}}",
    range: "{{range=REPLACE}}",
    targets: "{{targets=REPLACE}}",
    Concentration: "{{Concentration=[[ REPLACE ]]}}",
    description: "{{description=REPLACE}}",
    dc: "{{dc=[[ REPLACE ]]}}",
    spellPen: "{{spellPen=[[ REPLACE ]]}}",
    range_pick: "{{REPLACE=Range_pick}}",
    rangetext: "{{rangetext=REPLACE}}",
    level: "{{level=REPLACE}}",
    spellclass: "{{spellclass=REPLACE}}",
    cast_def: "{{cast_def=[[ REPLACE ]]}}",
    cast_defDC: "{{cast_defDC=[[ REPLACE ]]}}",
    concentrationNote: "{{concentrationNote=REPLACE}}",
    spellPenNote: "{{spellPenNote=REPLACE}}",
    casterlevel_chk: "{{casterlevel_chk=[[ 1d20 + REPLACE ]]}}",
    Concentration_chk: "{{Concentration_chk=[[ 1d20 + REPLACE ]]}}",
    spellnotes: "{{spells_notes=REPLACE}}",
    spell_fail_check: "{{spell_fail_check=[[ 1d100cf<[[ @{spell-fail} ]]cs>[[ @{spell-fail}+1 ]] ]]}}",
    spell_fail: "{{spell_fail=@{spell-fail}}}",
    spelldamage: "{{spelldamage=REPLACE}}",
    spelldamagetype: "{{spelldamagetype=REPLACE}}"
},
    optionTemplateRegexes = exports.optionTemplateRegexes = PFUtils.getOptionsCompiledRegexMap(optionTemplates);

/* non repeating */
var optionAttrs = ["Concentration-0-def", "Concentration-1-def", "Concentration-2-def", "spell-fail"],
    optionTogglesPlusOptionAttrs = optionToggles.concat(optionAttrs),

/* repeating*/
repeatingOptionAttrs = ["school", "cast-time", "duration", "save", "sr", "range_numeric", "targets", "description", "Concentration-mod", "savedc", "SP-mod", "range_pick", "range", "spell_level", "spellclass", "casterlevel", "components", "spellclass_number", "damage-macro-text", "damage-type"],
    repeatingOptionHelperAttrs = ["spellclass_number", "SP_misc", "CL_misc", "Concentration_misc", "slot", "spell-attack-type"],
    repeatingOptionAttrsToGet = repeatingOptionAttrs.concat(repeatingOptionHelperAttrs),
    rowattrToOptionToggleMap = {
    school: "toggle_spell_school_notes",
    "cast-time": "toggle_spell_casting_time_notes",
    components: "toggle_spell_components_notes",
    duration: "toggle_spell_duration_notes",
    save: "toggle_spell_saving_throw_notes",
    sr: "toggle_spell_sr_notes",
    range: "toggle_spell_range_notes",
    targets: "toggle_spell_targets_notes",
    description: "toggle_spell_description_notes",
    spellnotes: "toggle_spells_notes",
    spell_fail_check: "toggle_spell_spell_fail_check",
    "damage-macro-text": "toggle_spell_damage_notes",
    "damage-type": "toggle_spell_damage_notes"
},
    events = {
    spellOptionEventsPlayer: ["school", "cast-time", "components", "duration", "save", "sr", "range", "targets", "damage-macro-text", "damage-type"]
};
/** updateSpellOption - updates an existing @{spell_options} text for a row depending on the field updated on existing row
 * 
 * @param {obj} eventInfo 
 * @param {string} fieldUpdated 
 */
function updateSpellOption(eventInfo, fieldUpdated) {
    var fieldName = "repeating_spells_" + fieldUpdated,
        toggleField = rowattrToOptionToggleMap[fieldUpdated];
    getAttrs([fieldName, "repeating_spells_spell_options", "repeating_spells_spell_lvlstr", toggleField, "repeating_spells_SP-mod", "repeating_spells_savedc"], function (v) {
        var optionText = v["repeating_spells_spell_options"],
            newValue = "",
            setter = {};
        //make sure we are not updating from compendium
        //this works it is just fast enough that it will not do anything since importFromCompendium is not done.
        if (!v["repeating_spells_spell_lvlstr"] && optionText) {
            try {
                //TAS.debug("PFSpellOptions.updateSpellOption, field: "+ fieldUpdated,v);
                newValue = v[fieldName] || "";
                if (parseInt(v[toggleField], 10) === 1) {
                    //TAS.debug"made it inside toggleField");
                    switch (fieldUpdated) {
                        case 'school':
                            optionText = optionText.replace(optionTemplateRegexes.school, optionTemplates.school.replace("REPLACE", SWUtils.escapeForRollTemplate(newValue)));
                            break;
                        case 'cast-time':
                            optionText = optionText.replace(optionTemplateRegexes.casting_time, optionTemplates.casting_time.replace("REPLACE", SWUtils.escapeForRollTemplate(newValue)));
                            break;
                        case 'components':
                            optionText = optionText.replace(optionTemplateRegexes.components, optionTemplates.components.replace("REPLACE", SWUtils.escapeForRollTemplate(newValue)));
                            break;
                        case 'duration':
                            optionText = optionText.replace(optionTemplateRegexes.duration, optionTemplates.duration.replace("REPLACE", SWUtils.escapeForRollTemplate(newValue)));
                            break;
                        case 'range':
                            optionText = optionText.replace(optionTemplateRegexes.range, optionTemplates.range.replace("REPLACE", SWUtils.escapeForRollTemplate(newValue)));
                            break;
                        case 'targets':
                            optionText = optionText.replace(optionTemplateRegexes.targets, optionTemplates.targets.replace("REPLACE", SWUtils.escapeForRollTemplate(newValue)));
                            break;
                        case 'save':
                            if (PFUtils.shouldNotDisplayOption('saving_throw', newValue)) {
                                optionText = PFUtils.deleteOption(optionText, "saving_throw", optionTemplateRegexes);
                            } else {
                                optionText = optionText.replace(optionTemplateRegexes.saving_throw, optionTemplates.saving_throw.replace("REPLACE", SWUtils.escapeForRollTemplate(newValue)));
                            }
                            break;
                        case 'sr':
                            if (PFUtils.shouldNotDisplayOption('sr', newValue)) {
                                optionText = PFUtils.deleteOption(optionText, "sr", optionTemplateRegexes);
                            } else {
                                optionText = optionText.replace(optionTemplateRegexes.sr, optionTemplates.sr.replace("REPLACE", newValue));
                            }
                            break;
                        case 'damage-macro-text':
                            //TAS.debug"found damage macro-text="+newValue);
                            if (PFUtils.shouldNotDisplayOption('damage-macro-text', newValue)) {
                                optionText = PFUtils.deleteOption(optionText, "spelldamage", optionTemplateRegexes);
                            } else {
                                optionText = optionText.replace(optionTemplateRegexes.spelldamage, optionTemplates.spelldamage.replace("REPLACE", newValue));
                            }
                            break;
                        case 'damage-type':
                            //TAS.debug"found damage type"+newValue);
                            if (PFUtils.shouldNotDisplayOption('damage-type', newValue)) {
                                optionText = PFUtils.deleteOption(optionText, "spelldamagetype", optionTemplateRegexes);
                            } else {
                                optionText = optionText.replace(optionTemplateRegexes.spelldamagetype, optionTemplates.spelldamagetype.replace("REPLACE", newValue));
                            }
                            break;
                    }
                    setter["repeating_spells_spell_options"] = optionText;
                    setAttrs(setter, {
                        silent: true
                    });
                }
            } catch (err) {
                _exportsLoaderTASTheAaronSheet2.default.error("PFSpellOptions.updateSpellOption", err);
            }
        }
    });
}
/** getOptionText - resets entire @{spell_options} text for a spell row
* if the field to update is one that is set by updateSpellOption, then need to set {{key=}} so it can find correct one to replace.
*@param {string} id of row or null
*@param {jsobj} eventInfo NOT USED
*@param {object} toggleValues values from getAttrs of spell toggle option fields
*@param {object} rowValues values from getAttrs of row attributes
*@returns {string}
*/
function getOptionText(id, eventInfo, toggleValues, rowValues) {
    var prefix = "repeating_spells_" + SWUtils.getRepeatingIDStr(id),
        customConcentration = parseInt(rowValues[prefix + "Concentration_misc"], 10) || 0,
        customCasterlevel = parseInt(rowValues[prefix + "CL_misc"], 10) || 0,
        classNum = parseInt(rowValues[prefix + "spellclass_number"], 10),
        spellLevel = parseInt(rowValues[prefix + "spell_level"], 10),
        spellSlot = parseInt(rowValues[prefix + "slot"], 10),
        casterlevel = parseInt(rowValues[prefix + "casterlevel"], 10),
        concentrationMod = parseInt(rowValues[prefix + "Concentration-mod"], 10),
        levelForConcentrate = isNaN(spellSlot) || spellSlot === spellLevel ? spellLevel : spellSlot,
        defDC = 15 + levelForConcentrate * 2,
        defMod = parseInt(rowValues["Concentration-" + classNum + "-def"], 10) || 0,
        optionText = "",
        newValue = "";
    //TAS.debug("getOptionText, defMod: " + defMod);
    if (isNaN(classNum) || isNaN(spellLevel)) {
        _exportsLoaderTASTheAaronSheet2.default.warn("cannot set options for spell! id:" + id + "  class or level are not numbers");
        return "";
    }
    if (toggleValues.showschool) {
        optionText += optionTemplates.school.replace("REPLACE", SWUtils.escapeForRollTemplate(rowValues[prefix + "school"])) || "";
    }
    if (toggleValues.showlevel) {
        optionText += optionTemplates.spellclass.replace("REPLACE", SWUtils.escapeForRollTemplate(rowValues[prefix + "spellclass"])) || "";
        optionText += optionTemplates.level.replace("REPLACE", spellLevel);
    }
    if (toggleValues.showcasting_time) {
        optionText += optionTemplates.casting_time.replace("REPLACE", SWUtils.escapeForRollTemplate(rowValues[prefix + "cast-time"])) || "";
    }
    if (toggleValues.showcomponents) {
        optionText += optionTemplates.components.replace("REPLACE", SWUtils.escapeForRollTemplate(rowValues[prefix + "components"])) || "";
    }
    if (toggleValues.showsaving_throw) {
        newValue = rowValues[prefix + "save"] || "";
        if (PFUtils.shouldNotDisplayOption('saving_throw', newValue)) {
            optionText += "{{saving_throw=}}";
        } else {
            optionText += optionTemplates.saving_throw.replace("REPLACE", SWUtils.escapeForRollTemplate(newValue) || "");
        }
        optionText += optionTemplates.dc.replace("REPLACE", parseInt(rowValues[prefix + "savedc"], 10) || 0);
    }
    if (toggleValues.showrange) {
        optionText += optionTemplates.range_pick.replace("REPLACE", rowValues[prefix + "range_pick"] || "blank") || "";
        optionText += optionTemplates.range.replace("REPLACE", parseInt(rowValues[prefix + "range_numeric"], 10) || 0) || "";
        optionText += optionTemplates.rangetext.replace("REPLACE", SWUtils.escapeForRollTemplate(rowValues[prefix + "range"] || "") || "");
    }
    if (toggleValues.showtargets) {
        optionText += optionTemplates.targets.replace("REPLACE", SWUtils.escapeForRollTemplate(rowValues[prefix + "targets"]) || "");
    }
    if (toggleValues.showduration) {
        optionText += optionTemplates.duration.replace("REPLACE", SWUtils.escapeForRollTemplate(rowValues[prefix + "duration"]) || "");
    }
    if (toggleValues.showsr) {
        newValue = rowValues[prefix + "sr"] || "";
        if (PFUtils.shouldNotDisplayOption('sr', newValue)) {
            optionText += "{{sr=}}";
        } else {
            optionText += optionTemplates.sr.replace("REPLACE", newValue) || "";
        }
    }
    if (toggleValues.showcasterlevel && customCasterlevel) {
        optionText += optionTemplates.casterlevel.replace("REPLACE", casterlevel) || "";
    } else {
        optionText += "{{casterlevel=}}";
    }
    if (toggleValues.showcasterlevel_check) {
        optionText += optionTemplates.casterlevel_chk.replace("REPLACE", casterlevel) || "";
    }
    if (toggleValues.showcasterlevel || toggleValues.showcasterlevel_check) {
        newValue = parseInt(rowValues[prefix + "SP-mod"], 10) || 0;
        if (newValue === 0) {
            optionText += "{{spellPen=}}";
        } else {
            optionText += optionTemplates.spellPen.replace("REPLACE", newValue) || "";
        }
    }
    if (toggleValues.showconcentration && customConcentration) {
        optionText += optionTemplates.Concentration.replace("REPLACE", concentrationMod) || "";
    } else {
        optionText += "{{Concentration=}}";
    }
    if (toggleValues.showconcentration_check) {
        optionText += optionTemplates.Concentration_chk.replace("REPLACE", concentrationMod) || "";
    }
    if (toggleValues.showconcentration || toggleValues.showconcentration_check) {
        if (defMod > 0) {
            optionText += optionTemplates.cast_def.replace("REPLACE", defMod) || "";
        } else {
            optionText += "{{cast_def=}}";
        }
        optionText += optionTemplates.cast_defDC.replace("REPLACE", defDC) || "";
    }
    if (toggleValues.showdescription) {
        optionText += optionTemplates.description.replace("REPLACE", "@{description}") || "";
    }
    if (toggleValues.showspellnotes) {
        optionText += optionTemplates.spellnotes.replace("REPLACE", "@{spell-class-" + classNum + "-spells-notes}") || "";
    }
    if (toggleValues.showspell_fail_check && parseInt(rowValues['spell-fail'], 10) > 0) {
        //TAS.debug("adding spellfailure "+optionTemplates.spell_fail_check +" for id "+ id);
        optionText += optionTemplates.spell_fail_check || "";
        optionText += optionTemplates.spell_fail || "";
    }

    if (toggleValues.showdamage) {
        if (!PFUtils.findAbilityInString(rowValues[prefix + "spell-attack-type"])) {
            optionText += optionTemplates.spelldamage.replace("REPLACE", rowValues[prefix + "damage-macro-text"] || "");
        } else {
            optionText += "{{spelldamage=}}";
        }
        if (rowValues["damage-type"]) {
            optionText += optionTemplates.spelldamagetype.replace("REPLACE", rowValues["damage-type"] || "");
        } else {
            optionText += "{{spelldamagetype=}}";
        }
    } else {
        optionText += "{{spelldamage=}}{{spelldamagetype=}}";
    }
    //TAS.debug("PFSpell.resetOption returning "+optionText);
    return optionText;
}
/** resetOption updates repeating_spells_$X_spell_options
*@param {string} id id of row or null
*@param {jsobj} eventInfo NOT USED
*/
function resetOption(id, eventInfo) {
    var prefix = "repeating_spells_" + SWUtils.getRepeatingIDStr(id),
        allFields;
    allFields = _underscore2.default.map(repeatingOptionAttrsToGet, function (field) {
        return prefix + field;
    }).concat(optionTogglesPlusOptionAttrs);
    getAttrs(allFields, function (v) {
        var toggleValues = _underscore2.default.chain(optionToggles).reduce(function (memo, attr) {
            memo['show' + attr.toLowerCase().slice(13).replace('_notes', '')] = parseInt(v[attr], 10) || 0;
            return memo;
        }, {}).extend({
            "Concentration-0-def": parseInt(v["Concentration-0-def"], 10) || 0,
            "Concentration-1-def": parseInt(v["Concentration-1-def"], 10) || 0,
            "Concentration-2-def": parseInt(v["Concentration-2-def"], 10) || 0
        }).value(),
            optionText = "",
            setter = {};
        optionText = getOptionText(id, eventInfo, toggleValues, v) || "";
        //TAS.debug("resetOption","About to set",setter);
        setter["repeating_spells_" + SWUtils.getRepeatingIDStr(id) + "spell_options"] = optionText;
        setAttrs(setter, {
            silent: true
        });
    });
}
/**resetOptions - updates repeating_spells_spell_options for all spells.
*@param {function} callback call when done
*@param {object} eventInfo NOT USED
*/
function resetOptions(callback, eventInfo) {
    var done = _underscore2.default.once(function () {
        if (typeof callback === "function") {
            callback();
        }
    });
    getAttrs(optionTogglesPlusOptionAttrs, function (tv) {
        var optionFields, toggleValues;
        try {
            optionFields = repeatingOptionAttrs.concat(repeatingOptionHelperAttrs);
            toggleValues = _underscore2.default.chain(optionToggles).reduce(function (memo, attr) {
                //get word between toggle_spell_ and _notes
                memo['show' + attr.toLowerCase().slice(13).replace('_notes', '')] = parseInt(tv[attr], 10) || 0;
                return memo;
            }, {}).extend({
                "Concentration-0-def": parseInt(tv["Concentration-0-def"], 10) || 0,
                "Concentration-1-def": parseInt(tv["Concentration-1-def"], 10) || 0,
                "Concentration-2-def": parseInt(tv["Concentration-2-def"], 10) || 0
            }).value();
            getSectionIDs("repeating_spells", function (ids) {
                var fields, prefixes;
                if (!ids || _underscore2.default.size(ids) === 0) {
                    done();
                    return;
                }
                prefixes = _underscore2.default.map(ids, function (id) {
                    return "repeating_spells_" + id + "_";
                });
                fields = SWUtils.cartesianAppend(prefixes, optionFields);
                getAttrs(fields, function (v) {
                    var setter = {};
                    _underscore2.default.each(ids, function (id) {
                        var optionText = '';
                        try {
                            optionText = getOptionText(id, eventInfo, toggleValues, v) || "";
                            //TAS.debug("setting option text for "+id+" to "+optionText);
                            setter["repeating_spells_" + id + "_spell_options"] = optionText;
                        } catch (innererr) {
                            _exportsLoaderTASTheAaronSheet2.default.error("PFSpellOptions.resetOptions error on id " + id + ", innererr", innererr);
                        }
                    });
                    if (_underscore2.default.size(setter) > 0) {
                        setAttrs(setter, _PFConst2.default.silentParams, done);
                    } else {
                        done();
                    }
                });
            });
        } catch (outererr) {
            _exportsLoaderTASTheAaronSheet2.default.error("PFSpellOptions.resetOptions outererr:", outererr);
            done();
        }
    });
}
function recalculate(callback) {
    resetOptions(callback);
}

function registerEventHandlers() {
    //spell options for one row
    _underscore2.default.each(events.spellOptionEventsPlayer, function (fieldToWatch) {
        var eventToWatch = "change:repeating_spells:" + fieldToWatch;
        on(eventToWatch, _exportsLoaderTASTheAaronSheet2.default.callback(function eventOptionsRepeatingSpellsPlayer(eventInfo) {
            if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                updateSpellOption(eventInfo, fieldToWatch);
            }
        }));
    });
    //update the spell options
    _underscore2.default.each(optionToggles, function (toggleField) {
        on("change:" + toggleField, _exportsLoaderTASTheAaronSheet2.default.callback(function toggleSpellOptionField(eventInfo) {
            if (eventInfo.sourceType === "player" || eventInfo.sourceType === "api") {
                _exportsLoaderTASTheAaronSheet2.default.debug("caught " + eventInfo.sourceAttribute + " event: " + eventInfo.sourceType);
                resetOptions(null, eventInfo);
            }
        }));
    });
}
registerEventHandlers();
_PFLog.PFConsole.log('   PFSpellOptions module loaded   ');
_PFLog.PFLog.modulecount++;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _exportsLoaderTASTheAaronSheet = __webpack_require__(1);

var _exportsLoaderTASTheAaronSheet2 = _interopRequireDefault(_exportsLoaderTASTheAaronSheet);

var _PFLog = __webpack_require__(0);

var _PFConst = __webpack_require__(3);

var _PFConst2 = _interopRequireDefault(_PFConst);

var _PFSheet = __webpack_require__(25);

var PFSheet = _interopRequireWildcard(_PFSheet);

var _HLImport = __webpack_require__(31);

var HLImport = _interopRequireWildcard(_HLImport);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_exportsLoaderTASTheAaronSheet2.default.config({
  logging: {
    info: "production" !== 'production',
    debug: "production" !== 'production'
  }
});
if (false) {
  _exportsLoaderTASTheAaronSheet2.default.debugMode();
}
//importing PFSheet imports everything else


_PFLog.PFConsole.log('       ,## /##                    ');
_PFLog.PFConsole.log('      /#/ /  ##                   ');
_PFLog.PFConsole.log('     / / /    ##                  ');
_PFLog.PFConsole.log('      | ##___#/                   ');
_PFLog.PFConsole.log('      | ##       athfinder        ');
_PFLog.PFConsole.log('   #  | ##    sheet version       ');
_PFLog.PFConsole.log('    ### /           ' + ("0000" + _PFConst2.default.version.toFixed(2)).slice(-5) + '         ');
_PFLog.PFConsole.log('                                  ');
_PFLog.PFConsole.log('   PFSheet module loaded          ');
_PFLog.PFLog.modulecount++;
if (_PFLog.PFLog.modulecount === 35) {
  _PFLog.PFConsole.log('   All ' + _PFLog.PFLog.modulecount + ' Modules Loaded          ');
} else {
  _PFLog.PFConsole.log('   ONLY ' + _PFLog.PFLog.modulecount + ' Modules Loaded!        ' + _PFLog.PFLog.r, 'background: linear-gradient(to right,yellow,white,white,yellow); color:black;text-shadow: 0 0 8px white;');
}

/***/ })
/******/ ]);